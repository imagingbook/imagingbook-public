package imagingbook.common.math.eigen;

	// File ported from gov.nih.mipav.model.structures.jama.GeneralizedEigenvalue.java

	/**
	 * This file contains 1 user callable eigenvalue function and 2 user callable generalized eigenvalue functions.
	 * 
	 * <p>
	 * The eigenvalue problem solves the equation: A*x = lambda*x, where A is an n-by-n matrix, x is an n-length column
	 * vector, and lambda is a scalar. The eigenvalues are the n values of lambda that solve the equation, and the
	 * corresponding values of x are the right eigenvectors. The function dsyev solves the eigenvalue problem for the case
	 * of real symmetric matrix A.
	 * </p>
	 * 
	 * <p>
	 * The generalized eigenvalue problem solves the equation: A*x = lambda*B*x where both A and B are n-by-n matrices and
	 * lambda is a scalar. The generalized eigenvalues are the n values of lambda that solve the equation, and the
	 * corresponding values of x are the generalized right eigenvectors. The function dsygv solves the generalized
	 * eigenvalue problem for the case of real symmetric A, symmetric positive definite B. The funciton dggev solves the
	 * generalized eigenvalue problem for the case of real nonsymmetric A, real general B.
	 * </p>
	 * 
	 * <p>
	 * The symmetric generalized eigenvalue driver dsygv was tested with dsygv_test. The statement All 882 tests for dsygv
	 * passed the threshold was repeated 3 times. dchkst_test was implemented to test the dsytrd, dorgtr, dsteqr, and dsterf
	 * routines belonging to the dsygv drver. The statement All 1134 tests for dchkst passed the threshold was repeated 5
	 * times. ddrvst_test was implemented to test dsyev. The statement All 648 tests for ddrvst passed the threshold was
	 * repeated 5 times.
	 * </p>
	 * 
	 * <p>
	 * The nonsymmetric generalized eigenvalue driver dggev was tested with dggev_test. The resulting statement was 21 out
	 * of 1092 dggev tests failed to pass the threshold. Note that updating dgeqr2 from 3.1 to 3.2 increased the number of
	 * errors from 17 to 21. dchkgl was implemented to test the dggbal balancing routine of dggev. All 8 tests showed no
	 * signficant error. dchkgk was implemented to test the dggbak backward balancing routine of dggev. All 8 tests showed
	 * no significant error. dchkgg_test was implemented to test the dgghrd, dhgeqz, and dtgevc routines of the dggev
	 * driver. The following output statements resulted: 15 out of 2121 dchkgg tests failed to pass the threshold. 10 out of
	 * 2156 dchkgg tests failed to pass the threshold. 8 out of 2149 dchkgg tests failed to pass the threshold. 9 out of
	 * 2156 dchkgg tests failed to pass the threshold. The errors in the nonsymmetric case would not occur for matrix sizes
	 * of 5 or less. Following one case in parallel in the FORTRAN on the WATCOM compiler and on Java revealed input
	 * variables that were identical up to about 9 signficant places yielding an output variable of 7.77E-16 on the FORTRAN
	 * and -2.61E-15 on the Java. So apparently the Java failures are due to the Java 64 bit arithmetic having a greater
	 * error than the FORTRAN 64 bit arithmetic.
	 * </p>
	 * 
	 * <p>
	 * dchkqr.test() tests dgeqrf, dorgqr, and dormqr. All 30744 tests run passed the threshold.
	 * </p>
	 * 
	 * Running 8 self-tests: if (runTest) { GeneralizedEigenvalue ge = new GeneralizedEigenvalue(); //ge.dchkgg_test();
	 * ge.dchkst_test(); //ge.ddrvst_test(); //ge.dggev_test(); //ge.dsygv_test(); //ge.dchkgl(); //ge.dchkgk();
	 * //ge.dchkqr.test(); return; }
	 * 
	 * <p>
	 * There are basically 2 problems with Java precision. 1.) The Intel Pentium uses 80 bit numbers in floating point
	 * registers. However, Java must round each number back to 64 bits whenever a Java variable is assigned. There used to
	 * be a proposal to introduce a special keyword extendedfp to fully use whatever math the platform had, but it didn't
	 * get thru. Apparently the Java designers felt for Java being consistent is more important than being successful. 2.)
	 * Java also forbids the use of fused multiply-add (FMA) operations. This operation computes the quantity ax + y as a
	 * single floating-point operation. Operations of this type are found in many compute-intensive applications,
	 * particularly matrix operations. With this instruction, only a single rounding occurs for the two arithmetic
	 * operations, yielding a more accurate result in less time than would be required for two separate operations. Java's
	 * strict language definition does not permit use of FMAs and thus sacrifices up to 50% of performance on some
	 * platforms.
	 * </p>
	 * 
	 * <p>
	 * The only obvious cure for this problem would be to use the Java BigDecimal class. However, the use of BigDecimal
	 * would involve much more work than just changing doubles to BigDecimals. For example, with doubles I would write: f =
	 * f/g; With BigDecimal I would write: f = f.divide(g, mc); where mc is the mathematical context settings. Likewise,
	 * instead of the ordinary arithmetic operators I would have to use add, compareTo, equals, negate, plus, remainder, and
	 * subtract. Using BigDecimal would undoubtedly slow the program down considerably.
	 * </p>
	 * 
	 * <p>
	 * On significant change was made in the port of the nonsymmetric driver. In routine dhgeqz the number of maximum
	 * iterations maxit was increased from 30 * (ihi-ilo+1) to 300 * (ihi-ilo+1)
	 * </p>
	 * 
	 * <hr>
	 * 
	 * <p>
	 * Copyright (c) 1992-2007 The University of Tennessee. All rights reserved.
	 * </p>
	 * 
	 * <p>
	 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
	 * following conditions are met:
	 * </p>
	 * 
	 * <p>
	 * - Redistributions of source code must retain the above copyright notice, this list of conditions and the following
	 * disclaimer.
	 * </p>
	 * 
	 * <p>
	 * - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
	 * disclaimer listed in this license in the documentation and/or other materials provided with the distribution.
	 * </p>
	 * 
	 * <p>
	 * - Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
	 * products derived from this software without specific prior written permission.
	 * </p>
	 * 
	 * <p>
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
	 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
	 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 * </p>
	 */
	public class GeneralizedEigenvalueMipav {

	    private double base;

	    /** DOCUMENT ME! */
	    // private boolean doOnce = true;
	    // To set up for testing the software integrity:
	    // GeneralizedEigenvalue ge = new GeneralizedEigenvalue();
	    // ge.dsygv_test();
	    /** DOCUMENT ME! */
	    private double emax;

	    /** DOCUMENT ME! */
	    private double emin;

	    /** DOCUMENT ME! */
	    private double eps;

	    /**
	     * ------------------------ Class variables ------------------------ Double precision machine parameters found in
	     * routine dlamch.
	     */
	    private boolean first = true;

	    /** Double precison machine variables found in routine dlartg. */
	    private boolean first_dlartg = true;

	    /** Found in routine dlatb4 */
	    private boolean first_dlatb4 = true;
	    private double eps_dlatb4;
	    private final double small_dlatb4[] = new double[1];
	    private final double large_dlatb4[] = new double[1];
	    private double badc1_dlatb4;
	    private double badc2_dlatb4;

	    /** DOCUMENT ME! */
	    private int[] iparms;

	    /** DOCUMENT ME! */
	    private double prec;

	    /** DOCUMENT ME! */
	    private double rmax;

	    /** DOCUMENT ME! */
	    private double rmin;

	    /** DOCUMENT ME! */
	    private double rnd;

	    /** DOCUMENT ME! */
	    private double safmin;

	    /** DOCUMENT ME! */
	    private double safmn2;

	    /** DOCUMENT ME! */
	    private double safmx2;

	    /** DOCUMENT ME! */
	    private double sfmin;

	    /** DOCUMENT ME! */
	    private double t;

//	    /** Common variables in testing routines. */
//	    private ViewUserInterface UI = ViewUserInterface.getReference();

	    // ~ Constructors
	    // ---------------------------------------------------------------------------------------------------

	    /**
	     * Creates a new GeneralizedEigenvalue object.
	     */
	    public GeneralizedEigenvalueMipav() {}
	    
	    public void setSafmin(double safmin) {
	        this.safmin = safmin;
	    }
	    
	    public double getSafmin() {
	        return safmin;
	    }

	    // ~ Methods
	    // --------------------------------------------------------------------------------------------------------

	    /**
	     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive dchkgg in
	     * order to run dchkgg to test the nonsymmetric generalized eigenvalue problem. Tests dgghrd, dhgeqz, and dtgevc.
	     * Numerical values were obtained from the dgg.in datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., January, 2007
	     */
	    private void dchkgg_test() {

	        // Number of values of n
	        final int nn = 7;

	        // Values of matrix dimension n
	        final int[] nval = new int[] {0, 1, 2, 3, 5, 10, 16};

	        // Number of values of NB, NBMIN, NSVAL, MXBVAL, and NBCOL
	        final int nparms = 4;

	        // Values of blocksize NB
	        final int[] nbval = new int[] {1, 1, 2, 2};

	        // Values of minimum row dimension for blocks NBMIN
	        final int[] nbmin = new int[] {40, 40, 2, 2};

	        // Number of shifts NSVAL
	        final int[] nsval = new int[] {2, 4, 2, 4};

	        // The values for MAXB, used in determining minimum blocksize
	        final int[] mxbval = new int[] {40, 40, 2, 2};

	        // The values for NBCOL, the minimum column dimension for blocks
	        final int[] nbcol = new int[] {40, 40, 2, 2};

	        // Threshold value for the test ratios. Information will be printed
	        // about each test for which the test ratio is greater than or equal
	        // to threshold.
	        final double thresh = 20.0;

	        // Test the LAPACK routines
	        final boolean tstchk = true;

	        // Code describing how to set the random number seed.
	        // = 0: Set the seed to a default number before each run.
	        // = 1: Initialize the seed to a default value only before the first
	        // run.
	        // = 2: Like 1, but use the seed values in the 4 integer array
	        // ioldsd
	        int newsd = 1;
	        final int maxt = 30;
	        final boolean[] dotype = new boolean[maxt];
	        final int[] ioldsd = new int[] {0, 0, 0, 1};
	        final int[] iseed = new int[] {0, 0, 0, 1};
	        final int nmax = 132;
	        final int lwork = (nmax * ( (5 * nmax) + 5)) + 1;
	        final boolean[] logwrk = new boolean[nmax];
	        final double[] work = new double[lwork];
	        final double[] result = new double[500];
	        final int[] info = new int[1];
	        final boolean tstdif = false;
	        final double thrshn = 10.0;
	        double[][] A;
	        double[][] B;
	        double[][] H;
	        double[][] T;
	        double[][] S1;
	        double[][] S2;
	        double[][] P1;
	        double[][] P2;
	        double[][] U;
	        double[][] V;
	        double[][] Q;
	        double[][] Z;
	        double[] alphr1;
	        double[] alphi1;
	        double[] beta1;
	        double[] alphr3;
	        double[] alphi3;
	        double[] beta3;
	        double[][] evectl;
	        double[][] evectr;

	        final int maxtyp = 26;
	        int i;
	        int k;
	        int maxnval;
	        System.out.println("Tests of the Generalized Nonsymmetric Eigenvalue Problem routines\n");

	        for (i = 0; i < maxtyp; i++) {
	            dotype[i] = true;
	        }

	        maxnval = 0;

	        for (i = 0; i < nn; i++) {

	            if (nval[i] > maxnval) {
	                maxnval = nval[i];
	            }
	        }

	        iparms = new int[100];
	        A = new double[nmax][maxnval];
	        B = new double[nmax][maxnval];
	        H = new double[nmax][maxnval];
	        T = new double[nmax][maxnval];
	        S1 = new double[nmax][maxnval];
	        S2 = new double[nmax][maxnval];
	        P1 = new double[nmax][maxnval];
	        P2 = new double[nmax][maxnval];
	        U = new double[nmax][maxnval];
	        V = new double[nmax][maxnval];
	        Q = new double[nmax][maxnval];
	        Z = new double[nmax][maxnval];
	        alphr1 = new double[maxnval];
	        alphi1 = new double[maxnval];
	        beta1 = new double[maxnval];
	        alphr3 = new double[maxnval];
	        alphi3 = new double[maxnval];
	        beta3 = new double[maxnval];
	        evectl = new double[nmax][maxnval];
	        evectr = new double[nmax][maxnval];

	        for (i = 1; i <= nparms; i++) {

	            // 1 = The optimal blocksize; if this value is 1, an unblocked
	            // algorithm will give the best performance
	            iparms[1 - 1] = nbval[i - 1];

	            // 2 = The minimum blocksize for which the block routine should be
	            // used; if the usable block size is less than this value, an
	            // unblocked routine should be used.
	            iparms[2 - 1] = nbmin[i - 1];

	            // 3 = The number of shifts, used in nonsymmetric eigenvalue routines.
	            iparms[4 - 1] = nsval[i - 1];

	            // 5 = The minimum column dimension for blocking to be used;
	            // rectangular blocks must have dimension at least k by m,
	            // where k is given by ilaenv(2,...) and m by ilaenv(5,...)
	            iparms[5 - 1] = nbcol[i - 1];

	            // 8 = Another crossover point, for the multishift QR and QZ methods
	            // for nonsymmetric eigenvalue problems
	            iparms[8 - 1] = mxbval[i - 1];

	            if (newsd == 0) {

	                for (k = 0; k < 4; k++) {
	                    iseed[k] = ioldsd[k];
	                }
	            } // if (newsd == 0)

	            System.out.println("Optimal blocksize = " + nbval[i - 1] + "\n");
	            System.out.println("Minimum blocksize = " + nbmin[i - 1] + "\n");
	            System.out.println("Number of shifrs = " + nsval[i - 1] + "\n");
	            System.out.println("Minimum column dimnsion for blocks = " + nbcol[i - 1] + "\n");
	            System.out.println("Minimum submatrix size = " + mxbval[i - 1] + "\n");

	            if (tstchk) {
	                dchkgg(nn, nval, maxtyp, dotype, iseed, thresh, tstdif, thrshn, A, nmax, B, H, T, S1, S2, P1, P2, U,
	                        nmax, V, Q, Z, alphr1, alphi1, beta1, alphr3, alphi3, beta3, evectl, evectr, work, lwork,
	                        logwrk, result, info);

	                if (info[0] != 0) {
//	                    System.err.println("dchkgg had info = " + info[0]);
	                    System.err.println("dchkgg had info = " + info[0]);
	                }
	            } // if (tstchk)
	        } // for (i = 1; i <= nparms; i++)
	    } // dchkgg_test

	    /**
	     * This is a port of version 3.1 LAPACK test routine DCHKGK Original DCHKGK created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 Sample data values obtained from the file dgbak.in dchkgk tests
	     * dggbak, a routine for backward balancing of a matrix pair (A, B).
	     */
	    private void dchkgk() {
	        final int lda = 50;
	        final int ldb = 50;
	        final int ldvl = 50;
	        final int ldvr = 50;
	        final int lde = 50;
	        final int ldf = 50;
	        final int ldwork = 50;
	        int i;
	        final int[] ihi = new int[1];
	        final int[] ilo = new int[1];
	        final int[] info = new int[1];
	        int j;
	        int m;
	        int n;
	        double anorm;
	        double bnorm;
	        double eps;
	        double vmax;
	        final double[][] A = new double[lda][lda];
	        double[][] Asrc;
	        final double[][] AF = new double[lda][lda];
	        final double[][] B = new double[ldb][ldb];
	        double[][] Bsrc;
	        final double[][] BF = new double[ldb][ldb];
	        final double[][] E = new double[lde][lde];
	        final double[][] F = new double[ldf][ldf];
	        final double[] lscale = new double[lda];
	        final double[] rscale = new double[lda];
	        final double[][] VL = new double[ldvl][ldvl];
	        double[][] VLsrc;
	        final double[][] VLF = new double[ldvl][ldvl];
	        final double[][] VR = new double[ldvr][ldvr];
	        double[][] VRsrc;
	        final double[][] VRF = new double[ldvr][ldvr];
	        final double[][] work = new double[ldwork][ldwork];
	        int itest;
	        double[] work1d;
	        int ierr = 0;
	        int jerr = 0;

	        eps = dlamch('P');
	        System.out.println("Test output of DGGBAK\n");

	        for (itest = 1; itest <= 8; itest++) {

	            if (itest == 1) {
	                n = 6;
	                m = 3;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01}};

	                Bsrc = new double[][] { {0.6000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.5000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01}, {0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01, 0.6000E+01}};

	                VRsrc = new double[][] { { -0.1000E+01, -0.1000E+01, -0.1000E+01},
	                        { -0.2000E+01, -0.2000E+01, -0.2000E+01}, { -0.3000E+01, -0.3000E+01, -0.3000E+01},
	                        { -0.4000E+01, -0.4000E+01, -0.4000E+01}, { -0.5000E+01, -0.5000E+01, -0.5000E+01},
	                        { -0.6000E+01, -0.6000E+01, -0.6000E+01}};

	            } else if (itest == 2) {
	                n = 6;
	                m = 3;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.2000E+01, 0.2100E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.3000E+01, 0.3100E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.4000E+01, 0.4100E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.5100E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01, 0.6100E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01}, {0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01, 0.6000E+01}};

	                VRsrc = new double[][] { { -0.1000E+01, -0.1000E+01, -0.1000E+01},
	                        { -0.2000E+01, -0.2000E+01, -0.2000E+01}, { -0.3000E+01, -0.3000E+01, -0.3000E+01},
	                        { -0.4000E+01, -0.4000E+01, -0.4000E+01}, { -0.5000E+01, -0.5000E+01, -0.5000E+01},
	                        { -0.6000E+01, -0.6000E+01, -0.6000E+01}};

	            } else if (itest == 3) {
	                n = 5;
	                m = 5;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01},
	                        {0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01}};

	                VRsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01, 0.3000E+01},
	                        {0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01, 0.5000E+01}};

	            } else if (itest == 4) {
	                n = 6;
	                m = 5;
	                Asrc = new double[][] { {0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                VLsrc = new double[][] { {0.1000E+01, 0.2000E+01, -0.3000E+01, 0.4000E+01, 0.5000E+01},
	                        {0.8000E+01, 0.9000E+01, 0.0000E+00, 0.9000E+01, 0.2000E+01},
	                        {0.0000E+00, -0.9000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.8000E+01, 0.2000E+01, 0.1000E+01, 0.0000E+00, 0.2000E+01},
	                        {0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.2000E+01, 0.1000E+01, 0.9000E+01, 0.0000E+00, 0.1000E+01}};

	                VRsrc = new double[][] { {0.1000E+01, -0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01},
	                        { -0.8000E+01, 0.9000E+01, 0.0000E+00, 0.9000E+01, 0.2000E+01},
	                        {0.0000E+00, 0.9000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.8000E+01, 0.2000E+01, 0.1000E+01, 0.0000E+00, 0.2000E+01},
	                        {0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.2000E+01, 0.8000E+01, 0.9000E+01, 0.0000E+00, 0.1000E+01}};

	            } else if (itest == 5) {
	                n = 6;
	                m = 2;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01}, {0.3000E+01, 0.3000E+01},
	                        {0.4000E+01, 0.4000E+01}, {0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01}};

	                VRsrc = new double[][] { {0.1100E+01, 0.1100E+01}, {0.2200E+01, 0.2200E+01}, {0.3300E+01, 0.3300E+01},
	                        {0.4400E+01, 0.4400E+01}, {0.5500E+01, 0.5500E+01}, {0.6600E+01, 0.6600E+01}};

	            } else if (itest == 6) {
	                n = 7;
	                m = 3;
	                Asrc = new double[][] {
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                Bsrc = new double[][] {
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01}, {0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01, 0.6000E+01},
	                        {0.7000E+01, 0.7000E+01, 0.7000E+01}};

	                VRsrc = new double[][] { { -0.1000E+01, -0.1000E+01, -0.1000E+01},
	                        { -0.2000E+01, -0.2000E+01, -0.2000E+01}, { -0.3000E+01, -0.3000E+01, -0.3000E+01},
	                        { -0.4000E+01, -0.4000E+01, -0.4000E+01}, { -0.5000E+01, -0.5000E+01, -0.5000E+01},
	                        { -0.6000E+01, -0.6000E+01, -0.6000E+01}, { -0.7000E+01, -0.7000E+01, -0.7000E+01}};

	            } else if (itest == 7) {
	                n = 7;
	                m = 3;
	                Asrc = new double[][] {
	                        {0.0000E+00, 0.1000E+04, 0.0000E+00, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E-04},
	                        {0.0000E+00, 0.1000E-04, 0.1000E+04, 0.1000E-04, 0.1000E-04, 0.1000E+04, 0.1000E+04},
	                        {0.1000E+04, 0.1000E+04, 0.1000E-04, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+04},
	                        {0.0000E+00, 0.1000E-04, 0.0000E+00, 0.1000E+00, 0.1000E+04, 0.1000E-04, 0.1000E+04},
	                        {0.0000E+00, 0.1000E+04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.4000E-04, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-04},
	                        {0.0000E+00, 0.1000E+04, 0.0000E+00, 0.1000E+04, 0.1000E+04, 0.1000E-04, 0.1000E+04}};

	                Bsrc = new double[][] {
	                        {0.0000E+00, 0.1000E-01, 0.0000E+00, 0.1000E+04, 0.1000E-04, 0.1000E+04, 0.1000E+04},
	                        {0.0000E+00, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+00, 0.1000E+04},
	                        {0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E+04, 0.1000E-04, 0.1000E+04, 0.1000E+04},
	                        {0.0000E+00, 0.4000E-01, 0.0000E+00, 0.1000E+04, 0.1000E+01, 0.1000E+04, 0.1000E+04},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01},
	                        {0.0000E+00, 0.1000E-04, 0.0000E+00, 0.1000E+04, 0.1000E+01, 0.1000E+01, 0.1000E-04}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01}, {0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01, 0.6000E+01},
	                        {0.7000E+01, 0.7000E+01, 0.7000E+01}};

	                VRsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01, 0.2000E+01},
	                        {0.3000E+01, 0.3000E+01, 0.3000E+01}, {0.4000E+01, 0.4000E+01, 0.4000E+01},
	                        {0.5000E+01, 0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01, 0.6000E+01},
	                        {0.7000E+01, 0.7000E+01, 0.7000E+01}};

	            } else {
	                n = 6;
	                m = 2;
	                Asrc = new double[][] {
	                        { -0.2000E+02, -0.1000E+05, -0.2000E+01, -0.1000E+07, -0.1000E+02, -0.2000E+06},
	                        {0.6000E-02, 0.4000E+01, 0.6000E-03, 0.2000E+03, 0.3000E-02, 0.3000E+02},
	                        { -0.2000E+00, -0.3000E+03, -0.4000E-01, -0.1000E+05, 0.0000E+00, 0.3000E+04},
	                        {0.6000E-04, 0.4000E-01, 0.9000E-05, 0.9000E+01, 0.3000E-04, 0.5000E+00},
	                        {0.6000E-01, 0.5000E+02, 0.8000E-02, -0.4000E+04, 0.8000E-01, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+04, 0.7000E+00, -0.2000E+06, 0.1300E+02, -0.6000E+05}};

	                Bsrc = new double[][] { { -0.2000E+02, -0.1000E+05, 0.2000E+01, -0.2000E+07, 0.1000E+02, -0.1000E+06},
	                        {0.5000E-02, 0.3000E+01, -0.2000E-03, 0.4000E+03, -0.1000E-02, 0.3000E+02},
	                        {0.0000E+00, -0.1000E+03, -0.8000E-01, 0.2000E+05, -0.4000E+00, 0.0000E+00},
	                        {0.5000E-04, 0.3000E-01, 0.2000E-05, 0.4000E+01, 0.2000E-04, 0.1000E+00},
	                        {0.4000E-01, 0.3000E+02, -0.1000E-02, 0.3000E+04, -0.1000E-01, 0.6000E+03},
	                        { -0.1000E+01, 0.0000E+00, 0.4000E+00, -0.1000E+06, 0.4000E+01, 0.2000E+05}};

	                VLsrc = new double[][] { {0.1000E+01, 0.1000E+01}, {0.2000E+01, 0.2000E+01}, {0.3000E+01, 0.3000E+01},
	                        {0.4000E+01, 0.4000E+01}, {0.5000E+01, 0.5000E+01}, {0.6000E+01, 0.6000E+01}};

	                VRsrc = new double[][] { {0.1000E+02, 0.1000E+02}, {0.2000E+02, 0.2000E+02}, {0.3000E+02, 0.3000E+02},
	                        {0.4000E+02, 0.4000E+02}, {0.5000E+02, 0.5000E+02}, {0.6000E+02, 0.6000E+02}};

	            } // else itest == 8

	            for (i = 0; i < lda; i++) {

	                for (j = 0; j < lda; j++) {
	                    A[i][j] = 0.0;
	                }
	            }

	            for (i = 0; i < ldb; i++) {

	                for (j = 0; j < ldb; j++) {
	                    B[i][j] = 0.0;
	                }
	            }

	            for (i = 0; i < ldvl; i++) {

	                for (j = 0; j < ldvl; j++) {
	                    VL[i][j] = 0.0;
	                }
	            }

	            for (i = 0; i < ldvr; i++) {

	                for (j = 0; j < ldvr; j++) {
	                    VR[i][j] = 0.0;
	                }
	            }

	            for (i = 0; i < n; i++) {

	                for (j = 0; j < n; j++) {
	                    A[i][j] = Asrc[i][j];
	                    B[i][j] = Bsrc[i][j];
	                }

	                for (j = 0; j < m; j++) {
	                    VL[i][j] = VLsrc[i][j];
	                    VR[i][j] = VRsrc[i][j];
	                }
	            }

	            work1d = new double[6 * n];
	            anorm = dlange('M', n, n, A, lda, work1d);
	            bnorm = dlange('M', n, n, B, ldb, work1d);

	            dlacpy('F', n, n, A, lda, AF, lda);
	            dlacpy('F', n, n, B, ldb, BF, ldb);

	            System.out.println("Test number = " + itest + "\n");
	            dggbal('B', n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work1d, info);

	            if (info[0] != 0) {
	                System.out.println("dggbal had info[0] = " + info[0] + "\n");
	            }

	            dlacpy('F', n, m, VL, ldvl, VLF, ldvl);
	            dlacpy('F', n, m, VR, ldvr, VRF, ldvr);

	            dggbak('B', 'L', n, ilo[0], ihi[0], lscale, rscale, m, VL, ldvl, info);

	            if (info[0] != 0) {
	                System.out.println("dggbak with side = L had info[0] = " + info[0] + "\n");
	            }

	            dggbak('B', 'R', n, ilo[0], ihi[0], lscale, rscale, m, VR, ldvr, info);

	            if (info[0] != 0) {
	                System.out.println("dggbak with side = R had info[0] = " + info[0] + "\n");
	            }

	            // Test of dggbak
	            // Check tilde(V)'*A*tilde(VR) - VL'*tilde(A)*VR
	            // where tilde(A) denotes the transformed matrix
	            dgemm('N', 'N', n, m, n, 1.0, AF, lda, VR, ldvr, 0.0, work, ldwork);
	            dgemm('T', 'N', m, m, n, 1.0, VL, ldvl, work, ldwork, 0.0, E, lde);

	            dgemm('N', 'N', n, m, n, 1.0, A, lda, VRF, ldvr, 0.0, work, ldwork);
	            dgemm('T', 'N', m, m, n, 1.0, VLF, ldvl, work, ldwork, 0.0, F, ldf);

	            vmax = 0.0;

	            for (j = 0; j < m; j++) {

	                for (i = 0; i < m; i++) {

	                    if (Math.abs(E[i][j] - F[i][j]) > vmax) {
	                        vmax = Math.abs(E[i][j] - F[i][j]);
	                        ierr = i;
	                        jerr = j;
	                    }
	                }
	            }

	            vmax = vmax / (eps * Math.max(anorm, bnorm));
	            System.out.println("For A check vmax = " + vmax + "\n");

	            if (vmax > 0.0) {
	                System.out.println("E[" + ierr + "][" + jerr + "] = " + E[ierr][jerr] + "\n");
	                System.out.println("F[" + ierr + "][" + jerr + "] = " + F[ierr][jerr] + "\n");
	            }

	            // Check tilde(V)'*B*tilde(VR) - VL'*tilde(B)*VR
	            dgemm('N', 'N', n, m, n, 1.0, BF, ldb, VR, ldvr, 0.0, work, ldwork);
	            dgemm('T', 'N', m, m, n, 1.0, VL, ldvl, work, ldwork, 0.0, E, lde);

	            dgemm('N', 'N', n, m, n, 1.0, B, ldb, VRF, ldvr, 0.0, work, ldwork);
	            dgemm('T', 'N', m, m, n, 1.0, VLF, ldvl, work, ldwork, 0.0, F, ldf);

	            vmax = 0.0;

	            for (j = 0; j < m; j++) {

	                for (i = 0; i < m; i++) {

	                    if (Math.abs(E[i][j] - F[i][j]) > vmax) {
	                        vmax = Math.abs(E[i][j] - F[i][j]);
	                        ierr = i;
	                        jerr = j;
	                    }
	                }
	            }

	            vmax = vmax / (eps * Math.max(anorm, bnorm));
	            System.out.println("For B check vmax = " + vmax + "\n");

	            if (vmax > 0.0) {
	                System.out.println("E[" + ierr + "][" + jerr + "] = " + E[ierr][jerr] + "\n");
	                System.out.println("F[" + ierr + "][" + jerr + "] = " + F[ierr][jerr] + "\n");
	            }

	        } // for (itest = 1; itest <= 8; itest++)

	        return;
	    } // dchkgk

	    /**
	     * This is a port of version 3.1 LAPACK test routine DCHKGL Original DCHKGL created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 Sample data values obtained from the file dgbal.in
	     * 
	     * <p>
	     * dchkgl tests dggbal, a routine for balancing a matrix pair (A, B)
	     * </p>
	     */
	    private void dchkgl() {
	        final int lda = 20;
	        final int ldb = 20;
	        final int lwork = 6 * lda;
	        double eps;
	        double anorm;
	        double bnorm;
	        final double[] work = new double[lwork];
	        final int[] info = new int[1];
	        double vmax;
	        int i;
	        int j;
	        int itest;
	        int n;
	        final double[][] A = new double[lda][lda];
	        double[][] Asrc;
	        final double[][] B = new double[ldb][ldb];
	        double[][] Bsrc;
	        int iloin;
	        int ihiin;
	        final int[] ilo = new int[1];
	        final int[] ihi = new int[1];
	        final double[][] ain = new double[lda][lda];
	        double[][] ainsrc;
	        final double[][] bin = new double[ldb][ldb];
	        double[][] binsrc;
	        final double[] lsclin = new double[lda];
	        double[] lsclinsrc;
	        final double[] rsclin = new double[lda];
	        double[] rsclinsrc;
	        final double[] lscale = new double[lda];
	        final double[] rscale = new double[lda];
	        int itype;
	        int ierr = 0;
	        int jerr = 0;

	        eps = dlamch('P');
	        System.out.println("Test output of DGGBAL\n");

	        for (itest = 1; itest <= 8; itest++) {

	            if (itest == 1) {
	                n = 6;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01}};
	                Bsrc = new double[][] { {0.6000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.5000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};
	                iloin = 1;
	                ihiin = 1;
	                ainsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.5000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.6000E+01}};
	                binsrc = new double[][] { {0.6000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.5000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.4000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};
	                lsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01};
	                rsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01};
	            } // if (itest = 1);
	            else if (itest == 2) {
	                n = 6;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                iloin = 1;
	                ihiin = 1;
	                ainsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                binsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                lsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01};

	                rsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01};

	            } else if (itest == 3) {
	                n = 6;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01, 0.6000E+01}};

	                iloin = 1;
	                ihiin = 1;
	                ainsrc = new double[][] { {0.6000E+01, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                binsrc = new double[][] { {0.6000E+01, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                lsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01};

	                rsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01};

	            } else if (itest == 4) {
	                n = 5;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.0000E+00},
	                        {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.4000E+01, 0.5000E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                iloin = 1;
	                ihiin = 1;
	                ainsrc = new double[][] { {0.5000E+01, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.4000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.3000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.2000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                binsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                lsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01};

	                rsclinsrc = new double[] {0.1000E+01, 0.2000E+01, 0.3000E+01, 0.2000E+01, 0.1000E+01};

	            } else if (itest == 5) {
	                n = 6;
	                Asrc = new double[][] { {0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                Bsrc = new double[][] { {0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+11},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                iloin = 1;
	                ihiin = 6;
	                ainsrc = new double[][] { {0.1000E-03, 0.1000E+05, 0.1000E+04, 0.1000E+02, 0.1000E+00, 0.1000E-01},
	                        {0.1000E-02, 0.1000E-04, 0.1000E+05, 0.1000E+03, 0.1000E+01, 0.1000E+00},
	                        {0.1000E+00, 0.1000E-02, 0.1000E-03, 0.1000E+05, 0.1000E+03, 0.1000E+02},
	                        {0.1000E+02, 0.1000E+00, 0.1000E-01, 0.1000E-03, 0.1000E+05, 0.1000E+04},
	                        {0.1000E+03, 0.1000E+01, 0.1000E+00, 0.1000E-02, 0.1000E-04, 0.1000E+05},
	                        {0.1000E+05, 0.1000E+03, 0.1000E+02, 0.1000E+00, 0.1000E-02, 0.1000E-03}};

	                binsrc = new double[][] { {0.1000E-03, 0.1000E+05, 0.1000E+04, 0.1000E+02, 0.1000E+00, 0.1000E-01},
	                        {0.1000E-02, 0.1000E-04, 0.1000E+05, 0.1000E+03, 0.1000E+01, 0.1000E+00},
	                        {0.1000E+00, 0.1000E-02, 0.1000E-03, 0.1000E+05, 0.1000E+03, 0.1000E+02},
	                        {0.1000E+02, 0.1000E+00, 0.1000E-01, 0.1000E-03, 0.1000E+05, 0.1000E+04},
	                        {0.1000E+03, 0.1000E+01, 0.1000E+00, 0.1000E-02, 0.1000E-04, 0.1000E+05},
	                        {0.1000E+05, 0.1000E+03, 0.1000E+02, 0.1000E+00, 0.1000E-02, 0.1000E-03}};

	                lsclinsrc = new double[] {0.1000E-05, 0.1000E-04, 0.1000E-02, 0.1000E+00, 0.1000E+01, 0.1000E+03};

	                rsclinsrc = new double[] {0.1000E+03, 0.1000E+01, 0.1000E+00, 0.1000E-02, 0.1000E-04, 0.1000E-05};

	            } else if (itest == 6) {
	                n = 6;
	                Asrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07}};

	                Bsrc = new double[][] { {0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E+07},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-05, 0.1000E-05},
	                        {0.1000E+07, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+07, 0.1000E+07}};

	                iloin = 4;
	                ihiin = 6;
	                ainsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-03, 0.1000E+05},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+05, 0.1000E+01, 0.1000E-03},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-03, 0.1000E+05, 0.1000E+01}};

	                binsrc = new double[][] { {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E-03, 0.1000E+05},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+05, 0.1000E+01, 0.1000E-03},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E-03, 0.1000E+05, 0.1000E+01}};

	                lsclinsrc = new double[] {0.4000E+01, 0.4000E+01, 0.4000E+01, 0.1000E+00, 0.1000E+04, 0.1000E-04};

	                rsclinsrc = new double[] {0.2000E+01, 0.3000E+01, 0.4000E+01, 0.1000E-04, 0.1000E+04, 0.1000E+00};

	            } else if (itest == 7) {
	                n = 7;
	                Asrc = new double[][] {
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                Bsrc = new double[][] {
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01}};

	                iloin = 3;
	                ihiin = 5;
	                ainsrc = new double[][] {
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                binsrc = new double[][] {
	                        {0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01, 0.1000E+01},
	                        {0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.0000E+00, 0.1000E+01}};

	                lsclinsrc = new double[] {0.3000E+01, 0.2000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.6000E+01,
	                        0.5000E+01};

	                rsclinsrc = new double[] {0.1000E+01, 0.3000E+01, 0.1000E+01, 0.1000E+01, 0.1000E+01, 0.2000E+01,
	                        0.2000E+01};

	            } else {
	                n = 6;
	                Asrc = new double[][] {
	                        { -0.2000E+02, -0.1000E+05, -0.2000E+01, -0.1000E+07, -0.1000E+02, -0.2000E+06},
	                        {0.6000E-02, 0.4000E+01, 0.6000E-03, 0.2000E+03, 0.3000E-02, 0.3000E+02},
	                        { -0.2000E+00, -0.3000E+03, -0.4000E-01, -0.1000E+05, 0.0000E+00, 0.3000E+04},
	                        {0.6000E-04, 0.4000E-01, 0.9000E-05, 0.9000E+01, 0.3000E-04, 0.5000E+00},
	                        {0.6000E-01, 0.5000E+02, 0.8000E-02, -0.4000E+04, 0.8000E-01, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+04, 0.7000E+00, -0.2000E+06, 0.1300E+02, -0.6000E+05}};

	                Bsrc = new double[][] { { -0.2000E+02, -0.1000E+05, 0.2000E+01, -0.2000E+07, 0.1000E+02, -0.1000E+06},
	                        {0.5000E-02, 0.3000E+01, -0.2000E-03, 0.4000E+03, -0.1000E-02, 0.3000E+02},
	                        {0.0000E+00, -0.1000E+03, -0.8000E-01, 0.2000E+05, -0.4000E+00, 0.0000E+00},
	                        {0.5000E-04, 0.3000E-01, 0.2000E-05, 0.4000E+01, 0.2000E-04, 0.1000E+00},
	                        {0.4000E-01, 0.3000E+02, -0.1000E-02, 0.3000E+04, -0.1000E-01, 0.6000E+03},
	                        { -0.1000E+01, 0.0000E+00, 0.4000E+00, -0.1000E+06, 0.4000E+01, 0.2000E+05}};

	                iloin = 1;
	                ihiin = 6;
	                ainsrc = new double[][] {
	                        { -0.2000E+00, -0.1000E+01, -0.2000E+00, -0.1000E+01, -0.1000E+01, -0.2000E+01},
	                        {0.6000E+00, 0.4000E+01, 0.6000E+00, 0.2000E+01, 0.3000E+01, 0.3000E+01},
	                        { -0.2000E+00, -0.3000E+01, -0.4000E+00, -0.1000E+01, 0.0000E+00, 0.3000E+01},
	                        {0.6000E+00, 0.4000E+01, 0.9000E+00, 0.9000E+01, 0.3000E+01, 0.5000E+01},
	                        {0.6000E+00, 0.5000E+01, 0.8000E+00, -0.4000E+01, 0.8000E+01, 0.0000E+00},
	                        {0.0000E+00, 0.1000E+01, 0.7000E+00, -0.2000E+01, 0.1300E+02, -0.6000E+01}};

	                binsrc = new double[][] {
	                        { -0.2000E+00, -0.1000E+01, 0.2000E+00, -0.2000E+01, 0.1000E+01, -0.1000E+01},
	                        {0.5000E+00, 0.3000E+01, -0.2000E+00, 0.4000E+01, -0.1000E+01, 0.3000E+01},
	                        {0.0000E+00, -0.1000E+01, -0.8000E+00, 0.2000E+01, -0.4000E+01, 0.0000E+00},
	                        {0.5000E+00, 0.3000E+01, 0.2000E+00, 0.4000E+01, 0.2000E+01, 0.1000E+01},
	                        {0.4000E+00, 0.3000E+01, -0.1000E+00, 0.3000E+01, -0.1000E+01, 0.6000E+01},
	                        { -0.1000E+00, 0.0000E+00, 0.4000E+00, -0.1000E+01, 0.4000E+01, 0.2000E+01}};

	                lsclinsrc = new double[] {0.1000E-02, 0.1000E+02, 0.1000E+00, 0.1000E+04, 0.1000E+01, 0.1000E-01};

	                rsclinsrc = new double[] {0.1000E+02, 0.1000E+00, 0.1000E+03, 0.1000E-02, 0.1000E+03, 0.1000E-01};

	            } // else itest == 8

	            for (i = 0; i < lda; i++) {
	                lscale[i] = 0.0;
	                lsclin[i] = 0.0;
	                rscale[i] = 0.0;
	                rsclin[i] = 0.0;

	                for (j = 0; j < lda; j++) {
	                    A[i][j] = 0.0;
	                    ain[i][j] = 0.0;
	                }
	            }

	            for (i = 0; i < ldb; i++) {

	                for (j = 0; j < ldb; j++) {
	                    B[i][j] = 0.0;
	                    bin[i][j] = 0.0;
	                }
	            }

	            for (i = 0; i < n; i++) {
	                lsclin[i] = lsclinsrc[i];
	                rsclin[i] = rsclinsrc[i];

	                for (j = 0; j < n; j++) {
	                    A[i][j] = Asrc[i][j];
	                    ain[i][j] = ainsrc[i][j];
	                    B[i][j] = Bsrc[i][j];
	                    bin[i][j] = binsrc[i][j];
	                }
	            }

	            anorm = dlange('M', n, n, A, lda, work);
	            bnorm = dlange('M', n, n, B, ldb, work);

	            dggbal('B', n, A, lda, B, ldb, ilo, ihi, lscale, rscale, work, info);
	            System.out.println("Test number = " + itest + "\n");

	            if (info[0] != 0) {
	                System.out.println("info[0] = " + info[0] + "\n");
	            }

	            if ( (ilo[0] != iloin) || (ihi[0] != ihiin)) {
	                System.out.println("ilo or ihi wrong\n");
	            }

	            vmax = 0.0;
	            itype = 0;

	            for (i = 0; i < n; i++) {

	                for (j = 0; j < n; j++) {

	                    if (Math.abs(A[i][j] - ain[i][j]) > vmax) {
	                        vmax = Math.abs(A[i][j] - ain[i][j]);
	                        itype = 1;
	                        ierr = i;
	                        jerr = j;
	                    }

	                    if (Math.abs(B[i][j] - bin[i][j]) > vmax) {
	                        itype = 2;
	                        ierr = i;
	                        jerr = j;
	                    }
	                }
	            }

	            for (i = 0; i < n; i++) {

	                if (Math.abs(lscale[i] - lsclin[i]) > vmax) {
	                    vmax = Math.abs(lscale[i] - lsclin[i]);
	                    itype = 3;
	                    ierr = i;
	                }

	                if (Math.abs(rscale[i] - rsclin[i]) > vmax) {
	                    vmax = Math.abs(rscale[i] - rsclin[i]);
	                    itype = 4;
	                    ierr = i;
	                }
	            }

	            vmax = vmax / (eps * Math.max(anorm, bnorm));

	            System.out.println("Error vmax = " + vmax + "\n");

	            if (vmax > 0.0) {

	                if (itype == 1) {
	                    System.out.println("A[" + ierr + "][" + jerr + "] = " + A[ierr][jerr] + "\n");
	                    System.out.println("ain[" + ierr + "][" + jerr + "] = " + ain[ierr][jerr] + "\n");
	                } else if (itype == 2) {
	                    System.out.println("B[" + ierr + "][" + jerr + "] = " + B[ierr][jerr] + "\n");
	                    System.out.println("bin[" + ierr + "][" + jerr + "] = " + bin[ierr][jerr] + "\n");
	                } else if (itype == 3) {
	                    System.out.println("lscale[" + ierr + "] = " + lscale[ierr] + "\n");
	                    System.out.println("lsclin[" + ierr + "] = " + lsclin[ierr] + "\n");
	                } else if (itype == 4) {
	                    System.out.println("rscale[" + ierr + "] = " + rscale[ierr] + "\n");
	                    System.out.println("rsclin[" + ierr + "] = " + rsclin[ierr] + "\n");

	                }
	            } // if (vmax > 0.0)
	        } // for (itest = 1; itest <= 8; itest++)

	        return;
	    } // dchkgl

	    /**
	     * This is a port of version 3.1 LAPACK test routine DCHKQR Univ. of Tennessee, Univ. of California Berkeley and NAG
	     * Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. LOGICAL TSTERR INTEGER NM, NMAX, NN, NNB, NOUT, NRHS DOUBLE PRECISION THRESH .. .. Array
	     * Arguments .. LOGICAL DOTYPE( * ) INTEGER IWORK( * ), MVAL( * ), NBVAL( * ), NVAL( * ), $ NXVAL( * ) DOUBLE
	     * PRECISION A( * ), AC( * ), AF( * ), AQ( * ), AR( * ), $ B( * ), RWORK( * ), TAU( * ), WORK( * ), $ X( * ), XACT(
	     * * ) ..
	     * 
	     * Purpose =======
	     * 
	     * DCHKQR tests DGEQRF, DORGQR and DORMQR.
	     * 
	     * Arguments =========
	     * 
	     * DOTYPE (input) LOGICAL array, dimension (NTYPES) The matrix types to be used for testing. Matrices of type j (for
	     * 1 <= j <= NTYPES) are used for testing if DOTYPE(j) = .TRUE.; if DOTYPE(j) = .FALSE., then type j is not used.
	     * 
	     * NM (input) INTEGER The number of values of M contained in the vector MVAL.
	     * 
	     * MVAL (input) INTEGER array, dimension (NM) The values of the matrix row dimension M.
	     * 
	     * NN (input) INTEGER The number of values of N contained in the vector NVAL.
	     * 
	     * NVAL (input) INTEGER array, dimension (NN) The values of the matrix column dimension N.
	     * 
	     * NNB (input) INTEGER The number of values of NB and NX contained in the vectors NBVAL and NXVAL. The blocking
	     * parameters are used in pairs (NB,NX).
	     * 
	     * NBVAL (input) INTEGER array, dimension (NNB) The values of the blocksize NB.
	     * 
	     * NXVAL (input) INTEGER array, dimension (NNB) The values of the crossover point NX.
	     * 
	     * NRHS (input) INTEGER The number of right hand side vectors to be generated for each linear system.
	     * 
	     * THRESH (input) DOUBLE PRECISION The threshold value for the test ratios. A result is included in the output file
	     * if RESULT >= THRESH. To have every test ratio printed, use THRESH = 0.
	     * 
	     * TSTERR (input) LOGICAL Flag that indicates whether error exits are to be tested.
	     * 
	     * NMAX (input) INTEGER The maximum value permitted for M or N, used in dimensioning the work arrays.
	     * 
	     * A (workspace) DOUBLE PRECISION array, dimension [NMAX][NMAX]
	     * 
	     * AF (workspace) DOUBLE PRECISION array, dimension [NMAX][NMAX]
	     * 
	     * AQ (workspace) DOUBLE PRECISION array, dimension [NMAX][NMAX]
	     * 
	     * AR (workspace) DOUBLE PRECISION array, dimension [NMAX][NMAX]
	     * 
	     * AC (workspace) DOUBLE PRECISION array, dimension [NMAX][NMAX}
	     * 
	     * B (workspace) DOUBLE PRECISION array, dimension [NMAX*][NRHS]
	     * 
	     * X (workspace) DOUBLE PRECISION array, dimension [NMAX][NRHS]
	     * 
	     * XACT (workspace) DOUBLE PRECISION array, dimension [NMAX][NRHS]
	     * 
	     * TAU (workspace) DOUBLE PRECISION array, dimension (NMAX)
	     * 
	     * WORK (workspace) DOUBLE PRECISION array, dimension (NMAX*NMAX)
	     * 
	     * RWORK (workspace) DOUBLE PRECISION array, dimension (NMAX)
	     * 
	     * IWORK (workspace) INTEGER array, dimension (NMAX)
	     */
	    private void dchkqr(final boolean[] dotype, final int nm, final int[] mval, final int nn, final int[] nval,
	            final int nnb, final int[] nbval, final int[] nxval, final int nrhs, final double thresh,
	            final boolean tsterr, final int nmax, final double[][] A, final double[][] AF, final double[][] AQ,
	            final double[][] AR, final double[][] AC, final double[][] B, final double[][] X, final double[][] XACT,
	            final double[] tau, final double[] work, final double[] rwork, final int[] iwork) {
	        final int ntests = 8;
	        final int ntypes = 8;
	        final int iseedy[] = new int[] {1988, 1989, 1990, 1991};
	        int i;
	        int ik;
	        int im;
	        int imat;
	        int in;
	        int inb;
	        final int info[] = new int[1];
	        int k;
	        final int kl[] = new int[1];
	        final int ku[] = new int[1];
	        int lda;
	        int lwork;
	        int m;
	        int minmn;
	        final int mode[] = new int[1];
	        int n;
	        int nb;
	        int nerrs;
	        int nfail;
	        int nk;
	        int nrun;
	        int nt;
	        int nx;
	        final double anorm[] = new double[1];
	        final double cndnum[] = new double[1];
	        final int iseed[] = new int[4];
	        final int kval[] = new int[4];
	        final double result[] = new double[ntests];
	        String path;
	        final char type[] = new char[1];
	        final char dist[] = new char[1];
	        final double res[] = new double[4];
	        int p;
	        int q;
	        double vec1[];
	        final double resid[] = new double[1];

	        // Initialize constants and the random number seed
	        path = new String("DQR"); // D for double precision
	        nrun = 0;
	        nfail = 0;
	        nerrs = 0;
	        for (i = 0; i < 4; i++) {
	            iseed[i] = iseedy[i];
	        }

	        // Test the error exits
	        if (tsterr) {
	            derrqr();
	        }
	 
	        xlaenv(2, 2);

	        lda = nmax;
	        lwork = nmax * Math.max(nmax, nrhs);

	        // Do for each value of m in mval.

	        for (im = 1; im <= nm; im++) {
	            m = mval[im - 1];

	            // Do for each value of n in nval.
	            for (in = 1; in <= nn; in++) {
	                n = nval[in - 1];
	                minmn = Math.min(m, n);
	                for (imat = 1; imat <= ntypes; imat++) {
	                    // Do the tests only if dotype[imat-1] is true
	                    if ( !dotype[imat - 1]) {
	                        continue;
	                    }

	                    // Set up the parameters with dlatb4 and generate a test matrix
	                    // with dlatms.
	                    dlatb4(path, imat, m, n, type, kl, ku, anorm, mode, cndnum, dist);

	                    dlatms(m, n, dist[0], iseed, type[0], rwork, mode[0], cndnum[0], anorm[0], kl[0], ku[0], 'N', A,
	                            lda, work, info);

	                    // Check error code from dlamts.
	                    if (info[0] != 0) {
	                        if ( (nfail == 0) && (nerrs == 0)) {
	                            System.err.print("Path = DQR\n");
	                            System.err.print("QR decomposition of rectangular matrices\n");
	                            System.err.print("QR matrix types:\n");
	                            System.err.print("1. Diagonal\n");
	                            System.err.print("2. Upper triangular\n");
	                            System.err.print("3. Lower triangular\n");
	                            System.err.print("4. Random, cndnum[0] = 2\n");
	                            System.err.print("5. Random, cndnum[0] = sqrt(1.0/eps)\n");
	                            System.err.print("6. Random, cndnum[0] = 0.1/eps\n");
	                            System.err.print("7. Scaled near underflow\n");
	                            System.err.print("8. Scaled near overflow\n");
	                            System.err.print("Test ratios:\n");
	                            System.err.print("1: norm(R - Q' * A)/(M * norm(A) * eps)\n");
	                            System.err.print("2: norm(I - Q'*Q)/(M * eps)\n");
	                            System.err.print("3: norm(Q*C - Q*C)/(M * norm(C) * eps)\n");
	                            System.err.print("4: norm(C*Q - C*Q)/(M * norm(C) * eps)\n");
	                            System.err.print("5: norm(Q' * C - Q' * C)/(M * norm(C) * eps)\n");
	                            System.err.print("6: norm(C*Q' - C*Q')/(M * norm(C) * eps)\n");
	                            System.err.print("7: norm(B - A * X)/(norm(A) * norm(X) * eps)\n");
	                            System.err.print("8: Diagonal is not non-negative\n");
	                        } // if ((nfail == 0) && (nerrs == 0))
	                        nerrs++;
	                        System.err.print("Error code from dlatms is info[0] = " + info + " for m = " + m + " n = " + n
	                                + " type = " + imat + "\n");
	                        continue;
	                    } // if (info[0] != 0)

	                    // Get some values for k: the first value must be minmn,
	                    // corresponding to the call of dqrt01; other values are
	                    // used in the calls of dqrt02, and must not exceed minmn.
	                    kval[0] = minmn;
	                    kval[1] = 0;
	                    kval[2] = 1;
	                    kval[3] = minmn / 2;
	                    if (minmn == 0) {
	                        nk = 1;
	                    } else if (minmn == 1) {
	                        nk = 2;
	                    } else if (minmn <= 3) {
	                        nk = 3;
	                    } else {
	                        nk = 4;
	                    }

	                    for (ik = 1; ik <= nk; ik++) {
	                        k = kval[ik - 1];

	                        // Do for each pair of values (nb, nx) in nbval and nxval.
	                        for (inb = 1; inb <= nnb; inb++) {
	                            nb = nbval[inb - 1];
	                            xlaenv(1, nb);
	                            nx = nxval[inb - 1];
	                            xlaenv(3, nx);
	                            for (i = 0; i < ntests; i++) {
	                                result[i] = 0.0;
	                            }
	                            nt = 2;
	                            if (ik == 1) {
	                                // Test dgeqrf
	                                dqrt01(m, n, A, AF, AQ, AR, lda, tau, work, lwork, rwork, result);
	                                if ( !dgennd(m, n, AF, lda)) {
	                                    result[7] = 2 * thresh;
	                                }
	                                nt = nt + 1;
	                            } // if (ik == 1)
	                            else if (m >= n) {
	                                // Test dorgqr, using factorization returned by dqrt01
	                                dqrt02(m, n, k, A, AF, AQ, AR, lda, tau, work, lwork, rwork, result);
	                            } // else if (m >= n)
	                            if (m >= k) {
	                                // Test DORMQR, using factorization returned by DQRT01
	                                dqrt03(m, n, k, AF, AC, AR, AQ, lda, tau, work, lwork, rwork, res);
	                                for (p = 0; p < 4; p++) {
	                                    result[2 + p] = res[p];
	                                }
	                                nt = nt + 4;

	                                // If m >= n and k == n, call dgers to solve a system
	                                // with nrhs right hand sides and compute the residual.
	                                if ( (k == n) && (inb == 1)) {
	                                    // Generate a solution and set the right hand side.
	                                    // Here to dgemm extracted from dlarhs
	                                    vec1 = new double[n];
	                                    for (p = 1; p <= nrhs; p++) {
	                                        dlarnv(2, iseed, n, vec1);
	                                        for (q = 0; q < n; q++) {
	                                            XACT[q][p - 1] = vec1[q];
	                                        }
	                                    } // for (p = 1; p <= nrhs; p++)
	                                    dgemm('N', 'N', m, nrhs, n, 1.0, A, lda, XACT, lda, 0.0, B, lda);
	                                    dlacpy('F', m, nrhs, B, lda, X, lda);
	                                    dgeqrs(m, n, nrhs, AF, lda, tau, X, lda, work, lwork, info);

	                                    // Check error code from dgeqrs.
	                                    if (info[0] != 0) {
	                                        if ( (nfail == 0) && (nerrs == 0)) {
	                                            System.err.print("Path = DQR\n");
	                                            System.err.print("QR decomposition of rectangular matrices\n");
	                                            System.err.print("QR matrix types:\n");
	                                            System.err.print("1. Diagonal\n");
	                                            System.err.print("2. Upper triangular\n");
	                                            System.err.print("3. Lower triangular\n");
	                                            System.err.print("4. Random, cndnum[0] = 2\n");
	                                            System.err.print("5. Random, cndnum[0] = sqrt(1.0/eps)\n");
	                                            System.err.print("6. Random, cndnum[0] = 0.1/eps\n");
	                                            System.err.print("7. Scaled near underflow\n");
	                                            System.err.print("8. Scaled near overflow\n");
	                                            System.err.print("Test ratios:\n");
	                                            System.err.print("1: norm(R - Q' * A)/(M * norm(A) * eps)\n");
	                                            System.err.print("2: norm(I - Q'*Q)/(M * eps)\n");
	                                            System.err.print("3: norm(Q*C - Q*C)/(M * norm(C) * eps)\n");
	                                            System.err.print("4: norm(C*Q - C*Q)/(M * norm(C) * eps)\n");
	                                            System.err.print("5: norm(Q' * C - Q' * C)/(M * norm(C) * eps)\n");
	                                            System.err.print("6: norm(C*Q' - C*Q')/(M * norm(C) * eps)\n");
	                                            System.err.print("7: norm(B - A * X)/(norm(A) * norm(X) * eps)\n");
	                                            System.err.print("8: Diagonal is not non-negative\n");
	                                        } // if ((nfail == 0) && (nerrs == 0))
	                                        nerrs++;
	                                        System.err.print("Error code from dgeqrs info[0] = " + info[0] + "\n");
	                                        System.err.print("m = " + m + " n = " + n + " nrhs = " + nrhs + "\n");
	                                        System.err.print("nb = " + nb + " type = " + imat + "\n");
	                                    } // if (info[0] != 0)

	                                    dget02('N', m, n, nrhs, A, lda, X, lda, B, lda, rwork, resid);
	                                    result[6] = resid[0];
	                                    nt++;
	                                } // if ((k == n) && (inb == 1))
	                            } // if (m >= k)

	                            // Output information about the tests that did not pass the threshold.
	                            for (i = 1; i <= nt; i++) {
	                                if (result[i - 1] >= thresh) {
	                                    if ( (nfail == 0) && (nerrs == 0)) {
	                                        System.err.print("Path = DQR\n");
	                                        System.err.print("QR decomposition of rectangular matrices\n");
	                                        System.err.print("QR matrix types:\n");
	                                        System.err.print("1. Diagonal\n");
	                                        System.err.print("2. Upper triangular\n");
	                                        System.err.print("3. Lower triangular\n");
	                                        System.err.print("4. Random, cndnum[0] = 2\n");
	                                        System.err.print("5. Random, cndnum[0] = sqrt(1.0/eps)\n");
	                                        System.err.print("6. Random, cndnum[0] = 0.1/eps\n");
	                                        System.err.print("7. Scaled near underflow\n");
	                                        System.err.print("8. Scaled near overflow\n");
	                                        System.err.print("Test ratios:\n");
	                                        System.err.print("1: norm(R - Q' * A)/(M * norm(A) * eps)\n");
	                                        System.err.print("2: norm(I - Q'*Q)/(M * eps)\n");
	                                        System.err.print("3: norm(Q*C - Q*C)/(M * norm(C) * eps)\n");
	                                        System.err.print("4: norm(C*Q - C*Q)/(M * norm(C) * eps)\n");
	                                        System.err.print("5: norm(Q' * C - Q' * C)/(M * norm(C) * eps)\n");
	                                        System.err.print("6: norm(C*Q' - C*Q')/(M * norm(C) * eps)\n");
	                                        System.err.print("7: norm(B - A * X)/(norm(A) * norm(X) * eps)\n");
	                                        System.err.print("8: Diagonal is not non-negative\n");
	                                    } // if ((nfail == 0) && (nerrs == 0))
	                                    System.err.print("m = " + m + " n = " + n + " k = " + k + "\n");
	                                    System.err.print("nb = " + nb + " nx = " + nx + " type = " + imat + "\n");
	                                    System.err.print("Test = " + i + " with result = " + result[i - 1] + "\n");
	                                    nfail++;
	                                } // if (result[i-1] >= thresh)
	                            } // for (i = 1; i <= nt; i++)
	                            nrun = nrun + nt;
	                        } // for (inb = 1; inb <= nnb; inb++)
	                    } // for (ik = 1; ik <= nk; ik++)
	                } // for (imat = 1; imat <= ntypes; imat++)
	            } // for (in = 1; in <= nn; in++)
	        } // for (im = 1; im <= nm; im++)

	        // Output a summary of the results.
	        if (nfail > 0) {
	            System.err.print("In dchkqr " + nfail + " out of " + nrun + " tests failed to pass the threshold\n");
	        } else {
	            System.err.print("In dchkqr all " + nrun + " tests run passed the threshold\n");
	        }
	        if (nerrs > 0) {
	            System.err.print("In dchkqr " + nerrs + " errors occurred\n");
	        }
	        return;
	    } // dchkqr

	    /**
	     * This dchkqr_test routine is a port of a portion of the version 3.1.1 LAPACK test routine DCHKAA by Univ. of
	     * Tennessee, Univ. Of California Berkeley and NAG Ltd., January, 2007. and some values from the test data file
	     * dtest.in.
	     */
	    private void dchkqr_test() {

	        // Number of values of m
	        final int nm = 7;

	        // Values of m (row dimension)
	        // dtest.in uses 50 rather than 16
	        final int[] mval = new int[] {0, 1, 2, 3, 5, 10, 16};

	        // Number of values of n
	        final int nn = 7;

	        // Values of n (column dimension)
	        // dtest.in uses 50 rather than 16
	        final int[] nval = new int[] {0, 1, 2, 3, 5, 10, 16};

	        // Values of nrhs (number of right hand sides)
	        // dchkaa uses only 2. dtest.in uses 1, 2, 15.
	        // Since dchkr only accepts nrhs = nsval[0] use only 2.
	        final int[] nsval = new int[] {2};

	        // Number of values of nb
	        final int nnb = 5;

	        // Values of nb (the blocksize)
	        final int nbval[] = new int[] {1, 3, 3, 3, 20};

	        // Values of nx (crossover point)
	        // There are nnb values of nx.
	        final int nxval[] = new int[] {1, 0, 5, 9, 1};

	        // Threshold value of test ratio
	        // dchkaa has 20.0, dtest.in has 30.0
	        final double thresh = 20.0;

	        // Test the error exits
	        // Passed all 49 exits on test.
	        // Put at false so as not to have to hit okay to 49 displayError messages.
	        final boolean tsterr = false;

	        // The maximum allowable value for n
	        final int nmax = 132;

	        final int ntypes = 8;
	        final int nrhs = nsval[0];
	        final boolean dotype[] = new boolean[ntypes];
	        final double A[][] = new double[nmax][nmax];
	        final double AF[][] = new double[nmax][nmax];
	        final double AQ[][] = new double[nmax][nmax];
	        final double AR[][] = new double[nmax][nmax];
	        final double AC[][] = new double[nmax][nmax];
	        final double B[][] = new double[nmax][nrhs];
	        final double X[][] = new double[nmax][nrhs];
	        final double XACT[][] = new double[nmax][nrhs];
	        final double tau[] = new double[nmax];
	        final double work[] = new double[nmax * nmax];
	        final double rwork[] = new double[nmax];
	        final int iwork[] = new int[nmax];
	        iparms = new int[11];
	        int i;
	        double eps;

	        for (i = 0; i < ntypes; i++) {
	            dotype[i] = true;
	        }

	        // Output the machine dependent constants
	        eps = dlamch('U');
	        System.err.print("Underflow threshold = " + eps + "\n");
	        eps = dlamch('O');
	        System.err.print("Overflow threshold = " + eps + "\n");
	        eps = dlamch('E');
	        System.err.print("Precision = " + eps + "\n");

	        dchkqr(dotype, nm, mval, nn, nval, nnb, nbval, nxval, nrhs, thresh, tsterr, nmax, A, AF, AQ, AR, AC, B, X,
	                XACT, tau, work, rwork, iwork);
	    } // dchkqr_test

	    /**
	     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive dchkst,
	     * that tests routines used in symmetric generalized eigenvalue problem. The routines tested are dsytrd, dorgtr,
	     * dsteqr, and dsterf. Numerical values were obtained from the sep.in datafile. Original DCHKEE created by Univ. of
	     * Tennessee, Univ. of California Berkeley, and NAG Ltd., January, 2007
	     */
	    private void dchkst_test() {

	        // Number of values of n
	        final int nn = 6;

	        // Values of matrix dimension n
	        final int[] nval = new int[] {0, 1, 2, 3, 5, 20};

	        // Number of values of NB, NBMIN, and NX
	        final int nparms = 5;

	        // Values of blocksize NB
	        final int[] nbval = new int[] {1, 3, 3, 3, 10};

	        // Values of minimum blocksize NBMIN
	        final int[] nbmin = new int[] {2, 2, 2, 2, 2};

	        // Values of crossover point NX
	        final int[] nxval = new int[] {1, 0, 5, 9, 1};

	        // Threshold value for the test ratios. Information will be printed
	        // about each test for which the test ratio is greater than or equal
	        // to threshold.
	        final double thresh = 50.0;

	        // Test the LAPACK routines
	        final boolean tstchk = true;

	        // Code describing how to set the random number seed.
	        // = 0: Set the seed to a default number before each run.
	        // = 1: Initialize the seed to a default value only before the first
	        // run.
	        // = 2: Like 1, but use the seed values in the 4 integer array
	        // ioldsd
	        int newsd = 1;
	        final int maxt = 30;
	        final boolean[] dotype = new boolean[maxt];
	        final int[] ioldsd = new int[] {0, 0, 0, 1};
	        final int[] iseed = new int[] {0, 0, 0, 1};
	        final int nmax = 132;
	        final int lwork = (nmax * ( (5 * nmax) + 5)) + 1;
	        final int liwork = nmax * ( (5 * nmax) + 20);
	        final int[] iwork = new int[liwork];
	        final double[] work = new double[lwork];
	        final double[] result = new double[500];
	        final int[] info = new int[1];
	        double[][] A;
	        double[] AP;
	        double[] SD;
	        double[] SE;
	        double[] D1;
	        double[] D2;
	        double[] D3;
	        double[] D4;
	        double[] D5;
	        double[] WA1;
	        double[] WA2;
	        double[] WA3;
	        double[] WR;
	        double[][] U;
	        double[][] V;
	        double[] VP;
	        double[] TAU;
	        double[][] Z;

	        final int maxtyp = 21;
	        int i;
	        int k;
	        int maxnval;
	        System.out.println("Tests of the Symmetric Eigenvalue Problem routines\n");

	        for (i = 0; i < maxtyp; i++) {
	            dotype[i] = true;
	        }

	        maxnval = 0;

	        for (i = 0; i < nn; i++) {

	            if (nval[i] > maxnval) {
	                maxnval = nval[i];
	            }
	        }

	        iparms = new int[100];

	        // 9 = maximum size of the subproblems at the bottom of the computation
	        // tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd)
	        iparms[9 - 1] = 25;
	        A = new double[nmax][maxnval];
	        AP = new double[maxnval * (maxnval + 1) / 2];
	        SD = new double[maxnval];
	        SE = new double[maxnval];
	        D1 = new double[maxnval];
	        D2 = new double[maxnval];
	        D3 = new double[maxnval];
	        D4 = new double[maxnval];
	        D5 = new double[maxnval];
	        WA1 = new double[maxnval];
	        WA2 = new double[maxnval];
	        WA3 = new double[maxnval];
	        WR = new double[maxnval];
	        U = new double[nmax][maxnval];
	        V = new double[nmax][maxnval];
	        VP = new double[maxnval * (maxnval + 1) / 2];
	        TAU = new double[maxnval];
	        Z = new double[nmax][maxnval];

	        for (i = 1; i <= nparms; i++) {

	            // 1 = The optimal blocksize; if this value is 1, an unblocked
	            // algorithm will give the best performance
	            iparms[1 - 1] = nbval[i - 1];

	            // 2 = The minimum blocksize for which the block routine should be
	            // used; if the usable block size is less than this value, an
	            // unblocked routine should be used.
	            iparms[2 - 1] = nbmin[i - 1];

	            // 3 = The crossover point (in a block routine, for n less than this
	            // value, an unblocked routine should be used).
	            iparms[3 - 1] = nxval[i - 1];

	            if (newsd == 0) {

	                for (k = 0; k < 4; k++) {
	                    iseed[k] = ioldsd[k];
	                }
	            } // if (newsd == 0)

	            System.out.println("Optimal blocksize = " + nbval[i - 1] + "\n");
	            System.out.println("Minimum blocksize = " + nbmin[i - 1] + "\n");
	            System.out.println("Crossover point = " + nxval[i - 1] + "\n");

	            if (tstchk) {
	                dchkst(nn, nval, maxtyp, dotype, iseed, thresh, A, nmax, AP, SD, SE, D1, D2, D3, D4, D5, WA1, WA2, WA3,
	                        WR, U, nmax, V, VP, TAU, Z, work, lwork, iwork, liwork, result, info);

	                if (info[0] != 0) {
	                    System.err.println("dckkst had info = " + info[0]);
	                }
	            } // if (tstchk)
	        } // for (i = 1; i <= nparms; i++)
	    } // dckkst_test

	    /**
	     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive ddrvst,
	     * that tests symmetric generalized eigenvalue drivers. The driver tested is dsyev. Numerical values were obtained
	     * from the sep.in datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of California Berkeley, and NAG
	     * Ltd., January, 2007
	     */
	    private void ddrvst_test() {

	        // Number of values of n
	        final int nn = 6;

	        // Values of matrix dimension n
	        final int[] nval = new int[] {0, 1, 2, 3, 5, 20};

	        // Number of values of NB, NBMIN, and NX
	        final int nparms = 5;

	        // Values of blocksize NB
	        final int[] nbval = new int[] {1, 3, 3, 3, 10};

	        // Values of minimum blocksize NBMIN
	        final int[] nbmin = new int[] {2, 2, 2, 2, 2};

	        // Values of crossover point NX
	        final int[] nxval = new int[] {1, 0, 5, 9, 1};

	        // Threshold value for the test ratios. Information will be printed
	        // about each test for which the test ratio is greater than or equal
	        // to threshold.
	        final double thresh = 50.0;

	        // Test the driver routines
	        final boolean tstdrv = true;

	        // Code describing how to set the random number seed.
	        // = 0: Set the seed to a default number before each run.
	        // = 1: Initialize the seed to a default value only before the first
	        // run.
	        // = 2: Like 1, but use the seed values in the 4 integer array
	        // ioldsd
	        int newsd = 1;
	        final int maxt = 30;
	        final boolean[] dotype = new boolean[maxt];
	        final int[] ioldsd = new int[] {0, 0, 0, 1};
	        final int[] iseed = new int[] {0, 0, 0, 1};
	        final int nmax = 132;
	        final int lwork = (nmax * ( (5 * nmax) + 5)) + 1;
	        final int liwork = nmax * ( (5 * nmax) + 20);
	        final int[] iwork = new int[liwork];
	        final double[] work = new double[lwork];
	        final double[] result = new double[500];
	        final int[] info = new int[1];
	        double[][] A;
	        double[] D1;
	        double[] D2;
	        double[] D3;
	        double[] D4;
	        double[] eveigs;
	        double[] WA1;
	        double[] WA2;
	        double[] WA3;
	        double[][] U;
	        double[][] V;
	        double[] tau;
	        double[][] Z;

	        final int maxtyp = 21;
	        int i;
	        int k;
	        int maxnval;
	        System.out.println("Tests of the Symmetric Eigenvalue Problem routines\n");

	        for (i = 0; i < maxtyp; i++) {
	            dotype[i] = true;
	        }

	        maxnval = 0;

	        for (i = 0; i < nn; i++) {

	            if (nval[i] > maxnval) {
	                maxnval = nval[i];
	            }
	        }

	        iparms = new int[100];

	        // 9 = maximum size of the subproblems at the bottom of the computation
	        // tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd)
	        iparms[9 - 1] = 25;
	        A = new double[nmax][maxnval];
	        D1 = new double[maxnval];
	        D2 = new double[maxnval];
	        D3 = new double[maxnval];
	        D4 = new double[maxnval];
	        eveigs = new double[maxnval];
	        WA1 = new double[maxnval];
	        WA2 = new double[maxnval];
	        WA3 = new double[maxnval];
	        U = new double[nmax][maxnval];
	        V = new double[nmax][maxnval];
	        tau = new double[maxnval];
	        Z = new double[nmax][maxnval];

	        for (i = 1; i <= nparms; i++) {

	            // 1 = The optimal blocksize; if this value is 1, an unblocked
	            // algorithm will give the best performance
	            iparms[1 - 1] = nbval[i - 1];

	            // 2 = The minimum blocksize for which the block routine should be
	            // used; if the usable block size is less than this value, an
	            // unblocked routine should be used.
	            iparms[2 - 1] = nbmin[i - 1];

	            // 3 = The crossover point (in a block routine, for n less than this
	            // value, an unblocked routine should be used).
	            iparms[3 - 1] = nxval[i - 1];

	            if (newsd == 0) {

	                for (k = 0; k < 4; k++) {
	                    iseed[k] = ioldsd[k];
	                }
	            } // if (newsd == 0)

	            System.out.println("Optimal blocksize = " + nbval[i - 1] + "\n");
	            System.out.println("Minimum blocksize = " + nbmin[i - 1] + "\n");
	            System.out.println("Crossover point = " + nxval[i - 1] + "\n");

	            if (tstdrv) {
	                ddrvst(nn, nval, 18, dotype, iseed, thresh, A, nmax, D1, D2, D3, D4, eveigs, WA1, WA2, WA3, U, nmax, V,
	                        tau, Z, work, lwork, iwork, liwork, result, info);

	                if (info[0] != 0) {
	                    System.err.println("ddrvst had info = " + info[0]);
	                }
	            } // if (tstchk)
	        } // for (i = 1; i <= nparms; i++)
	    } // ddrvst_test

	    /**
	     * This is a port of a portion of version 3.1 LAPACK routine DERRQR. * Univ. of Tennessee, Univ. of California
	     * Berkeley and NAG Ltd.. November 2006
	     */
	    private void derrqr() {
	        final int nmax = 2;
	        int i;
	        final int info[] = new int[1];
	        int j;
	        final double A[][] = new double[nmax][nmax];
	        final double AF[][] = new double[nmax][nmax];
	        final double B[][] = new double[nmax][nmax];
	        final double b[] = new double[nmax];
	        final double w[] = new double[nmax];
	        final double x[] = new double[nmax];
	        int npass = 49;
	        final int ntotal = 49;

	        // Set the variables to innocuous values
	        for (j = 1; j <= nmax; j++) {
	            for (i = 1; i <= nmax; i++) {
	                A[i - 1][j - 1] = 1.0 / (double) (i + j);
	                AF[i - 1][j - 1] = 1.0 / (double) (i + j);
	                B[i - 1][j - 1] = 1.0 / (double) (i + j);
	            }
	            b[j - 1] = 0.0;
	            w[j - 1] = 0.0;
	            x[j - 1] = 0.0;
	        }

	        // Error exits for QR factorization

	        // DGEQRF
	        dgeqrf( -1, 0, A, 1, b, w, 1, info);
	        if (info[0] != -1) {
	            System.err.print("dgeqrf(-1, 0, A, 1, b, w, 1, info) produced info[0] = " + info[0] + " instead of -1\n");
	            npass--;
	        }

	        dgeqrf(0, -1, A, 1, b, w, 1, info);
	        if (info[0] != -2) {
	            System.err.print("dgeqrf(-0, -1, A, 1, b, w, 1, info) produced info[0] = " + info[0] + " instead of -2\n");
	            npass--;
	        }

	        dgeqrf(2, 1, A, 1, b, w, 1, info);
	        if (info[0] != -4) {
	            System.err.print("dgeqrf(2, 1, A, 1, b, w, 1, info) produced info[0] = " + info[0] + " instead of -4\n");
	            npass--;
	        }

	        dgeqrf(1, 2, A, 1, b, w, 1, info);
	        if (info[0] != -7) {
	            System.err.print("dgeqrf(1, 2, A, 1, b, w, 1, info) produced info[0] = " + info[0] + " instead of -7\n");
	            npass--;
	        }

	        // DGEQR2
	        dgeqr2( -1, 0, A, 1, b, w, info);
	        if (info[0] != -1) {
	            System.err.print("dgeqr2(-1, 0, A, 1, b, w, info) produced info[0] = " + info[0] + " instead of -1\n");
	            npass--;
	        }

	        dgeqr2(0, -1, A, 1, b, w, info);
	        if (info[0] != -2) {
	            System.err.print("dgeqr2(0, -1, A, 1, b, w, info) produced info[0] = " + info[0] + " instead of -2\n");
	            npass--;
	        }

	        dgeqr2(2, 1, A, 1, b, w, info);
	        if (info[0] != -4) {
	            System.err.print("dgeqr2(2, 1, A, 1, b, w, info) produced info[0] = " + info[0] + " instead of -4\n");
	            npass--;
	        }

	        // DGEQRS
	        dgeqrs( -1, 0, 0, A, 1, x, B, 1, w, 1, info);
	        if (info[0] != -1) {
	            System.err.print("dgeqrs(-1, 0, 0, A, 1, x, B, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -1\n");
	            npass--;
	        }

	        dgeqrs(0, -1, 0, A, 1, x, B, 1, w, 1, info);
	        if (info[0] != -2) {
	            System.err.print("dgeqrs(0, -1, 0, A, 1, x, B, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -2\n");
	            npass--;
	        }

	        dgeqrs(1, 2, 0, A, 2, x, B, 2, w, 1, info);
	        if (info[0] != -2) {
	            System.err.print("dgeqrs(1, 2, 0, A, 2, x, B, 2, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -2\n");
	            npass--;
	        }

	        dgeqrs(0, 0, -1, A, 1, x, B, 1, w, 1, info);
	        if (info[0] != -3) {
	            System.err.print("dgeqrs(0, 0, -1, A, 1, x, B, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -3\n");
	            npass--;
	        }

	        dgeqrs(2, 1, 0, A, 1, x, B, 2, w, 1, info);
	        if (info[0] != -5) {
	            System.err.print("dgeqrs(2, 1, 0, A, 1, x, B, 2, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dgeqrs(2, 1, 0, A, 2, x, B, 1, w, 1, info);
	        if (info[0] != -8) {
	            System.err.print("dgeqrs(2, 1, 0, A, 2, x, B, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -8\n");
	            npass--;
	        }

	        dgeqrs(1, 1, 2, A, 1, x, B, 1, w, 1, info);
	        if (info[0] != -10) {
	            System.err.print("dgeqrs(1, 1, 2, A, 1, x, B, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -10\n");
	            npass--;
	        }

	        // DORGQR
	        dorgqr( -1, 0, 0, A, 1, x, w, 1, info);
	        if (info[0] != -1) {
	            System.err.print("dorgqr(-1, 0, 0, A, 1, x, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -1\n");
	            npass--;
	        }

	        dorgqr(0, -1, 0, A, 1, x, w, 1, info);
	        if (info[0] != -2) {
	            System.err.print("dorgqr(0, -1, 0, A, 1, x, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -2\n");
	            npass--;
	        }

	        dorgqr(1, 2, 0, A, 1, x, w, 2, info);
	        if (info[0] != -2) {
	        	System.err.print("dorgqr(1, 2, 0, A, 1, x, w, 2, info) produced info[0] = " + info[0] + " instead of -2\n");
	            npass--;
	        }

	        dorgqr(0, 0, -1, A, 1, x, w, 1, info);
	        if (info[0] != -3) {
	            System.err.print("dorgqr(0, 0, -1, A, 1, x, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -3\n");
	            npass--;
	        }

	        dorgqr(1, 1, 2, A, 1, x, w, 1, info);
	        if (info[0] != -3) {
	        	System.err.print("dorgqr(1, 1, 2, A, 1, x, w, 1, info) produced info[0] = " + info[0] + " instead of -3\n");
	            npass--;
	        }

	        dorgqr(2, 2, 0, A, 1, x, w, 2, info);
	        if (info[0] != -5) {
	        	System.err.print("dorgqr(2, 2, 0, A, 1, x, w, 2, info) produced info[0] = " + info[0] + " instead of -5\n");
	            npass--;
	        }

	        dorgqr(2, 2, 0, A, 2, x, w, 1, info);
	        if (info[0] != -8) {
	        	System.err.print("dorgqr(2, 2, 0, A, 2, x, w, 1, info) produced info[0] = " + info[0] + " instead of -8\n");
	            npass--;
	        }

	        // DORG2R
	        dorg2r( -1, 0, 0, A, 1, x, w, info);
	        if (info[0] != -1) {
	            System.err.print("dorg2r(-1, 0, 0, A, 1, x, w, info) produced info[0] = " + info[0] + " instead of -1\n");
	            npass--;
	        }

	        dorg2r(0, -1, 0, A, 1, x, w, info);
	        if (info[0] != -2) {
	            System.err.print("dorg2r(0, -1, 0, A, 1, x, w, info) produced info[0] = " + info[0] + " instead of -2\n");
	            npass--;
	        }

	        dorg2r(1, 2, 0, A, 1, x, w, info);
	        if (info[0] != -2) {
	            System.err.print("dorg2r(1, 2, 0, A, 1, x, w, info) produced info[0] = " + info[0] + " instead of -2\n");
	            npass--;
	        }

	        dorg2r(0, 0, -1, A, 1, x, w, info);
	        if (info[0] != -3) {
	            System.err.print("dorg2r(0, 0, -1, A, 1, x, w, info) produced info[0] = " + info[0] + " instead of -3\n");
	            npass--;
	        }

	        dorg2r(2, 1, 2, A, 2, x, w, info);
	        if (info[0] != -3) {
	            System.err.print("dorg2r(2, 1, 2, A, 2, x, w, info) produced info[0] = " + info[0] + " instead of -3\n");
	            npass--;
	        }

	        dorg2r(2, 1, 0, A, 1, x, w, info);
	        if (info[0] != -5) {
	            System.err.print("dorg2r(2, 1, 0, A, 1, x, w, info) produced info[0] = " + info[0] + " instead of -5\n");
	            npass--;
	        }

	        // DORMQR
	        dormqr('/', 'N', 0, 0, 0, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -1) {
	            System.err.print("dormqr('/', 'N', 0, 0, 0, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -1\n");
	            npass--;
	        }

	        dormqr('L', '/', 0, 0, 0, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -2) {
	            System.err.print("dormqr('L', '/', 0, 0, 0, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -2\n");
	            npass--;
	        }

	        dormqr('L', 'N', -1, 0, 0, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -3) {
	            System.err.print("dormqr('L', 'N', -1, 0, 0, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -3\n");
	            npass--;
	        }

	        dormqr('L', 'N', 0, -1, 0, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -4) {
	            System.err.print("dormqr('L', 'N', 0, -1, 0, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -4\n");
	            npass--;
	        }

	        dormqr('L', 'N', 0, 0, -1, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -5) {
	            System.err.print("dormqr('L', 'N', 0, 0, -1, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dormqr('L', 'N', 0, 1, 1, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -5) {
	            System.err.print("dormqr('L', 'N', 0, 1, 1, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dormqr('R', 'N', 1, 0, 1, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -5) {
	            System.err.print("dormqr('R', 'N', 1, 0, 1, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dormqr('L', 'N', 2, 1, 0, A, 1, x, AF, 2, w, 1, info);
	        if (info[0] != -7) {
	            System.err.print("dormqr('L', 'N', 2, 1, 0, A, 1, x, AF, 2, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -7\n");
	            npass--;
	        }

	        dormqr('R', 'N', 1, 2, 0, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -7) {
	            System.err.print("dormqr('R', 'N', 1, 2, 0, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -7\n");
	            npass--;
	        }

	        dormqr('L', 'N', 2, 1, 0, A, 2, x, AF, 1, w, 1, info);
	        if (info[0] != -10) {
	            System.err.print("dormqr('L', 'N', 2, 1, 0, A, 2, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -10\n");
	            npass--;
	        }

	        dormqr('L', 'N', 1, 2, 0, A, 1, x, AF, 1, w, 1, info);
	        if (info[0] != -12) {
	            System.err.print("dormqr('L', 'N', 1, 2, 0, A, 1, x, AF, 1, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -12\n");
	            npass--;
	        }

	        dormqr('R', 'N', 2, 1, 0, A, 1, x, AF, 2, w, 1, info);
	        if (info[0] != -12) {
	            System.err.print("dormqr('R', 'N', 2, 1, 0, A, 1, x, AF, 2, w, 1, info) produced info[0] = " + info[0]
	                    + " instead of -12\n");
	            npass--;
	        }

	        // DORM2R
	        dorm2r('/', 'N', 0, 0, 0, A, 1, x, AF, 1, w, info);
	        if (info[0] != -1) {
	            System.err.print("dorm2r('/', 'N', 0, 0, 0, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -1\n");
	            npass--;
	        }

	        dorm2r('L', '/', 0, 0, 0, A, 1, x, AF, 1, w, info);
	        if (info[0] != -2) {
	            System.err.print("dorm2r('L', '/', 0, 0, 0, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -2\n");
	            npass--;
	        }

	        dorm2r('L', 'N', -1, 0, 0, A, 1, x, AF, 1, w, info);
	        if (info[0] != -3) {
	            System.err.print("dorm2r('L', 'N', -1, 0, 0, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -3\n");
	            npass--;
	        }

	        dorm2r('L', 'N', 0, -1, 0, A, 1, x, AF, 1, w, info);
	        if (info[0] != -4) {
	            System.err.print("dorm2r('L', 'N', 0, -1, 0, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -4\n");
	            npass--;
	        }

	        dorm2r('L', 'N', 0, 0, -1, A, 1, x, AF, 1, w, info);
	        if (info[0] != -5) {
	            System.err.print("dorm2r('L', 'N', 0, 0, -1, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dorm2r('L', 'N', 0, 1, 1, A, 1, x, AF, 1, w, info);
	        if (info[0] != -5) {
	            System.err.print("dorm2r('L', 'N', 0, 1, 1, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dorm2r('R', 'N', 1, 0, 1, A, 1, x, AF, 1, w, info);
	        if (info[0] != -5) {
	            System.err.print("dorm2r('R', 'N', 1, 0, 1, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -5\n");
	            npass--;
	        }

	        dorm2r('L', 'N', 2, 1, 0, A, 1, x, AF, 2, w, info);
	        if (info[0] != -7) {
	            System.err.print("dorm2r('L', 'N', 2, 1, 0, A, 1, x, AF, 2, w, info) produced info[0] = " + info[0]
	                    + " instead of -7\n");
	            npass--;
	        }

	        dorm2r('R', 'N', 1, 2, 0, A, 1, x, AF, 1, w, info);
	        if (info[0] != -7) {
	            System.err.print("dorm2r('R', 'N', 1, 2, 0, A, 1, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -7\n");
	            npass--;
	        }

	        dorm2r('L', 'N', 2, 1, 0, A, 2, x, AF, 1, w, info);
	        if (info[0] != -10) {
	            System.err.print("dorm2r('L', 'N', 2, 1, 0, A, 2, x, AF, 1, w, info) produced info[0] = " + info[0]
	                    + " instead of -10\n");
	            npass--;
	        }

	        System.err.print("derrqr correctly found " + npass + " of " + ntotal + " error exits\n");
	        return;
	    } // derrqr

	    /**
	     * This is a port of version 3.1 LAPACK routine DGEQRS. Univ. of Tennessee, Univ. of California Berkeley and NAG
	     * Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. INTEGER INFO, LDA, LDB, LWORK, M, N, NRHS .. .. Array Arguments .. DOUBLE PRECISION A(
	     * LDA, * ), B( LDB, * ), TAU( * ), $ WORK( LWORK ) ..
	     * 
	     * Purpose =======
	     * 
	     * Solve the least squares problem min || A*X - B || using the QR factorization A = Q*R computed by DGEQRF.
	     * 
	     * Arguments =========
	     * 
	     * M (input) INTEGER The number of rows of the matrix A. M >= 0.
	     * 
	     * N (input) INTEGER The number of columns of the matrix A. M >= N >= 0.
	     * 
	     * NRHS (input) INTEGER The number of columns of B. NRHS >= 0.
	     * 
	     * A (input) DOUBLE PRECISION array, dimension (LDA,N) Details of the QR factorization of the original matrix A as
	     * returned by DGEQRF.
	     * 
	     * LDA (input) INTEGER The leading dimension of the array A. LDA >= M.
	     * 
	     * TAU (input) DOUBLE PRECISION array, dimension (N) Details of the orthogonal matrix Q.
	     * 
	     * B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the m-by-nrhs right hand side matrix B.
	     * On exit, the n-by-nrhs solution matrix X.
	     * 
	     * LDB (input) INTEGER The leading dimension of the array B. LDB >= M.
	     * 
	     * WORK (workspace) DOUBLE PRECISION array, dimension (LWORK)
	     * 
	     * LWORK (input) INTEGER The length of the array WORK. LWORK must be at least NRHS, and should be at least NRHS*NB,
	     * where NB is the block size for this environment.
	     * 
	     * INFO (output) INTEGER = 0: successful exit < 0: if INFO = -i, the i-th argument had an illegal value
	     */
	    private void dgeqrs(final int m, final int n, final int nrhs, final double A[][], final int lda,
	            final double[] tau, final double[][] B, final int ldb, final double[] work, final int lwork,
	            final int info[]) {

	        // Test the input arguments.
	        info[0] = 0;
	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (n < 0) || (n > m)) {
	            info[0] = -2;
	        } else if (nrhs < 0) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -5;
	        } else if (ldb < Math.max(1, m)) {
	            info[0] = -8;
	        } else if ( (lwork < 1) || (lwork < nrhs) && (m > 0) && (n > 0)) {
	            info[0] = -10;
	        }
	        if (info[0] != 0) {
	            System.err.println("dgeqrs had info[0] = " + info[0]);
	            return;
	        }

	        // Quick return if possible
	        if ( (n == 0) || (nrhs == 0) || (m == 0)) {
	            return;
	        }

	        // B := Q' * B
	        dormqr('L', 'T', m, nrhs, n, A, lda, tau, B, ldb, work, lwork, info);

	        // Solve R*X = B(1:n,:)

	        dtrsm('L', 'U', 'N', 'N', n, nrhs, 1.0, A, lda, B, ldb);
	        return;
	    } // dgeqrs

	    /**
	     * This is a port of version 3.1 LAPACK test routine DGET02. Univ. of Tennessee, Univ. of California Berkeley and
	     * NAG Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. CHARACTER TRANS INTEGER LDA, LDB, LDX, M, N, NRHS DOUBLE PRECISION RESID .. .. Array
	     * Arguments .. DOUBLE PRECISION A( LDA, * ), B( LDB, * ), RWORK( * ), $ X( LDX, * ) ..
	     * 
	     * Purpose =======
	     * 
	     * DGET02 computes the residual for a solution of a system of linear equations A*x = b or A'*x = b: RESID = norm(B -
	     * A*X) / ( norm(A) * norm(X) * EPS ), where EPS is the machine epsilon.
	     * 
	     * Arguments =========
	     * 
	     * TRANS (input) CHARACTER*1 Specifies the form of the system of equations: = 'N': A *x = b = 'T': A'*x = b, where
	     * A' is the transpose of A = 'C': A'*x = b, where A' is the transpose of A
	     * 
	     * M (input) INTEGER The number of rows of the matrix A. M >= 0.
	     * 
	     * N (input) INTEGER The number of columns of the matrix A. N >= 0.
	     * 
	     * NRHS (input) INTEGER The number of columns of B, the matrix of right hand sides. NRHS >= 0.
	     * 
	     * A (input) DOUBLE PRECISION array, dimension (LDA,N) The original M x N matrix A.
	     * 
	     * LDA (input) INTEGER The leading dimension of the array A. LDA >= max(1,M).
	     * 
	     * X (input) DOUBLE PRECISION array, dimension (LDX,NRHS) The computed solution vectors for the system of linear
	     * equations.
	     * 
	     * LDX (input) INTEGER The leading dimension of the array X. If TRANS = 'N', LDX >= max(1,N); if TRANS = 'T' or 'C',
	     * LDX >= max(1,M).
	     * 
	     * B (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS) On entry, the right hand side vectors for the
	     * system of linear equations. On exit, B is overwritten with the difference B - A*X.
	     * 
	     * LDB (input) INTEGER The leading dimension of the array B. IF TRANS = 'N', LDB >= max(1,M); if TRANS = 'T' or 'C',
	     * LDB >= max(1,N).
	     * 
	     * RWORK (workspace) DOUBLE PRECISION array, dimension (M)
	     * 
	     * RESID (output) DOUBLE PRECISION The maximum over the number of right hand sides of norm(B - A*X) / ( norm(A) *
	     * norm(X) * EPS ).
	     */
	    private void dget02(final char trans, final int m, final int n, final int nrhs, final double[][] A, final int lda,
	            final double[][] X, final int ldx, final double[][] B, final int ldb, final double[] rwork,
	            final double[] resid) {
	        int j;
	        int n1;
	        int n2;
	        double anorm;
	        double bnorm;
	        double eps;
	        double xnorm;
	        int p;

	        // Quick exit if m == 0 or n == 0 or nrhs == 0
	        if ( (m <= 0) || (n <= 0) || (nrhs <= 0)) {
	            resid[0] = 0.0;
	            return;
	        }

	        if ( (trans == 'T') || (trans == 't') || (trans == 'C') || (trans == 'c')) {
	            n1 = n;
	            n2 = m;
	        } else {
	            n1 = m;
	            n2 = n;
	        }

	        // Exit with resid[0] = 1/eps if anorm = 0.
	        eps = dlamch('E'); // Epsilon
	        anorm = dlange('1', n1, n2, A, lda, rwork);
	        if (anorm <= 0.0) {
	            resid[0] = 1.0 / eps;
	            return;
	        }

	        // Compute B - A*X (or B - A'*X) and store in B.
	        dgemm(trans, 'N', n1, nrhs, n2, -1.0, A, lda, X, ldx, 1.0, B, ldb);

	        // Compute the maximum overr the number of right hand sides of
	        // norm(B - A*X)/(norm(A) * norm(X) * eps).
	        resid[0] = 0.0;
	        for (j = 1; j <= nrhs; j++) {
	            bnorm = 0.0;
	            for (p = 0; p < n1; p++) {
	                bnorm += Math.abs(B[p][j - 1]);
	            }
	            xnorm = 0.0;
	            for (p = 0; p < n2; p++) {
	                xnorm += Math.abs(X[p][j - 1]);
	            }
	            if (xnorm <= 0.0) {
	                resid[0] = 1.0 / eps;
	            } else {
	                resid[0] = Math.max(resid[0], ( (bnorm / anorm) / xnorm) / eps);
	            }
	        } // for (j = 1; j <= nrhs; j++)
	        return;
	    } // dget02

	    /**
	     * This is a port of the version 3.1 LAPACK driver routine DGGEV Original DGGEV created by Univ. of Tennessee, Univ.
	     * of California Berkeley, and NAG Ltd., November, 2006 dggev computes for a pair of n by n real nonsymmetric
	     * matrices (A,B) the generalized eigenvalues, and optionally, the left and/or right generalized eigenvectors.
	     * 
	     * <p>
	     * A generalized eigenvalue for a pair of matrices (A,B) is a scalar lambda or a ratio alpha/beta = lambda, such
	     * that A - lambda*B is singular. It is usually represented as the pair (alpha, beta), as there is a reasonable
	     * interpretation for beta = 0, and even for both being zero.
	     * </p>
	     * 
	     * <p>
	     * The right eigenvector v[j] corresponding to the eigenvalue lambda[j] of (A,B) satisfies A * v[j] = lambda[j] * B
	     * * v[j] The left eigenvector u[j] corresponding to the eigenvalue lambda[j] of (A,B) satisfies u[j]**H * A =
	     * lambda[j] * u[j]**H * B where u[j]**H is the conjugate-transpose of u[j].
	     * </p>
	     * 
	     * @param jobvl input char = 'N': do not compute the left generalized eigenvectors = 'V': compute the left
	     *            generalized eigenvectors
	     * @param jobvr input char = 'N': do not compute the right generalized eigenvectors = 'V': compute the right
	     *            generalized eigenvectors
	     * @param n input int The order of the matrices A, B, vl, and vr. n >= 0.
	     * @param A input/output double[][] of dimension (lda,n) On entry, the matrix A in the pair (A,B). On exit, A has
	     *            been overwritten.
	     * @param lda input int The leading dimension of A. lda >= max(1,n).
	     * @param B input/output double[][] of dimension (ldb,n). On entry, the matrix B in the pair (A,B). On exit, B has
	     *            been overwritten.
	     * @param ldb input int The leading dimension of B. ldb >= max(1,n).
	     * @param alphar output double[] of dimension n
	     * @param alphai output double[] of dimension n
	     * @param beta output double[] of dimension n On exit, (alphar[j] + alphai[j]*i)/beta[j], j = 0,...,n-1 will be the
	     *            generalized eigenvalues. If alphai[j] is zero, then the j-th eigenvalue is real; if positive, then the
	     *            j-th and (j+1)-st eigenvalues are a complex conjugate pair, with alphai[j+1] negative.
	     * 
	     *            <p>
	     *            Note: the quotients alphar[j]/beta[j] and alphai[j]/beta[j] may easily over- or underflow, and beta[j]
	     *            may even be zero. Thus, the user should avoid naively computing the ratio alpha/beta. However, alphar
	     *            and alphai will be always less than and usually comparable with norm(A) in magnitude, and beta always
	     *            less than and usually comparable with norm(B).
	     *            </p>
	     * @param vl output double[][] of dimension (ldvl,n) If jobvl = 'V', the left eigenvectors u[j] are stored one after
	     *            another in the columns of vl, in the same order as their eigenvalues. If the j-th eigenvalue is real,
	     *            then u[j] = vl(:,j), the j-th column of vl. If the j-th and (j+1)-th eigenvalues form a complex
	     *            conjugate pair, then u[j] = vl(:,j) + i*vl(:,j+1) and u[j+1] = vl(:,j) - i*vl(:,j+1). Each eigenvector
	     *            will be scaled so the largest component have abs(real part) + abs(imag part) = 1. Not referenced if
	     *            jobvl = 'N'.
	     * @param ldvl input int The leading dimension of matrix vl. ldvl >= 1, and if jobvl = 'V', ldvl >= n.
	     * @param vr output double[][] of dimension (ldvr,n) If jobvr = 'V', the right eigenvectors v[j] are stored one
	     *            after another in the columns of vr, in the same order as their eigenvalues. If the j-th eigenvalue is
	     *            real, then v[j] = vr(:,j), the j-th column of vr. If the j-th and (j+1)-th eigenvalues form a complex
	     *            pair, then v[j] = vr(:,j) + i*vr(:,j+1) and v[j+1] = vr(:,j) - i*vr(:,j+1). Each eigenvector will be
	     *            scaled so the largest component have abs(real part) + abs(imag part) = 1. Not referenced if jobvr =
	     *            'N'.
	     * @param ldvr input int The leading dimension of matrix vr. ldvr >= 1, and if jobvr = 'V', ldvr >= n.
	     * @param work (workspace/output) double[] of dimension max(1,lwork) On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= max(1,8*n). For good performance, lwork must
	     *            generally be larger. If lwork = -1, then a workspace query is assumed; the routine only calculates the
	     *            optimal size of the work array, returns this value as the first entry of the work array, and no error
	     *            message related to lwork is issued.
	     * @param info output int[] = 0: successful exit < 0: if info[0] = -i, the i-th argument had an illegal value =
	     *            1,...,n: The QZ iteration failed. No eigenvectors have been calculated, but alphar[j] , alphai[j], and
	     *            beta[j] should be correct for j = info[0],...,n-1. > n: = n+1: other than QZ iteration failed in
	     *            DHGEQZ. = n+2: error return from dtgevc.
	     */
	    private void dggev(final char jobvl, final char jobvr, final int n, final double[][] A, final int lda,
	            final double[][] B, final int ldb, final double[] alphar, final double[] alphai, final double[] beta,
	            final double[][] vl, final int ldvl, final double[][] vr, final int ldvr, final double[] work,
	            final int lwork, final int[] info) {
	        boolean ilascl;
	        boolean ilbscl;
	        boolean ilv;
	        boolean ilvl;
	        boolean ilvr;
	        boolean lquery;
	        char chtemp;
	        int icols;
	        final int[] ierr = new int[1];
	        final int[] ihi = new int[1];
	        int ijobvl;
	        int ijobvr;
	        final int[] ilo = new int[1];
	        final int[] in = new int[1];
	        int iright;
	        int irows;
	        int itau;
	        int iwrk;
	        int jc;
	        int jr;
	        int maxwrk = 1;
	        int minwrk;
	        double anrm;
	        double anrmto = 0.0;
	        final double[] bignum = new double[1];
	        double bnrm;
	        double bnrmto = 0.0;
	        double eps;
	        final double[] smlnum = new double[1];
	        double temp;
	        final boolean[] ldumma = new boolean[1];
	        String name;
	        String opts;
	        final double[] work2 = new double[n];
	        final double[] work3 = new double[6 * n];
	        double[][] array1;
	        double[][] array2;
	        double[] work4;
	        double[] work5;
	        int i;
	        int j;
	        int row1;

	        // Decode the input arguments
	        if ( (jobvl == 'N') || (jobvl == 'n')) {
	            ijobvl = 1;
	            ilvl = false;
	        } else if ( (jobvl == 'V') || (jobvl == 'v')) {
	            ijobvl = 2;
	            ilvl = true;
	        } else {
	            ijobvl = -1;
	            ilvl = false;
	        }

	        if ( (jobvr == 'N') || (jobvr == 'n')) {
	            ijobvr = 1;
	            ilvr = false;
	        } else if ( (jobvr == 'V') || (jobvr == 'v')) {
	            ijobvr = 2;
	            ilvr = true;
	        } else {
	            ijobvr = -1;
	            ilvr = false;
	        }

	        ilv = ilvl || ilvr;

	        // Test the input arguments
	        info[0] = 0;

	        if (lwork == -1) {
	            lquery = true;
	        } else {
	            lquery = false;
	        }

	        if (ijobvl <= 0) {
	            info[0] = -1;
	        } else if (ijobvr <= 0) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -5;
	        } else if (ldb < Math.max(1, n)) {
	            info[0] = -7;
	        } else if ( (ldvl < 1) || (ilvl && (ldvl < n))) {
	            info[0] = -12;
	        } else if ( (ldvr < 1) || (ilvr && (ldvr < n))) {
	            info[0] = -14;
	        }

	        // Compute workspace
	        // (Note: Comments in the code beginning "Workspace:" describe the
	        // minimal amount of workspace needed at that point in the code, as well
	        // as the preferred amount for good performance. NB refers to the
	        // optimal block size for the immediately follwing subroutine, as
	        // returned by ilaenv. The workspace is computed assuming ilo = 1 and
	        // ihi = n, the worst case.)

	        minwrk = 1;

	        if (info[0] == 0) {
	            minwrk = Math.max(1, 8 * n);
	            name = new String("DGEQRF");
	            opts = new String(" ");
	            maxwrk = Math.max(1, n * (7 + ilaenv(1, name, opts, n, 1, n, 0)));
	            name = new String("DORMQR");
	            maxwrk = Math.max(maxwrk, n * (7 + ilaenv(1, name, opts, n, 1, n, 0)));

	            if (ilvl) {
	                name = new String("DORGQR");
	                maxwrk = Math.max(maxwrk, n * (7 + ilaenv(1, name, opts, n, 1, n, -1)));
	            }

	            work[0] = maxwrk;

	            if ( (lwork < minwrk) && ( !lquery)) {
	                info[0] = -16;
	            }
	        } // if (info[0] == 0)

	        if (info[0] != 0) {
	            System.err.println("Error dggev had info[0] = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        // Get machine constants
	        eps = dlamch('P');
	        smlnum[0] = dlamch('S');
	        bignum[0] = 1.0 / smlnum[0];
	        dlabad(smlnum, bignum);
	        smlnum[0] = Math.sqrt(smlnum[0]) / eps;
	        bignum[0] = 1.0 / smlnum[0];

	        // Scale A if max element outside range (smlnum[0], bignum[0])
	        anrm = dlange('M', n, n, A, lda, work);
	        ilascl = false;

	        if ( (anrm > 0.0) && (anrm < smlnum[0])) {
	            anrmto = smlnum[0];
	            ilascl = true;
	        } else if (anrm > bignum[0]) {
	            anrmto = bignum[0];
	            ilascl = true;
	        }

	        if (ilascl) {
	            dlascl('G', 0, 0, anrm, anrmto, n, n, A, lda, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dlascl 1 had ierr[0] = " + ierr[0] + "\n");
	            }
	        }

	        // Scale B if max element outside range (smalnum[0], bignum[0])
	        bnrm = dlange('M', n, n, B, ldb, work);
	        ilbscl = false;

	        if ( (bnrm > 0.0) && (bnrm < smlnum[0])) {
	            bnrmto = smlnum[0];
	            ilbscl = true;
	        } else if (bnrm > bignum[0]) {
	            bnrmto = bignum[0];
	            ilbscl = true;
	        }

	        if (ilbscl) {
	            dlascl('G', 0, 0, bnrm, bnrmto, n, n, B, ldb, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dlascl 2 had ierr[0] = " + ierr[0] + "\n");
	            }
	        }

	        // Permute the matrices A, B to isolate eigenvalues if possible
	        // (Workspace: need 6*n)
	        iright = n + 1;
	        iwrk = iright + n;
	        dggbal('P', n, A, lda, B, ldb, ilo, ihi, work, work2, work3, ierr);

	        if (ierr[0] != 0) {
	            System.out.println("dggev call to dggbal had ierr[0] = " + ierr[0] + "\n");
	        }

	        // Reduce B to triangular form (QR decomposition of B)
	        // (Workspace: need n, prefer n*nb)
	        irows = ihi[0] + 1 - ilo[0];

	        if (ilv) {
	            icols = n + 1 - ilo[0];
	        } else {
	            icols = irows;
	        }

	        itau = iwrk;
	        iwrk = itau + irows;
	        row1 = Math.max(1, irows);
	        array1 = new double[row1][icols];

	        for (i = 0; i < row1; i++) {

	            for (j = 0; j < icols; j++) {
	                array1[i][j] = B[ilo[0] - 1 + i][ilo[0] - 1 + j];
	            }
	        }

	        work4 = new double[Math.min(irows, icols)];
	        work5 = new double[lwork + 1 - iwrk];
	        dgeqrf(irows, icols, array1, row1, work4, work5, lwork + 1 - iwrk, ierr);

	        if (ierr[0] != 0) {
	            System.out.println("dggev call to dgeqrf had ierr[0] = " + ierr[0] + "\n");
	        }

	        for (i = 0; i < row1; i++) {

	            for (j = 0; j < icols; j++) {
	                B[ilo[0] - 1 + i][ilo[0] - 1 + j] = array1[i][j];
	            }
	        }

	        // Apply the orthogonal transformation to matrix A
	        // (Workspace: need n, prefer n*nb)
	        array1 = new double[row1][irows];

	        for (i = 0; i < row1; i++) {

	            for (j = 0; j < irows; j++) {
	                array1[i][j] = B[ilo[0] - 1 + i][ilo[0] - 1 + j];
	            }
	        }

	        array2 = new double[row1][icols];

	        for (i = 0; i < row1; i++) {

	            for (j = 0; j < icols; j++) {
	                array2[i][j] = A[ilo[0] - 1 + i][ilo[0] - 1 + j];
	            }
	        }

	        dormqr('L', 'T', irows, icols, irows, array1, row1, work4, array2, row1, work5, lwork + 1 - iwrk, ierr);

	        if (ierr[0] != 0) {
	            System.out.println("dggev call to dormqr had ierr[0] = " + ierr[0] + "\n");
	        }

	        for (i = 0; i < row1; i++) {

	            for (j = 0; j < icols; j++) {
	                A[ilo[0] - 1 + i][ilo[0] - 1 + j] = array2[i][j];
	            }
	        }

	        // Initialize vl
	        // (Workspace: need n, prefer n*nb)
	        if (ilvl) {
	            dlaset('F', n, n, 0.0, 1.0, vl, ldvl);

	            if (irows > 1) {
	                row1 = Math.max(1, irows - 1);
	                array1 = new double[row1][irows - 1];

	                for (i = 0; i < row1; i++) {

	                    for (j = 0; j < (irows - 1); j++) {
	                        array1[i][j] = B[ilo[0] + i][ilo[0] - 1 + j];
	                    }
	                }

	                array2 = new double[row1][irows - 1];
	                dlacpy('L', irows - 1, irows - 1, array1, row1, array2, row1);

	                for (i = 0; i < row1; i++) {

	                    for (j = 0; j < (irows - 1); j++) {
	                        vl[ilo[0] + i][ilo[0] - 1 + j] = array2[i][j];
	                    }
	                }
	            } // if (irows > 1)

	            row1 = Math.max(1, irows);
	            array1 = new double[row1][irows];

	            for (i = 0; i < row1; i++) {

	                for (j = 0; j < irows; j++) {
	                    array1[i][j] = vl[ilo[0] - 1 + i][ilo[0] - 1 + j];
	                }
	            }

	            dorgqr(irows, irows, irows, array1, row1, work4, work5, lwork + 1 - iwrk, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dorgqr had ierr[0] = " + ierr[0] + "\n");
	            }

	            for (i = 0; i < row1; i++) {

	                for (j = 0; j < irows; j++) {
	                    vl[ilo[0] - 1 + i][ilo[0] - 1 + j] = array1[i][j];
	                }
	            }
	        } // if (ilvl)

	        // Initialize vr
	        if (ilvr) {
	            dlaset('F', n, n, 0.0, 1.0, vr, ldvr);
	        }

	        // Reduce to generalized Hessenberg form
	        // (Workspace: none needed)
	        if (ilv) {

	            // Eigenvectors requested -- work on whole matrix
	            dgghrd(jobvl, jobvr, n, ilo[0], ihi[0], A, lda, B, ldb, vl, ldvl, vr, ldvr, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dgghrd 1 had ierr[0] = " + ierr[0] + "\n");
	            }

	        } else {
	            row1 = Math.max(1, irows);
	            array1 = new double[row1][irows];
	            array2 = new double[row1][irows];

	            for (i = 0; i < row1; i++) {

	                for (j = 0; j < irows; j++) {
	                    array1[i][j] = A[ilo[0] - 1 + i][ilo[0] - 1 + j];
	                    array2[i][j] = B[ilo[0] - 1 + i][ilo[0] - 1 + j];
	                }
	            }

	            dgghrd('N', 'N', irows, 1, irows, array1, row1, array2, row1, vl, ldvl, vr, ldvr, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dgghrd 2 had ierr[0] = " + ierr[0] + "\n");
	            }

	            for (i = 0; i < row1; i++) {

	                for (j = 0; j < irows; j++) {
	                    A[ilo[0] - 1 + i][ilo[0] - 1 + j] = array1[i][j];
	                    B[ilo[0] - 1 + i][ilo[0] - 1 + j] = array2[i][j];
	                }
	            }
	        } // else

	        // Perform QZ algorithm (Compute eigenvalues, and optionally, the
	        // Schur forms and Schur vectors)
	        // (Workspace: need n)

	        iwrk = itau;

	        if (ilv) {
	            chtemp = 'S';
	        } else {
	            chtemp = 'E';
	        }
	        /*
	         * double Ainput[][] = new double[lda][n]; for (i = 0; i < lda; i++) { for (j = 0; j < n; j++) { Ainput[i][j] =
	         * A[i][j]; } } double Binput[][] = new double[ldb][n]; for (i = 0; i < ldb; i++) { for (j = 0; j < n; j++) {
	         * Binput[i][j] = B[i][j]; } }
	         */

	        dhgeqz(chtemp, jobvl, jobvr, n, ilo[0], ihi[0], A, lda, B, ldb, alphar, alphai, beta, vl, ldvl, vr, ldvr,
	                work5, lwork + 1 - iwrk, ierr);

	        if (ierr[0] != 0) {
	            System.out.println("dggev call to dhgeqz had ierr[0] = " + ierr[0] + "\n");
	            /*
	             * for (i = 0; i < n; i++) { for (j = 0; j < n; j++) { System.out.println("Ainput[" + i +"][" + j + "] = " +
	             * Ainput[i][j] + "\n"); } } for (i = 0; i < n; i++) { for (j = 0; j < n; j++) { System.out.println("Binput[" +
	             * i +"][" + j + "] = " + Binput[i][j] + "\n"); } } for (i = 0; i < n; i++) { for (j = 0; j < n; j++) {
	             * System.out.println("A[" + i +"][" + j + "] = " + A[i][j] + "\n"); } } for (i = 0; i < n; i++) { for (j = 0; j
	             * < n; j++) { System.out.println("B[" + i +"][" + j + "] = " + B[i][j] + "\n"); }}
	             */

	        }

	        if (ierr[0] != 0) {

	            if ( (ierr[0] > 0) && (ierr[0] <= n)) {
	                info[0] = ierr[0];
	            } else if ( (ierr[0] > n) && (ierr[0] <= (2 * n))) {
	                info[0] = ierr[0] - n;
	            } else {
	                info[0] = n + 1;
	            }

	            work[0] = maxwrk;

	            return;
	        } // if (ierr[0] != 0)

	        // Compute eigenvectors
	        // (Workspace: need 6*n)
	        if (ilv) {

	            if (ilvl) {

	                if (ilvr) {
	                    chtemp = 'B';
	                } // if (ilvr)
	                else {
	                    chtemp = 'L';
	                } // else
	            } // if (ilvl)
	            else {
	                chtemp = 'R';
	            } // else

	            work5 = new double[6 * n];
	            dtgevc(chtemp, 'B', ldumma, n, A, lda, B, ldb, vl, ldvl, vr, ldvr, n, in, work5, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dtgevc had ierr[0] = " + ierr[0] + "\n");
	                info[0] = n + 2;
	                work[0] = maxwrk;

	                return;
	            }

	            // Undo balancing on vl and vr and normalization
	            // (Workspace: none needed)
	            if (ilvl) {
	                dggbak('P', 'L', n, ilo[0], ihi[0], work, work2, n, vl, ldvl, ierr);

	                if (ierr[0] != 0) {
	                    System.out.println("dggev call to dggbak 1 had ierr[0] = " + ierr[0] + "\n");
	                }

	                for (jc = 0; jc < n; jc++) {

	                    if (alphai[jc] < 0.0) {
	                        continue;
	                    } // if (alphai[jc] < 0.0)

	                    temp = 0.0;

	                    if (alphai[jc] == 0.0) {

	                        for (jr = 0; jr < n; jr++) {
	                            temp = Math.max(temp, Math.abs(vl[jr][jc]));
	                        }
	                    } // if (alphai[jc] == 0.0)
	                    else { // alphai[jc] != 0.0

	                        for (jr = 0; jr < n; jr++) {
	                            temp = Math.max(temp, Math.abs(vl[jr][jc]) + Math.abs(vl[jr][jc + 1]));
	                        }
	                    } // else alphai[jc] != 0.0

	                    if (temp < smlnum[0]) {
	                        continue;
	                    } // if (temp < smlnum[0])

	                    temp = 1.0 / temp;

	                    if (alphai[jc] == 0.0) {

	                        for (jr = 0; jr < n; jr++) {
	                            vl[jr][jc] = vl[jr][jc] * temp;
	                        }
	                    } // if (alphai[jc] == 0.0)
	                    else { // alphai[jc] != 0.0

	                        for (jr = 0; jr < n; jr++) {
	                            vl[jr][jc] = vl[jr][jc] * temp;
	                            vl[jr][jc + 1] = vl[jr][jc + 1] * temp;
	                        } // for (jr = 0; jr < n; jr++)
	                    } // else alphai[jc] != 0.0
	                } // for (jc = 0; jc < n; jc++)
	            } // if (ilvl)

	            if (ilvr) {
	                dggbak('P', 'R', n, ilo[0], ihi[0], work, work2, n, vr, ldvr, ierr);

	                if (ierr[0] != 0) {
	                    System.out.println("dggev call to dggbak 2 had ierr[0] = " + ierr[0] + "\n");
	                }

	                for (jc = 0; jc < n; jc++) {

	                    if (alphai[jc] < 0.0) {
	                        continue;
	                    } // if (alphai[jc] < 0.0)

	                    temp = 0.0;

	                    if (alphai[jc] == 0.0) {

	                        for (jr = 0; jr < n; jr++) {
	                            temp = Math.max(temp, Math.abs(vr[jr][jc]));
	                        }
	                    } // if (alphai[jc] == 0.0)
	                    else { // alphai[jc] != 0.0

	                        for (jr = 0; jr < n; jr++) {
	                            temp = Math.max(temp, Math.abs(vr[jr][jc]) + Math.abs(vr[jr][jc + 1]));
	                        }
	                    } // else alphai[jc] != 0.0

	                    if (temp < smlnum[0]) {
	                        continue;
	                    } // if (temp < smlnum[0])

	                    temp = 1.0 / temp;

	                    if (alphai[jc] == 0.0) {

	                        for (jr = 0; jr < n; jr++) {
	                            vr[jr][jc] = vr[jr][jc] * temp;
	                        }
	                    } // if (alphai[jc] == 0.0)
	                    else { // alphai[jc] != 0.0

	                        for (jr = 0; jr < n; jr++) {
	                            vr[jr][jc] = vr[jr][jc] * temp;
	                            vr[jr][jc + 1] = vr[jr][jc + 1] * temp;
	                        } // for (jr = 0; jr < n; jr++)
	                    } // else alphai[jc] != 0.0
	                } // for (jc = 0; jc < n; jc++)
	            } // if (ilvr)
	            // End of eigenvector calculation
	        } // if (ilv)

	        // Undo scaling if necessary
	        if (ilascl) {
	            array1 = new double[n][1];

	            for (i = 0; i < n; i++) {
	                array1[i][0] = alphar[i];
	            }

	            dlascl('G', 0, 0, anrmto, anrm, n, 1, array1, n, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dlascl 3 had ierr[0] = " + ierr[0] + "\n");
	            }

	            for (i = 0; i < n; i++) {
	                alphar[i] = array1[i][0];
	                array1[i][0] = alphai[i];
	            }

	            dlascl('G', 0, 0, anrmto, anrm, n, 1, array1, n, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dlascl 4 had ierr[0] = " + ierr[0] + "\n");
	            }

	            for (i = 0; i < n; i++) {
	                alphai[i] = array1[i][0];
	            }
	        } // if (ilascl)

	        if (ilbscl) {
	            array1 = new double[n][1];

	            for (i = 0; i < n; i++) {
	                array1[i][0] = beta[i];
	            }

	            dlascl('G', 0, 0, bnrmto, bnrm, n, 1, array1, n, ierr);

	            if (ierr[0] != 0) {
	                System.out.println("dggev call to dlascl 5 had ierr[0] = " + ierr[0] + "\n");
	            }

	            for (i = 0; i < n; i++) {
	                beta[i] = array1[i][0];
	            }
	        } // if (ilbscl)

	        work[0] = maxwrk;

	        return;
	    } // dggev

	    /**
	     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive ddrgev in
	     * order to test DGGEV, that handles the nonsymmetric generalized eigenvalue problem. Numerical values were obtained
	     * from the dgv section in the dgd.in datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of California
	     * Berkeley, and NAG Ltd., January, 2007
	     */
	    private void dggev_test() {

	        // Number of values of n
	        final int nn = 6;

	        // Values of matrix dimension n
	        final int[] nval = new int[] {2, 6, 8, 10, 15, 20};

	        // Value of blocksize NB
	        final int[] nbval = new int[] {1};

	        // minimum blocksize NBMIN
	        final int[] nbmin = new int[] {1};

	        // Minimum dimension for blocking
	        final int[] nxval = new int[] {1};

	        // Number of shifts in xHGEQR
	        final int[] nsval = new int[] {2};

	        // Minimum column size for blocking
	        final int[] mxbval = new int[] {1};

	        // The test threshold against which computed residuals are compared.
	        // Should generally be in the range from 10.0 to 20.0. If it is 0.0,
	        // all test data will be printed.
	        final double thresh = 10.0;

	        final int maxt = 30;
	        final boolean[] dotype = new boolean[maxt];
	        final int[] iseed = new int[] {0, 0, 0, 1};
	        final int nmax = 132;
	        final int lwork = (nmax * ( (5 * nmax) + 5)) + 1;
	        final double[] work = new double[lwork];
	        final double[] result = new double[7];
	        final int[] info = new int[1];
	        double[][] A;
	        double[][] B;
	        double[][] S;
	        double[][] T;
	        double[][] Q;
	        double[][] Z;
	        double[][] QE;
	        double[] alphar;
	        double[] alphai;
	        double[] beta;
	        double[] alphr1;
	        double[] alphi1;
	        double[] beta1;

	        final int maxtyp = 26;
	        int i;
	        int maxnval;
	        System.out.println("Tests of the Generalized Nonsymmetric Eigenvalue Problem Driver dggev\n");

	        for (i = 0; i < maxtyp; i++) {
	            dotype[i] = true;
	        }

	        maxnval = 0;

	        for (i = 0; i < nn; i++) {

	            if (nval[i] > maxnval) {
	                maxnval = nval[i];
	            }
	        }

	        iparms = new int[100];
	        A = new double[nmax][maxnval];
	        B = new double[nmax][maxnval];
	        S = new double[nmax][maxnval];
	        T = new double[nmax][maxnval];
	        Q = new double[nmax][maxnval];
	        Z = new double[nmax][maxnval];
	        QE = new double[nmax][maxnval];
	        alphar = new double[maxnval];
	        alphai = new double[maxnval];
	        beta = new double[maxnval];
	        alphr1 = new double[maxnval];
	        alphi1 = new double[maxnval];
	        beta1 = new double[maxnval];

	        // 1 = The optimal blocksize; if this value is 1, an unblocked
	        // algorithm will give the best performance
	        iparms[1 - 1] = nbval[0];

	        // 2 = The minimum blocksize for which the block routine should be
	        // used; if the usable block size is less than this value, an
	        // unblocked routine should be used.
	        iparms[2 - 1] = nbmin[0];

	        // 3 = The crossover point (in a block routine, for n less than this
	        // value, an unblocked routine should be used).
	        iparms[3 - 1] = nxval[0];

	        // 4 = the number of shifts, used in the nonsymmetric eigenvalue
	        // routines
	        iparms[4 - 1] = nsval[0];

	        // 8 = another crossover point, for the multishift QR and QZ methods
	        // for nonsymmetric eigenvalue problems
	        iparms[8 - 1] = mxbval[0];

	        System.out.println("Optimal blocksize = " + nbval[0] + "\n");
	        System.out.println("Minimum blocksize = " + nbmin[0] + "\n");
	        System.out.println("Crossover point = " + nxval[0] + "\n");
	        System.out.println("Number of shifts = " + nsval[0] + "\n");
	        System.out.println("Another crossover point = " + mxbval[0] + "\n");

	        ddrgev(nn, nval, maxtyp, dotype, iseed, thresh, A, nmax, B, S, T, Q, nmax, Z, QE, nmax, alphar, alphai, beta,
	                alphr1, alphi1, beta1, work, lwork, result, info);

	        if (info[0] != 0) {
	            System.err.println("ddrgev had info = " + info[0]);
	        }
	    } // dggev_test
	         
	    /**
	     * This is a port of the version 3.1 LAPACK DSYEV routine Original DSYEV created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dsyev computes all eigenvalues and, optionally, eigenvectors of
	     * a real symmetric matrix A.
	     * 
	     * @param jobz input char = 'N': Compute eigenvalues only = 'V': Compute eigenvalues and eigenvectors.
	     * @param uplo input char = 'U': Upper triangle of A is stored = 'L': Lower triangle of A is stored
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param A input/output double[][] of dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
	     *            leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A. If uplo
	     *            = 'L', the leading n-by-n lower triangular part of A contains the lower triangular part of matrix A.
	     *            On exit, if jobz = 'V', then if info = 0, A contains the orthonormal eigenvectors of the matrix A. If
	     *            jobz = 'N', then on exit the lower triangle (if uplo = 'L') or the upper triangle (if uplo = 'U') of
	     *            A, including the diagonal, is destroyed.
	     * @param lda input int The leading dimension of array A. lda >= max(1,n).
	     * @param w output double[] of dimension n. If info = 0, the eigenvalues are in ascending order.
	     * @param work (workspace/output) double[] of dimension max(1,lwork). On exit, if info[0] = 0, then work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The length of the array work. lwork >= max(1,3*n-1). For optimal efficiency , lwork >=
	     *            (nb+2)*n, where nb is the blocksize for dsytrd returned by ilaenv.
	     * 
	     *            <p>
	     *            If lwork = -1, then a workspace query is assumed; the routine only calculates the optimal size of the
	     *            work array, returns this value as the first entry of the work array, and no error message related to
	     *            lwork is issued.
	     *            </p>
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value. > 0:
	     *            If info[0] = i, the algorithm failed to converge; i off-diagonal elements of an intermediate
	     *            tridiagonal form did not converge to zero.
	     */
	    private void dsyev(final char jobz, final char uplo, final int n, final double[][] A, final int lda,
	            final double[] w, final double[] work, final int lwork, final int[] info) {
	        boolean lower;
	        boolean lquery;
	        boolean wantz;
	        final int[] iinfo = new int[1];
	        int imax;
	        int inde;
	        int indtau;
	        int indwrk;
	        int iscale;
	        int llwork;
	        int lwkopt = 1;
	        int nb;
	        double anrm;
	        double bignum;
	        double eps;
	        double rmax;
	        double rmin;
	        double safmin;
	        double sigma = 1.0;
	        double smlnum;
	        final char[] ch = new char[1];
	        String opts;
	        double[] vector1;
	        double[] vector2;
	        double[] vector3;

	        // Test the input parameters.
	        if ( (jobz == 'V') || (jobz == 'v')) {
	            wantz = true;
	        } else {
	            wantz = false;
	        }

	        if ( (uplo == 'L') || (uplo == 'l')) {
	            lower = true;
	        } else {
	            lower = false;
	        }

	        if (lwork == -1) {
	            lquery = true;
	        } else {
	            lquery = false;
	        }

	        info[0] = 0;

	        if ( ( !wantz) && (jobz != 'N') && (jobz != 'n')) {
	            info[0] = -1;
	        } else if ( ( !lower) && (uplo != 'U') && (uplo != 'u')) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -5;
	        }

	        if (info[0] == 0) {
	            ch[0] = uplo;
	            opts = new String(ch);
	            nb = ilaenv(1, "DSYTRD", opts, n, -1, -1, -1);
	            lwkopt = Math.max(1, (nb + 2) * n);
	            work[0] = lwkopt;

	            if ( (lwork < Math.max(1, (3 * n) - 1)) && ( !lquery)) {
	                info[0] = -8;
	            }
	        } // if (info[0] == 0)

	        if (info[0] != 0) {
	            System.err.println("Error dsyev had info = " + info[0]);

	            return;
	        } // if (info[0] != 0)
	        else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if (n == 1) {
	            w[0] = A[0][0];
	            work[0] = 2;

	            if (wantz) {
	                A[0][0] = 1.0;
	            }

	            return;
	        } // if (n == 1)

	        // Get machine constants

	        safmin = dlamch('S');
	        eps = dlamch('P');
	        smlnum = safmin / eps;
	        bignum = 1.0 / smlnum;
	        rmin = Math.sqrt(smlnum);
	        rmax = Math.sqrt(bignum);

	        // Scale matrix to allowable range, if necessary

	        anrm = dlansy('M', uplo, n, A, lda, work);
	        iscale = 0;

	        if ( (anrm > 0.0) && (anrm < rmin)) {
	            iscale = 1;
	            sigma = rmin / anrm;
	        } // if ((anrm > 0.0) && (anrm < rmin))
	        else if (anrm > rmax) {
	            iscale = 1;
	            sigma = rmax / anrm;
	        } // else if (anrm > rmax)

	        if (iscale == 1) {
	            dlascl(uplo, 0, 0, 1.0, sigma, n, n, A, lda, info);

	            if (info[0] != 0) {
	                System.out.println("dsyev call to dlascl had info[0] = " + info[0] + "\n");
	            }
	        }

	        // Call dsytrd to reduce symmetric matrix to tridiagonal form
	        inde = 1;
	        indtau = inde + n;
	        indwrk = indtau + n;
	        llwork = lwork - indwrk + 1;
	        vector1 = new double[n - 1];
	        vector2 = new double[n - 1];
	        vector3 = new double[llwork];

	        dsytrd(uplo, n, A, lda, w, vector1, vector2, vector3, llwork, iinfo);

	        if (iinfo[0] != 0) {
	            System.out.println("dsyev call to dsytrd had iinfo[0] = " + iinfo[0] + "\n");
	        }

	        // For eigenvalues only, call dsterf. For eigenvectors, first call dorgtr
	        // to generate the orthogonal matrix, then call dsteqr.

	        if ( !wantz) {
	            dsterf(n, w, vector1, info);

	            if (info[0] != 0) {
	                System.out.println("dsyev call to dsterf had info[0] = " + info[0] + "\n");
	            }
	        } else {
	            dorgtr(uplo, n, A, lda, vector2, vector3, llwork, iinfo);

	            if (iinfo[0] != 0) {
	                System.out.println("dsyev call to dorgtr had iinfo[0] = " + iinfo[0] + "\n");
	            }

	            vector2 = new double[Math.max(1, (2 * n) - 2)];
	            dsteqr(jobz, n, w, vector1, A, lda, vector2, info);

	            if (info[0] != 0) {
	                System.out.println("dsyev call to dsteqr had info[0] = " + info[0] + "\n");
	            }
	        }

	        // If matrix was scaled, then rescale eigenvalues appropriately.
	        if (iscale == 1) {

	            if (info[0] == 0) {
	                imax = n;
	            } else {
	                imax = info[0] - 1;
	            }

	            dscal(imax, 1.0 / sigma, w, 1);
	        } // if (iscale == 1)

	        // Set work[0] to optimal workspace size.
	        work[0] = lwkopt;

	        return;
	    } // dsyev
	    
	   



	    /**
	     * DYSGV is ported from the version 3.1 LAPACK driver routine Original DSYGV created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 DSYGV computes all the eigenvalues, and optionally, the
	     * eigenvectors of a real generalized symmetric-definite eigenproblem, of the form A*x = (lambda)*B*x, A*Bx =
	     * (lambda)*x, or B*A*x = (lambda)*x. Here A and B are assumed to be symmetric and B is also positive definite
	     * 
	     * @param itype input integer specifies the problem type to be solved: = 1: A*x = (lambda)*B*x = 2: A*B*x =
	     *            (lambda)*x ' = 3: B*A*x = (lambda)*x
	     * @param jobz input char = 'N': Compute eigenvalues only = 'V': Compute eigenvalues and eigenvectors
	     * @param uplo input char = 'U': Upper triangles of A and B are stored = 'L': Lower triangles of A and B are stored
	     * @param n input integer The order of matrices A and B. n >= 0.
	     * @param A (input/output) double[][], dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
	     *            leading n by n upper triangular part of A contains the upper triangular part of the matrix A. If uplo
	     *            = 'L', the leading n by n lower triangular part of A contains the lower triangular part of the matrix
	     *            A.
	     * 
	     *            <p>
	     *            On exit, if jobz = 'V', then if info[0] = 0, A contains the matrix Z of eigenvectors. The eigenvectors
	     *            are normalized as follows: If itype = 1 or 2, Z**T*B*Z = I; If itype = 3, Z**T*inv(B)*Z = I. If jobz =
	     *            'N', then on exit the upper triangle (if uplo = 'U') or the lower triangle (if uplo = 'L') of A,
	     *            including the diagonal, is destroyed.
	     *            </p>
	     * @param lda input integer The leading dimension of array A. lda >= max(1,n).
	     * @param B (input/output) double[][], dimension ldb by n On entry, the symmetric positive definite matrix B. If
	     *            uplo = 'U', the leading n by n upper triangular part of B contains the upper triangular part of the
	     *            matrix B. If uplo = 'L', the leading n by n lower triangular part of B contains the lower triangular
	     *            part of the matrix B.
	     * 
	     *            <p>
	     *            On exit, if info <= n, the part of B containing the matrix is overwritten by the triangular factor U
	     *            or L from the Cholesky factorization B = U**T*U or B = L*L**T.
	     *            </p>
	     * @param ldb input integer The leading dimension of the array B. ldb >= max(1,n).
	     * @param w output double[] of dimension n If info = 0, the eigenvalues in ascending order.
	     * @param work (workspace/output) double[] of dimension max(1,lwork) On exit, if info = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input integer The length of the array work. lwork >= max(1,3*n-1). For optimal efficiency, lwork >=
	     *            (nb+2)*n, where nb is the blocksize for dsytrd returned by ilaenv.
	     * 
	     *            <p>
	     *            If lwork = -1, then a workspace query is assumed; the routine only calculates the optimal size of the
	     *            work array, returns this value as the first entry of the work array, and no error message related to
	     *            lwork is issued.
	     *            </p>
	     * @param info output integer[] = 0: successful exit < 0: if info = -i, the i-th argument had an illegal value > 0:
	     *            dpotrf or dsyev returned an error code: <= n: If info = i, dsyev failed to converge; i off-diagonal
	     *            elements of an intermediate tridiagonal form did not converge to zero; > n: If info = n + i, for 1 <=
	     *            i <= n, then the leading minor of order i of B is not positive definite. The factorization of B could
	     *            not be completed and no eigenvalues or eigenvectors were computed.
	     */
	    private void dsygv(final int itype, final char jobz, final char uplo, final int n, final double[][] A,
	            final int lda, final double[][] B, final int ldb, final double[] w, final double[] work, final int lwork,
	            final int[] info) {
	        boolean wantz;
	        boolean upper;
	        boolean lquery;
	        int nb;
	        String name;
	        final char[] optsChar = new char[1];
	        String opts;
	        int lwkopt = 0;
	        int neig;
	        char trans;
	        int lwkmin;

	        // Test the input statements
	        if ( (jobz == 'V') || (jobz == 'v')) {
	            wantz = true;
	        } else {
	            wantz = false;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if (lwork == -1) {
	            lquery = true;
	        } else {
	            lquery = false;
	        }

	        info[0] = 0;

	        if ( (itype < 1) || (itype > 3)) {
	            info[0] = -1;
	        } else if ( ! ( (wantz) || (jobz == 'N') || (jobz == 'n'))) {
	            info[0] = -2;
	        } else if ( ! ( (upper) || (uplo == 'L') || (uplo == 'l'))) {
	            info[0] = -3;
	        } else if (n < 0) {
	            info[0] = -4;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -6;
	        } else if (ldb < Math.max(1, n)) {
	            info[0] = -8;
	        }

	        if (info[0] == 0) {
	            lwkmin = Math.max(1, 3 * n - 1);
	            name = new String("DSYTRD");
	            optsChar[0] = uplo;
	            opts = new String(optsChar);
	            nb = ilaenv(1, name, opts, n, -1, -1, -1);
	            lwkopt = Math.max(lwkmin, (nb + 2) * n);
	            work[0] = lwkopt;
	            if ( (lwork < lwkmin) && ( !lquery)) {
	                info[0] = -11;
	            }
	        }

	        if (info[0] != 0) {
	            System.err.println("dsygv had info = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        // Form a Cholesky factorization of B
	        dpotrf(uplo, n, B, ldb, info);

	        if (info[0] != 0) {
	            System.out.println("Call to dpotrf in dsygv returned info[0] = " + info[0] + "\n");
	            info[0] = n + info[0];

	            return;
	        }

	        // Transform problem to standard eigenvalue problem and solve
	        dsygst(itype, uplo, n, A, lda, B, ldb, info);

	        if (info[0] != 0) {
	            System.out.println("call to dsygst in dsygv returned info[0] = " + info[0] + "\n");
	        }

	        dsyev(jobz, uplo, n, A, lda, w, work, lwork, info);

	        if (info[0] != 0) {
	            System.out.println("Call to dsyev in dsygv returned info[0] = " + info[0] + "\n");
	        }

	        if (wantz) {

	            // Backtransform eigenvectors to the original problem.

	            neig = n;

	            if (info[0] > 0) {
	                neig = info[0] - 1;
	            } // if (info[0] > 0)

	            if ( (itype == 1) || (itype == 2)) {

	                // For A*x = (lambda)*B*x and A*B*x = (lambda)*x
	                // backtransform eigenvectors: x = (inv(L))'*y or inv(U)*y

	                if (upper) {
	                    trans = 'N';
	                } // if (upper)
	                else {
	                    trans = 'T';
	                }

	                dtrsm('L', uplo, trans, 'N', n, neig, 1.0, B, ldb, A, lda);
	            } // if ((itype == 1) || (itype == 2))
	            else if (itype == 3) {

	                // For B*A*x = (lambda)*x
	                // backtransform eigenvectors: x = L*y or U'*y

	                if (upper) {
	                    trans = 'T';
	                } // if (upper)
	                else {
	                    trans = 'N';
	                }

	                dtrmm('L', uplo, trans, 'N', n, neig, 1.0, B, ldb, A, lda);
	            } // else if (itype == 3)
	        } // if (wantz)

	        work[0] = lwkopt;

	        return;
	    } // dsygv

	    /**
	     * This routine is an extraction from the FORTRAN program version 3.1.1 DCHKEE of the code needed to drive ddrvsg in
	     * order to test DSYGV, that handles the symmetric generalized eigenvalue problem. Numerical values were obtained
	     * from the dsg.in datafile. Original DCHKEE created by Univ. of Tennessee, Univ. of California Berkeley, and NAG
	     * Ltd., January, 2007
	     */
	    private void dsygv_test() {

	        // Number of values of n
	        final int nn = 7;

	        // Values of matrix dimension n
	        final int[] nval = new int[] {0, 1, 2, 3, 5, 10, 16};

	        // Number of values of NB, NBMIN, and NX
	        final int nparms = 3;

	        // Values of blocksize NB
	        final int[] nbval = new int[] {1, 3, 20};

	        // Values of minimum blocksize NBMIN
	        final int[] nbmin = new int[] {2, 2, 2};

	        // Values of crossover point NX
	        final int[] nxval = new int[] {1, 1, 1};

	        // Threshold value for the test ratios. Information will be printed
	        // about each test for which the test ratio is greater than or equal
	        // to threshold.
	        final double thresh = 20.0;

	        // Test the LAPACK routines
	        final boolean tstchk = true;

	        // Code describing how to set the random number seed.
	        // = 0: Set the seed to a default number before each run.
	        // = 1: Initialize the seed to a default value only before the first
	        // run.
	        // = 2: Like 1, but use the seed values in the 4 integer array
	        // ioldsd
	        int newsd = 1;
	        final int maxt = 30;
	        final boolean[] dotype = new boolean[maxt];
	        final int[] ioldsd = new int[] {0, 0, 0, 1};
	        final int[] iseed = new int[] {0, 0, 0, 1};
	        final int nmax = 132;
	        final int lwork = (nmax * ( (5 * nmax) + 5)) + 1;
	        final int liwork = nmax * ( (5 * nmax) + 20);
	        final int[] iwork = new int[liwork];
	        final double[] work = new double[lwork];
	        final double[] result = new double[500];
	        final int[] info = new int[1];
	        double[][] A;
	        double[][] B;
	        double[] D;
	        double[][] Z;
	        double[][] AB;
	        double[][] BB;
	        double[] AP;
	        double[] BP;

	        final int maxtyp = 21;
	        int i;
	        int k;
	        int maxnval;
	        System.out.println("Tests of the Symmetric Eigenvalue Problem routines\n");

	        for (i = 0; i < maxtyp; i++) {
	            dotype[i] = true;
	        }

	        maxnval = 0;

	        for (i = 0; i < nn; i++) {

	            if (nval[i] > maxnval) {
	                maxnval = nval[i];
	            }
	        }

	        iparms = new int[100];

	        // 9 = maximum size of the subproblems at the bottom of the computation
	        // tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd)
	        iparms[9 - 1] = 25;
	        A = new double[nmax][maxnval];
	        B = new double[nmax][maxnval];
	        D = new double[maxnval];
	        Z = new double[nmax][maxnval];
	        AB = new double[nmax][maxnval];
	        BB = new double[nmax][maxnval];
	        AP = new double[maxnval * maxnval];
	        BP = new double[maxnval * maxnval];

	        for (i = 1; i <= nparms; i++) {

	            // 1 = The optimal blocksize; if this value is 1, an unblocked
	            // algorithm will give the best performance
	            iparms[1 - 1] = nbval[i - 1];

	            // 2 = The minimum blocksize for which the block routine should be
	            // used; if the usable block size is less than this value, an
	            // unblocked routine should be used.
	            iparms[2 - 1] = nbmin[i - 1];

	            // 3 = The crossover point (in a block routine, for n less than this
	            // value, an unblocked routine should be used).
	            iparms[3 - 1] = nxval[i - 1];

	            if (newsd == 0) {

	                for (k = 0; k < 4; k++) {
	                    iseed[k] = ioldsd[k];
	                }
	            } // if (newsd == 0)

	            System.out.println("Optimal blocksize = " + nbval[i - 1] + "\n");
	            System.out.println("Minimum blocksize = " + nbmin[i - 1] + "\n");
	            System.out.println("Crossover point = " + nxval[i - 1] + "\n");

	            if (tstchk) {
	                ddrvsg(nn, nval, maxtyp, dotype, iseed, thresh, A, nmax, B, nmax, D, Z, nmax, AB, BB, AP, BP, work,
	                        lwork, iwork, liwork, result, info);

	                if (info[0] != 0) {
	                    System.err.println("ddrvsg had info = " + info[0]);
	                }
	            } // if (tstchk)
	        } // for (i = 1; i <= nparms; i++)
	    } // dsygv_test

	    /**
	     * DOCUMENT ME!
	     */
	    private void dsygv_test2() {
//	        this.UI = ViewUserInterface.getReference();

	        final int itype = 1;
	        final char jobz = 'V';
	        final char uplo = 'U';
	        final int n = 4;
	        final double[][] A = new double[4][4];
	        A[0][0] = 0.24;
	        A[0][1] = 0.39;
	        A[0][2] = 0.42;
	        A[0][3] = -0.16;
	        A[1][0] = 0.39;
	        A[1][1] = -0.11;
	        A[1][2] = 0.79;
	        A[1][3] = 0.63;
	        A[2][0] = 0.42;
	        A[2][1] = 0.79;
	        A[2][2] = -0.25;
	        A[2][3] = 0.48;
	        A[3][0] = -0.16;
	        A[3][1] = 0.63;
	        A[3][2] = 0.48;
	        A[3][3] = -0.03;

	        final int lda = 4;
	        final double[][] B = new double[4][4];
	        B[0][0] = 4.16;
	        B[0][1] = -3.12;
	        B[0][2] = 0.56;
	        B[0][3] = -0.10;
	        B[1][0] = -3.12;
	        B[1][1] = 5.03;
	        B[1][2] = -0.83;
	        B[1][3] = 1.09;
	        B[2][0] = 0.56;
	        B[2][1] = -0.83;
	        B[2][2] = 0.76;
	        B[2][3] = 0.34;
	        B[3][0] = -0.10;
	        B[3][1] = 1.09;
	        B[3][2] = 0.34;
	        B[3][3] = 1.18;

	        final int ldb = 4;
	        final double[] w = new double[4];
	        final double[] work = new double[100];
	        final int lwork = 100;
	        final int[] info = new int[1];
	        dsygv(itype, jobz, uplo, n, A, lda, B, ldb, w, work, lwork, info);

	        if (info[0] != 0) {
	            System.out.println("dsygv had info[0] = " + info[0] + "\n");

	            return;
	        }

	        System.out.println("Eigenvalues in ascending order are:\n");
	        System.out.println(w[0] + "  " + w[1] + "  " + w[2] + "  " + w[3] + "\n");
	        System.out.println("Eigenvector 0:\n");
	        System.out.println(A[0][0] + "\n");
	        System.out.println(A[1][0] + "\n");
	        System.out.println(A[2][0] + "\n");
	        System.out.println(A[3][0] + "\n");
	        System.out.println("Eigenvector 1:\n");
	        System.out.println(A[0][1] + "\n");
	        System.out.println(A[1][1] + "\n");
	        System.out.println(A[2][1] + "\n");
	        System.out.println(A[3][1] + "\n");
	        System.out.println("Eigenvector 2:\n");
	        System.out.println(A[0][2] + "\n");
	        System.out.println(A[1][2] + "\n");
	        System.out.println(A[2][2] + "\n");
	        System.out.println(A[3][2] + "\n");
	        System.out.println("Eigenvector 3:\n");
	        System.out.println(A[0][3] + "\n");
	        System.out.println(A[1][3] + "\n");
	        System.out.println(A[2][3] + "\n");
	        System.out.println(A[3][3] + "\n");

	        return;
	    }

	    /**
	     * DOCUMENT ME!
	     * 
	     * @param UI DOCUMENT ME!
	     */
	    private void dsygv_test3() {	//final ViewUserInterface UI
//	        this.UI = UI;

	        final int itype = 1;
	        final char jobz = 'V';
	        final char uplo = 'L';
	        final int n = 2;
	        final double[][] A = new double[2][2];
	        A[0][0] = 0.24;
	        A[0][1] = 0.39;
	        A[1][0] = 0.39;
	        A[1][1] = -0.11;

	        final int lda = 2;
	        final double[][] B = new double[2][2];
	        B[0][0] = 4.16;
	        B[0][1] = -3.12;
	        B[1][0] = -3.12;
	        B[1][1] = 5.03;

	        final int ldb = 2;
	        final double[] w = new double[2];
	        final double[] work = new double[100];
	        final int lwork = 100;
	        final int[] info = new int[1];
	        dsygv(itype, jobz, uplo, n, A, lda, B, ldb, w, work, lwork, info);

	        if (info[0] != 0) {
	            System.out.println("dsygv had info[0] = " + info[0] + "\n");

	            return;
	        }

	        System.out.println("Eigenvalues in ascending order are:\n");
	        System.out.println(w[0] + "  " + w[1] + "\n");
	        System.out.println("Eigenvector 0:\n");
	        System.out.println(A[0][0] + "\n");
	        System.out.println(A[1][0] + "\n");
	        System.out.println("Eigenvector 1:\n");
	        System.out.println(A[0][1] + "\n");
	        System.out.println(A[1][1] + "\n");

	        return;
	    }

	    /**
	     * Port of 12/3/93 linpack routine daxpy Original version written by Jack Dongarra vector dy = vector dy + da *
	     * vector dx.
	     * 
	     * @param n input int
	     * @param da inut double
	     * @param dx input double[]
	     * @param incx input int
	     * @param dy input/output double[]
	     * @param incy input int
	     */
	    private void daxpy(final int n, final double da, final double[] dx, final int incx, final double[] dy,
	            final int incy) {
	        int i;
	        int ix;
	        int iy;
	        int m;
	        int mp1;

	        if (n <= 0) {
	            return;
	        }

	        if (da == 0.0) {
	            return;
	        }

	        if ( (incx != 1) || (incy != 1)) {

	            // Code for unequal increments or equal increments not equal to 1
	            ix = 1;
	            iy = 1;

	            if (incx < 0) {
	                ix = ( ( -n + 1) * incx) + 1;
	            }

	            if (incy < 0) {
	                iy = ( ( -n + 1) * incy) + 1;
	            }

	            for (i = 1; i <= n; i++) {
	                dy[iy - 1] = dy[iy - 1] + (da * dx[ix - 1]);
	                ix = ix + incx;
	                iy = iy + incy;
	            }

	            return;
	        } // if ((incx != 1) || (incy != 1))

	        // Code for both increments equal to 1
	        m = n % 4;

	        if (m != 0) {

	            for (i = 0; i < m; i++) {
	                dy[i] = dy[i] + (da * dx[i]);
	            }

	            if (n < 4) {
	                return;
	            }
	        } // if (m != 0)

	        mp1 = m + 1;

	        for (i = mp1; i <= n; i += 4) {
	            dy[i - 1] = dy[i - 1] + (da * dx[i - 1]);
	            dy[i] = dy[i] + (da * dx[i]);
	            dy[i + 1] = dy[i + 1] + (da * dx[i + 1]);
	            dy[i + 2] = dy[i + 2] + (da * dx[i + 2]);
	        }

	        return;
	    } // daxpy

	    /**
	     * This is a port of version 3.1 LAPACK test routine DCHKGG Original DCHKGG created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dchkgg checks the nonsymmetric generalized eigenvalue problem
	     * routines.
	     * 
	     * <p>
	     * dgghrd factors A and B as U H Vtranspose and U T Vtranspose, where H is hessenberg, T is triangular, and U and V
	     * are orthogonal.
	     * </p>
	     * 
	     * <p>
	     * dhgeqz factors H and T as Q S Ztranspose and Q P Ztranspose, where P is upper triangular, S is in generalized
	     * Schur form (block upper triangular, with 1x1 and 2x2 blocks on the diagonal, the 2x2 blocks corresponding to
	     * complex conjugate pairs of generalized eigenvalues), and Q and Z are orthogonal. It also computes the generalized
	     * eigenvalues (alpha[0], beta[0]),...,(alpha[n-1], beta[n-1]), where alpha[j] = S[j][j] and beta[j] = P[j][j] --
	     * thus, w[j] = alpha[j]/beta[j] is a root of the generalized eigenvalue problem det(A - w[j] B ) = 0 and m[j] =
	     * beta[j]/alpha[j] is a root of the essentially equivalent problem det(m[j] A - B ) = 0
	     * </p>
	     * 
	     * <p>
	     * dtgevc computes the matrix L of left eigenvectors and the matrix R of right eigenvectors for the matrix pair (S,
	     * P). In the description below, L and R are left and right eigenvectors corresponding to the generalized
	     * eigenvalues (alpha, beta).
	     * </p>
	     * 
	     * <p>
	     * When dchkgg is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For each
	     * size ("n") and each type of matrix, one matrix will be generated and used to test the nonsymmetric eigenroutines.
	     * For each matrix, 15 tests will be performed. The first twelve "test ratios" should be small -- O(1). They will be
	     * compared with the threshold thresh: (1) | A - U H Vtrans| / ( |A| n ulp) (2) | B - U T Vtrans| / ( |B| n ulp) (3)
	     * | I - UUtrans| / (n ulp) (4) | I - VVtrans| / (n ulp) (5) | H - Q S Ztrans| / ( |H| n ulp) (6) | T - Q P Ztrans|
	     * / ( |T| n ulp) (7) | I - QQtrans| / (n ulp) (8) | I - ZZtrans| / (n ulp) (9) max over all left eigenvalue/-vector
	     * pairs (beta/alpha, L) of | L**H * (beta S - alpha P) | / (ulp max( |beta S|, |alpha P| )) (10) max over all left
	     * eigenvalue/-vector pairs (beta/alpha, L') of | L'**H * (beta H - alphatranspose T) | / (ulp max( |beta H|, |alpha
	     * T| )) where the eigenvectors L' are the result of passing Q to dtgevc and back transforming (howmny = 'B'). (11)
	     * max over all right eigenvalue/-vector pairs (beta/alpha, R) of | (beta S - alpha T) R | / (ulp max( |beta S|,
	     * |alpha T| )) (12) max over all right eigenvalue/-vector pairs (beta/alpha, R') of | (beta H - alpha T) R' | / (
	     * ulp max( |beta H|, |alpha T| )) where the eigenvectors R' are the result of passing Z to dtgevc and back
	     * transforming (howmny = 'B'). The last three test ratios will usually be small, but there is no mathematical
	     * requirement that they be so. They are therefore compared with thresh only if tstdif is true. (13) | S(Q,Z
	     * computed) - S(Q,Z not computed) | / ( |S| ulp ) (14) | P(Q,Z computed) - P(Q,Z not computed) | / ( |P| ulp ) (15)
	     * max( |alpha(Q,Z computed) - alpha(Q,Z not computed)|/|S|, |beta(Q,Z computed) - beta(Q,Z not computed)|/|P| ) /
	     * ulp In addition, the normalization of L and R are checked, and compared with the threshold thrshn.
	     * </p>
	     * 
	     * <p>
	     * Test Matrices The sizes of the test matrices are specified by an array nn[0:sizes-1]; the value of each element
	     * nn[j] specifies one size. The "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j] is true,
	     * then a matrix type "j" will be generated. Currently, the list of possible types is: (1) (0, 0) (a pair of zero
	     * matrices) (2) (I, 0) (an identity and a zero matrix) (3) (0, I) (a zero and an identity matrix) (4) (I, I) (a
	     * pair of identity matrices) (5) (Jtranspose, Jtranspose) (a pair of transposed Jordan blocks) (6) (X, Y) where X =
	     * (Jtranspose 0) and Y = (I 0 ) (0 I) (0 Jtranspose) and I is a k by k identity and J a (k+1) by (k+1) Jordan
	     * block; k = (N-1)/2 (7) (D, I) where D is diag(0, 1,..., N-1) (a diagonal matrix with those diagonal entries.) (8)
	     * (I, D) (9) (big*D, small*I) where "big" is near overflow and small = 1/big (10) (small*D, big*I) (11) (big*I,
	     * small*D) (12) (small*I, big*D) (13) (big*D, big*I) (14) (small*D, small*I) (15) (D1, D2) where D1 is diag(0, 0,
	     * 1, ..., N-3, 0) and D2 is diag(0, N-3, N-4,..., 1, 0, 0) (16) U (Jtranspose, Jtranspose) V where U and V are
	     * random orthogonal matrices. (17) U (T1, T2) V where T1 and T2 are upper triangular matrices with random O(1)
	     * entries above the diagonal and diagonal entries diag(T1) = (0, 0, 1, ..., N-3, 0) and diag(T2) = (0, N-3, N-4,
	     * ..., 1, 0, 0) (18) U (T1, T2) V diag(T1) = (0, 0, 1, 1, s, ..., s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0) s =
	     * machine precision (19) U (T1, T2) V diag(T1) = (0,0,1,1, 1-d, ..., 1 - (N-5)*d=s, 0) diag(T2) = (0, 1, 0, 1, ...,
	     * 1, 0) (20) U (T1, T2) V diag(T1) = (0,0,1,1,a, ..., a**(N-5)=s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0) (21) U
	     * (T1, T2) V diag(T1) = (0, 0, 1, r1, r2, ..., r(N-4), 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0) where r1, ...,
	     * r(N-4) are random. (22) U (big*T1, small*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0)
	     * (23) U (small*T1, big*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0) (24) U (small*T1,
	     * small*T2) V diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0) (25) U (big*T1, big*T2) V diag(T1)
	     * = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0) (26) U(T1, T2) V where T1 and T2 are random
	     * upper-triangular matrices.
	     * </p>
	     * 
	     * @param nsizes input int The number of sizes of matrices to use. If it is zero, dchkgg does nothing. It must be at
	     *            least zero.
	     * @param nn input int[] of dimension (nsizes) An array containing the sizes to be used for matrices. Zero values
	     *            will be skipped. The values must be at least zero.
	     * @param ntypes input int The number of elements in dotype. If it is zero, dchkgg does nothing. It must be at least
	     *            zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined, which is to use
	     *            whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and dotype[maxtyp] is
	     *            true.
	     * @param dotype input boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix of
	     *            that size and of type j will be generated. If ntypes is smaller than the maximum number of types
	     *            defined(parameter maxtyp), then types ntypes+1 through maxtyp will not be generated. If ntypes is
	     *            larger than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
	     * @param iseed (input/ouptut) int[] of dimension (4) On entry iseed specifies the seed of the random number
	     *            generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
	     *            Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence limited to
	     *            small integers, and so should produce machine independent random numbers. The values of iseed are
	     *            changed on exit, and can be used in the next call to dchkgg to continue the same random number
	     *            sequence.
	     * @param thresh input double A test will count as "failed" if the "error", computed as described above, exceeds
	     *            thresh. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple of
	     *            1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double) or the
	     *            size of the matrix. It must be at least zero.
	     * @param tstdif input boolean Specifies whether the ratios 13-15 will be computed and compared with thresh. =
	     *            false: Only test ratios 1-12 will be computed and tested. Ratios 13-15 will be set to zero. = true:
	     *            All the test ratios 1-15 will be computed and tested.
	     * @param thrshn input double Threshold for reporting eigenvector normalization error. If the normalization of any
	     *            eigenvector differs from one by nore than thrshn*ulp, then a special error message will be printed.
	     *            (This is handled separately from the other tests, since only a compiler or programming error should
	     *            cause an error message, at least if thrshn is at least 5--10.)
	     * @param A (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original A matrix. Used as
	     *            input only if ntypes = maxtyp+1, dotype[0:maxtyp-1] = false, and dotype[maxtyp] = true.
	     * @param lda input int The leaeding dimension of A, B, H, T, S1, P1, S2, and P2. It must be at least 1 and at least
	     *            max(nn).
	     * @param B (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original B matrix. Used as
	     *            input only if ntypes= maxtyp+1, dotype[0:maxtyp-1] = false, and dotype[maxtyp] = true.
	     * @param H (workspace) double[][] of dimension (lda, max(nn)) The upper Hessenberg matrix computed from A by
	     *            dgghrd.
	     * @param T (workspace) double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from B by
	     *            dgghrd.
	     * @param S1 (workspace) double[][] of dimension (lda, max(nn)) The Schur (block upper triangular) matrix computed
	     *            from H by dhgeqz when Q and Z are also computed.
	     * @param S2 (workspace) double[][] of dimension (lda, max(nn)) The Schur (block upper triangular) matrix computed
	     *            from H by dhgeqz when Q and Z are not computed.
	     * @param P1 (workspace) double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from T by
	     *            dhgeqz when Q and Z are also computed.
	     * @param P2 (workspace) double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from T by
	     *            dhgeqz when Q and Z are not computed.
	     * @param U (workspace) double[][] of dimension (ldu, max(nn)) The (left) orthogonal matrix computed by dgghrd.
	     * @param ldu input int The leading dimension of U, V, Q, Z, evectl, and evectr. It must be at least 1 and at least
	     *            max(nn).
	     * @param V (workspace) double[][] of dimension (ldu, max(nn)) The (right) orthogonal matrix computed by dgghrd.
	     * @param Q (workspace) double[][] of dimesnion (ldu, max(nn)) The (left) orthogonal matrix computed by dhgeqz.
	     * @param Z (workspace) double[][] of dimension (ldu, max(nn)) The (left) orthogonal matrix computed by dhgeqz.
	     * @param alphr1 (workspace) double[] of dimension (max(nn))
	     * @param alphi1 (workspace) double[] of dimension (max(nn))
	     * @param beta1 (workspace) double[] of dimension (max(nn)) The generalized eigenvalues of (A,B) computed by dhgeqz
	     *            when Q, Z, and the full Schur matrices are computed. On exit, (alphr1[k] + alphi1[k]*i) /beta1[k] is
	     *            the (k+1)-st generalized eigenvalue of the matrices in A and B.
	     * @param alphr3 (workspace) double[] of dimension (max(nn))
	     * @param alphi3 (workspace) double[] of dimension (max(nn))
	     * @param beta3 (workspace) double[] of dimension (max(nn))
	     * @param evectl (workspace) double[][] of dimension (ldu, max(nn)) The (block lower triangular) left eigenvector
	     *            matrix for the matrices in S1 and P1. (See dtgevc for the format.)
	     * @param evectr (workspace) double[][] of dimesnion (ldu, max(nn)) The (block upper triangular) right eigenvector
	     *            matrix for the matrices in S1 and P1. (See dtgevc for the format.)
	     * @param work (workspace) double[] of dimension (lwork)
	     * @param lwork input int The number of entries in work. This must be at least max(2*n**2, 6*n, 1), for all n =
	     *            nn[j].
	     * @param llwork (workspace) boolean[] of dimension max(nn))
	     * @param result (output) double[] of dimension (15) The values computed by the tests described above. The values
	     *            are currently limited to 1/ulp, to avoid overflow.
	     * @param info (output) int[] = 0: successful exit < 0: If info[0] == -i, then i-th argument had an illegal value. >
	     *            0: A routine returned an error code. info is the absolute value of the info value returned.
	     */
	    private void dchkgg(final int nsizes, final int[] nn, final int ntypes, final boolean[] dotype, final int[] iseed,
	            final double thresh, final boolean tstdif, final double thrshn, final double[][] A, final int lda,
	            final double[][] B, final double[][] H, final double[][] T, final double[][] S1, final double[][] S2,
	            final double[][] P1, final double[][] P2, final double[][] U, final int ldu, final double[][] V,
	            final double[][] Q, final double[][] Z, final double[] alphr1, final double[] alphi1, final double[] beta1,
	            final double[] alphr3, final double[] alphi3, final double[] beta3, final double[][] evectl,
	            final double[][] evectr, final double[] work, final int lwork, final boolean[] llwork,
	            final double[] result, final int[] info) {
	        final int maxtyp = 26;
	        boolean badnn;
	        int i1;
	        int iadd;
	        final int[] iinfo = new int[1];
	        final int[] in = new int[] {1};
	        int j;
	        int jc;
	        int jr;
	        int jsize;
	        int jtype;
	        int lwkopt;
	        int mtypes;
	        int n;
	        int n1;
	        int nerrs;
	        int nmats;
	        int nmax;
	        int ntest;
	        int ntestt;
	        double anorm = 0.0;
	        double bnorm = 0.0;
	        final double[] safmax = new double[1];
	        final double[] safmin = new double[1];
	        double temp1;
	        double temp2;
	        double ulp;
	        double ulpinv;
	        final int[] iasign = new int[] {0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0};
	        final int[] ibsign = new int[] {0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	        final int[] ioldsd = new int[4];
	        final int[] kadd = new int[] {0, 0, 0, 0, 3, 2};
	        final int[] kamagn = new int[] {1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, 2, 1};
	        final int[] katype = new int[] {0, 1, 0, 1, 2, 3, 4, 1, 4, 4, 1, 1, 4, 4, 4, 2, 4, 5, 8, 7, 9, 4, 4, 4, 4, 0};
	        final int[] kazero = new int[] {1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 3, 5, 5, 5, 5, 3, 3, 3, 3, 1};
	        final int[] kbmagn = new int[] {1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 1};
	        final int[] kbtype = new int[] {0, 0, 1, 1, 2, -3, 1, 4, 1, 1, 4, 4, 1, 1, -4, 2, -4, 8, 8, 8, 8, 8, 8, 8, 8, 0};
	        final int[] kbzero = new int[] {1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 4, 1, 4, 6, 6, 6, 6, 4, 4, 4, 4, 1};
	        final int[] kclass = new int[] {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3};
	        final int[] ktrian = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
	        final int[] kz1 = new int[] {0, 1, 2, 1, 3, 3};
	        final int[] kz2 = new int[] {0, 0, 1, 2, 1, 1};
	        final double[] dumma = new double[4];
	        final double[] rmagn = new double[4];
	        final double[] alpha = new double[1];
	        double[] x;
	        final double[] tau = new double[1];
	        int i;
	        double[] work2;
	        final double[] res = new double[1];
	        final double[][] dummy = new double[1][1];
	        int row1;
	        double[][] array1;

	        // Check for errors
	        info[0] = 0;
	        badnn = false;
	        nmax = 1;

	        for (j = 0; j < nsizes; j++) {
	            nmax = Math.max(nmax, nn[j]);

	            if (nn[j] < 0) {
	                badnn = true;
	            }
	        } // for (j = 0; j < nsizes; j++)

	        // Maximum blocksize and shift -- we assume that blocksize and number
	        // of shifts are monotone and increasing functions of n.
	        lwkopt = Math.max(6 * nmax, 2 * nmax * nmax);
	        lwkopt = Math.max(lwkopt, 1);

	        // Check for errors
	        if (nsizes < 0) {
	            info[0] = -1;
	        } else if (badnn) {
	            info[0] = -2;
	        } else if (ntypes < 0) {
	            info[0] = -3;
	        } else if (thresh < 0.0) {
	            info[0] = -6;
	        } else if ( (lda <= 1) || (lda < nmax)) {
	            info[0] = -10;
	        } else if ( (ldu <= 1) || (ldu < nmax)) {
	            info[0] = -19;
	        } else if (lwkopt > lwork) {
	            info[0] = -30;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dchkgg had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (nsizes == 0) || (ntypes == 0)) {
	            return;
	        }

	        safmin[0] = dlamch('S');
	        ulp = dlamch('E') * dlamch('B');
	        safmin[0] = safmin[0] / ulp;
	        safmax[0] = 1.0 / safmin[0];
	        dlabad(safmin, safmax);
	        ulpinv = 1.0 / ulp;

	        // The values rmagn(2:3) depend on n, see below.
	        rmagn[0] = 0.0;
	        rmagn[1] = 1.0;

	        // Loop over sizes, types
	        ntestt = 0;
	        nerrs = 0;
	        nmats = 0;

	        for (jsize = 1; jsize <= nsizes; jsize++) {
	            n = nn[jsize - 1];
	            n1 = Math.max(1, n);
	            rmagn[2] = safmax[0] * ulp / n1;
	            rmagn[3] = safmin[0] * ulpinv * n1;

	            if (nsizes != 1) {
	                mtypes = Math.min(maxtyp, ntypes);
	            } else {
	                mtypes = Math.min(maxtyp + 1, ntypes);
	            }

	            for (jtype = 1; jtype <= mtypes; jtype++) {

	                if ( !dotype[jtype - 1]) {
	                    continue;
	                }

	                nmats = nmats + 1;
	                ntest = 0;

	                // Save iseed in case of error
	                for (j = 0; j < 4; j++) {
	                    ioldsd[j] = iseed[j];
	                }

	                // Initialize result
	                for (j = 0; j < 15; j++) {
	                    result[j] = 0.0;
	                }

	                // Compute A and B
	                // Description of control parameters:
	                // kclass = 1 means without rotation, = 2 means with rotation,
	                // = 3 means random.
	                // katype: the "type" to be passed to dlatm4 for computing A.
	                // kazero: the pattern of zeros on the diagonal for A:
	                // = 1: ( xxx ), = 2: (0, xxx ) = 3: (0, 0, xxx, 0 ),
	                // = 4: (0, xxx, 0, 0 ), = 5: ( 0, 0, 1, xxx, 0 ),
	                // = 6: ( 0, 1, 0, xxx, 0). (xxx means a string of
	                // non-zero entries.)
	                // kamagn: the magnitude of the matrix = 0: zero, = 1: O(1),
	                // = 2: large, = 3: small.
	                // iasign: 1 if the diagonal elements of A are to be multiplied
	                // by a random magnitude 1 number, = 2 if randomly chosen
	                // diagonal blocks are to be rotated to form 2x2 blocks.
	                // kbtype, kbzero, kbmagn, ibsign: the same, but for B.
	                // ktrian = 0: don't fill in the upper triangle, = 1: do.
	                // kz1, kz2, kadd: used to implement kazero and kbzero.
	                // rmagn: used to implement kamagn and kbmagn.

	                if (mtypes <= maxtyp) {
	                    iinfo[0] = 0;

	                    if (kclass[jtype - 1] < 3) {

	                        // Generate A without rotation
	                        if (Math.abs(katype[jtype - 1]) == 3) {
	                            in[0] = (2 * ( (n - 1) / 2)) + 1;

	                            if (in[0] != n) {
	                                dlaset('F', n, n, 0.0, 0.0, A, lda);
	                            }
	                        } // if (Math.abs(katype[jtype-1] == 3)
	                        else {
	                            in[0] = n;
	                        }

	                        dlatm4(katype[jtype - 1], in[0], kz1[kazero[jtype - 1] - 1], kz2[kazero[jtype - 1] - 1],
	                                iasign[jtype - 1], rmagn[kamagn[jtype - 1]], ulp, rmagn[ktrian[jtype - 1]
	                                        * kamagn[jtype - 1]], 2, iseed, A, lda);
	                        iadd = kadd[kazero[jtype - 1] - 1];

	                        if ( (iadd > 0) && (iadd <= n)) {
	                            A[iadd - 1][iadd - 1] = rmagn[kamagn[jtype - 1]];
	                        }

	                        // Generate B without rotation
	                        if (Math.abs(kbtype[jtype - 1]) == 3) {
	                            in[0] = (2 * ( (n - 1) / 2)) + 1;

	                            if (in[0] != n) {
	                                dlaset('F', n, n, 0.0, 0.0, B, lda);
	                            }
	                        } // if (Math.abs(kbtype[jtype-1]) == 3)
	                        else {
	                            in[0] = n;
	                        }

	                        dlatm4(kbtype[jtype - 1], in[0], kz1[kbzero[jtype - 1] - 1], kz2[kbzero[jtype - 1] - 1],
	                                ibsign[jtype - 1], rmagn[kbmagn[jtype - 1]], 1.0, rmagn[ktrian[jtype - 1]
	                                        * kbmagn[jtype - 1]], 2, iseed, B, lda);
	                        iadd = kadd[kbzero[jtype - 1] - 1];

	                        if ( (iadd != 0) && (iadd <= n)) {
	                            B[iadd - 1][iadd - 1] = rmagn[kbmagn[jtype - 1]];
	                        }

	                        if ( (kclass[jtype - 1] == 2) && (n > 0)) {

	                            // Include rotations
	                            // Generate U, V as Householder transformations times
	                            // a diagonal matrix.
	                            for (jc = 1; jc <= (n - 1); jc++) {

	                                for (jr = jc; jr <= n; jr++) {
	                                    U[jr - 1][jc - 1] = dlarnd(3, iseed);
	                                    V[jr - 1][jc - 1] = dlarnd(3, iseed);
	                                } // for (jr = jc; jr <= n; jr++)

	                                x = new double[n - jc];

	                                for (i = 0; i < (n - jc); i++) {
	                                    x[i] = U[jc + i][jc - 1];
	                                }

	                                alpha[0] = U[jc - 1][jc - 1];
	                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
	                                U[jc - 1][jc - 1] = alpha[0];

	                                for (i = 0; i < (n - jc); i++) {
	                                    U[jc + i][jc - 1] = x[i];
	                                }

	                                work[jc - 1] = tau[0];

	                                if (U[jc - 1][jc - 1] >= 0.0) {
	                                    work[ (2 * n) + jc - 1] = 1.0;
	                                } else {
	                                    work[ (2 * n) + jc - 1] = -1.0;
	                                }

	                                U[jc - 1][jc - 1] = 1.0;
	                                alpha[0] = V[jc - 1][jc - 1];

	                                for (i = 0; i < (n - jc); i++) {
	                                    x[i] = V[jc + i][jc - 1];
	                                }

	                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
	                                V[jc - 1][jc - 1] = alpha[0];

	                                for (i = 0; i < (n - jc); i++) {
	                                    V[jc + i][jc - 1] = x[i];
	                                }

	                                work[n + jc - 1] = tau[0];

	                                if (V[jc - 1][jc - 1] >= 0.0) {
	                                    work[ (3 * n) + jc - 1] = 1.0;
	                                } else {
	                                    work[ (3 * n) + jc - 1] = -1.0;
	                                }

	                                V[jc - 1][jc - 1] = 1.0;
	                            } // for (jc = 1; jc <= n-1; jc++)

	                            U[n - 1][n - 1] = 1.0;
	                            work[n - 1] = 0.0;

	                            if (dlarnd(2, iseed) >= 0.0) {
	                                work[ (3 * n) - 1] = 1.0;
	                            } else {
	                                work[ (3 * n) - 1] = -1.0;
	                            }

	                            V[n - 1][n - 1] = 1.0;
	                            work[ (2 * n) - 1] = 0.0;

	                            if (dlarnd(2, iseed) >= 0.0) {
	                                work[ (4 * n) - 1] = 1.0;
	                            } else {
	                                work[ (4 * n) - 1] = -1.0;
	                            }

	                            // Apply the diagonal matrices
	                            for (jc = 0; jc < n; jc++) {

	                                for (jr = 0; jr < n; jr++) {
	                                    A[jr][jc] = work[ (2 * n) + jr] * work[ (3 * n) + jc] * A[jr][jc];
	                                    B[jr][jc] = work[ (2 * n) + jr] * work[ (3 * n) + jc] * B[jr][jc];
	                                }
	                            }

	                            work2 = new double[n];
	                            dorm2r('L', 'N', n, n, n - 1, U, ldu, work, A, lda, work2, iinfo);

	                            if (iinfo[0] != 0) {
	                                System.out.println("First dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(iinfo[0]);

	                                return;
	                            } // if (iinfo[0] != 0)

	                            x = new double[n - 1];

	                            for (i = 0; i < (n - 1); i++) {
	                                x[i] = work[n + i];
	                            }

	                            dorm2r('R', 'T', n, n, n - 1, V, ldu, x, A, lda, work2, iinfo);

	                            if (iinfo[0] != 0) {
	                                System.out.println("Second dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(iinfo[0]);

	                                return;
	                            } // if (iinfo[0] != 0)

	                            dorm2r('L', 'N', n, n, n - 1, U, ldu, work, B, lda, work2, iinfo);

	                            if (iinfo[0] != 0) {
	                                System.out.println("Third dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(iinfo[0]);

	                                return;
	                            } // if (iinfo[0] != 0)

	                            dorm2r('R', 'T', n, n, n - 1, V, ldu, x, B, lda, work2, iinfo);

	                            if (iinfo[0] != 0) {
	                                System.out.println("Fourth dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(iinfo[0]);

	                                return;
	                            } // if (iinfo[0] != 0)
	                        } // if ((kclass[jtype-1] == 2) && (n > 0))
	                    } // if (kclass[jtype-1] < 3)
	                    else { // kclass[jtype-1] >= 3

	                        // Random matrices
	                        for (jc = 0; jc < n; jc++) {

	                            for (jr = 0; jr < n; jr++) {
	                                A[jr][jc] = rmagn[kamagn[jtype - 1]] * dlarnd(2, iseed);
	                                B[jr][jc] = rmagn[kbmagn[jtype - 1]] * dlarnd(2, iseed);
	                            }
	                        }

	                        anorm = dlange('1', n, n, A, lda, work);
	                        bnorm = dlange('1', n, n, B, lda, work);
	                    } // else kclass[jtype-1] >= 3
	                } // if (mtypes <= maxtyp)

	                // Call dgeqr2, dorm2r, and dgghrd to compute H, T, U, and V
	                dlacpy(' ', n, n, A, lda, H, lda);
	                dlacpy(' ', n, n, B, lda, T, lda);
	                ntest = 1;
	                result[0] = ulpinv;
	                work2 = new double[n];

	                loop1: {
	                    dgeqr2(n, n, T, lda, work, work2, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dgeqr2 returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dorm2r('L', 'T', n, n, n, T, lda, work, H, lda, work2, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("Fifth dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dlaset('F', n, n, 0.0, 1.0, U, ldu);
	                    dorm2r('R', 'N', n, n, n, T, lda, work, U, ldu, work2, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("Sixth dchkgg dorm2r returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dgghrd('V', 'I', n, 1, n, H, lda, T, lda, U, ldu, V, ldu, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dgghrd returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    ntest = 4;

	                    // Do tests 1--4
	                    dget51(1, n, A, lda, H, lda, U, ldu, V, ldu, work, result);
	                    dget51(1, n, B, lda, T, lda, U, ldu, V, ldu, work, res);
	                    result[1] = res[0];
	                    dget51(3, n, B, lda, T, lda, U, ldu, U, ldu, work, res);
	                    result[2] = res[0];
	                    dget51(3, n, B, lda, T, lda, V, ldu, V, ldu, work, res);
	                    result[3] = res[0];

	                    // Call dhgeqz to compute S1, P1, S2, P2, Q, and Z, do tests.
	                    // Compute T1 and UZ
	                    // Eigenvalues only
	                    dlacpy(' ', n, n, H, lda, S2, lda);
	                    dlacpy(' ', n, n, T, lda, P2, lda);
	                    ntest = 5;
	                    result[4] = ulpinv;

	                    dhgeqz('E', 'N', 'N', n, 1, n, S2, lda, P2, lda, alphr3, alphi3, beta3, Q, ldu, Z, ldu, work,
	                            lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("First dchkgg dhgeqz returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    // Eigenvalues and full Schur form
	                    dlacpy(' ', n, n, H, lda, S2, lda);
	                    dlacpy(' ', n, n, T, lda, P2, lda);

	                    dhgeqz('S', 'N', 'N', n, 1, n, S2, lda, P2, lda, alphr1, alphi1, beta1, Q, ldu, Z, ldu, work,
	                            lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("Second dchkgg dhgeqz returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    // Eigenvalues, Schur Form, and Schur Vectors
	                    dlacpy(' ', n, n, H, lda, S1, lda);
	                    dlacpy(' ', n, n, T, lda, P1, lda);
	                    dhgeqz('S', 'I', 'I', n, 1, n, S1, lda, P1, lda, alphr1, alphi1, beta1, Q, ldu, Z, ldu, work,
	                            lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("Third dchkgg dhgeqz returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    ntest = 8;

	                    // Do tests 5--8
	                    dget51(1, n, H, lda, S1, lda, Q, ldu, Z, ldu, work, res);
	                    result[4] = res[0];
	                    dget51(1, n, T, lda, P1, lda, Q, ldu, Z, ldu, work, res);
	                    result[5] = res[0];
	                    dget51(3, n, T, lda, P1, lda, Q, ldu, Q, ldu, work, res);
	                    result[6] = res[0];
	                    dget51(3, n, T, lda, P1, lda, Z, ldu, Z, ldu, work, res);
	                    result[7] = res[0];

	                    // Compute the Left and Right Eigenvectors of (S1,P1)
	                    // 9: Compute the left eigenvector matrix without
	                    // back transforming:
	                    ntest = 9;
	                    result[8] = ulpinv;

	                    // To test "select" option, compute half of the eigenvectors
	                    // in one call, and half in another
	                    i1 = n / 2;

	                    for (j = 0; j < i1; j++) {
	                        llwork[j] = true;
	                    }

	                    for (j = i1; j < n; j++) {
	                        llwork[j] = false;
	                    }

	                    dtgevc('L', 'S', llwork, n, S1, lda, P1, lda, evectl, ldu, dummy, ldu, n, in, work, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dtgevc(L,S1) returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    i1 = in[0];

	                    for (j = 0; j < i1; j++) {
	                        llwork[j] = false;
	                    }

	                    for (j = i1; j < n; j++) {
	                        llwork[j] = true;
	                    }

	                    row1 = Math.max(1, n);
	                    array1 = new double[row1][n];

	                    for (i = 0; i < row1; i++) {

	                        for (j = 0; j < (n - i1); j++) {
	                            array1[i][j] = evectl[i][j + i1];
	                        }
	                    }

	                    dtgevc('L', 'S', llwork, n, S1, lda, P1, lda, array1, row1, dummy, ldu, n, in, work, iinfo);

	                    for (i = 0; i < row1; i++) {

	                        for (j = 0; j < (n - i1); j++) {
	                            evectl[i][j + i1] = array1[i][j];
	                        }
	                    }

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dtgevc(L,S2) returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dget52(true, n, S1, lda, P1, lda, evectl, ldu, alphr1, alphi1, beta1, work, dumma);
	                    result[8] = dumma[0];

	                    if (dumma[1] > thrshn) {
	                        System.out.println("Left eigenvectors from dtgevc(howmny=S)" + " incorrectly normalized\n");
	                        System.out.println("Bits of error = " + dumma[1] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    } // if (dumma[1] > thrshn)

	                    // 10: Compute the left eigenvector matrix with
	                    // back transforming
	                    ntest = 10;
	                    result[9] = ulpinv;
	                    dlacpy('F', n, n, Q, ldu, evectl, ldu);
	                    dtgevc('L', 'B', llwork, n, S1, lda, P1, lda, evectl, ldu, dummy, ldu, n, in, work, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dtgevc(L,B) returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dget52(true, n, H, lda, T, lda, evectl, ldu, alphr1, alphi1, beta1, work, dumma);
	                    result[9] = dumma[0];

	                    if (dumma[1] > thrshn) {
	                        System.out.println("Left eigenvectors from dtgevc(howmny=B)" + " incorrectly normalized\n");
	                        System.out.println("Bits of error = " + dumma[1] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    } // if (dumma[1] > thrshn)

	                    // 11: Compute the right eigenvector matrix without
	                    // back transforming
	                    ntest = 11;
	                    result[10] = ulpinv;

	                    // To test "select" option, compute half of the eigenvectors
	                    // in one call, and half in another
	                    i1 = n / 2;

	                    for (j = 0; j < i1; j++) {
	                        llwork[j] = true;
	                    }

	                    for (j = i1; j < n; j++) {
	                        llwork[j] = false;
	                    }

	                    dtgevc('R', 'S', llwork, n, S1, lda, P1, lda, dummy, ldu, evectr, ldu, n, in, work, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dtgevc(R,S1) returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    i1 = in[0];

	                    for (j = 0; j < i1; j++) {
	                        llwork[j] = false;
	                    }

	                    for (j = i1; j < n; j++) {
	                        llwork[j] = true;
	                    }

	                    row1 = Math.max(1, n);
	                    array1 = new double[row1][n];

	                    for (i = 0; i < row1; i++) {

	                        for (j = 0; j < (n - i1); j++) {
	                            array1[i][j] = evectr[i][j + i1];
	                        }
	                    }

	                    dtgevc('R', 'S', llwork, n, S1, lda, P1, lda, dummy, ldu, array1, row1, n, in, work, iinfo);

	                    for (i = 0; i < row1; i++) {

	                        for (j = 0; j < (n - i1); j++) {
	                            evectr[i][j + i1] = array1[i][j];
	                        }
	                    }

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dtgevc(R,S2) returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dget52(false, n, S1, lda, P1, lda, evectr, ldu, alphr1, alphi1, beta1, work, dumma);
	                    result[10] = dumma[0];

	                    if (dumma[1] > thresh) {
	                        System.out.println("Right eigenvectors from dtgevc(howmny=S)" + " incorrectly normalized\n");
	                        System.out.println("Bits of error = " + dumma[1] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    } // if (dumma[1] > thresh)

	                    // 12: Compute the right eigenvector matrix with
	                    // back transforming.
	                    ntest = 12;
	                    result[11] = ulpinv;
	                    dlacpy('F', n, n, Z, ldu, evectr, ldu);
	                    dtgevc('R', 'B', llwork, n, S1, lda, P1, lda, dummy, ldu, evectr, ldu, n, in, work, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dchkgg dtgevc(R,B) returned iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        break loop1;
	                    } // if (iinfo[0] != 0)

	                    dget52(false, n, H, lda, T, lda, evectr, ldu, alphr1, alphi1, beta1, work, dumma);
	                    result[11] = dumma[0];

	                    if (dumma[1] > thresh) {
	                        System.out.println("Right eigenvectors from dtgevc(howmny=B)" + " incorrectly normalized\n");
	                        System.out.println("Bits of error = " + dumma[1] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    } // if (dumma[1] > thresh)

	                    // Tests 13--15 are done only on request
	                    if (tstdif) {

	                        // Do tests 13--14
	                        dget51(2, n, S1, lda, S2, lda, Q, ldu, Z, ldu, work, res);
	                        result[12] = res[0];
	                        dget51(2, n, P1, lda, P2, lda, Q, ldu, Z, ldu, work, res);
	                        result[13] = res[0];

	                        // Do test 15
	                        temp1 = 0.0;
	                        temp2 = 0.0;

	                        for (j = 0; j < n; j++) {
	                            temp1 = Math.max(temp1, Math.abs(alphr1[j] - alphr3[j]) + Math.abs(alphi1[j] - alphi3[j]));
	                            temp2 = Math.max(temp2, Math.abs(beta1[j] - beta3[j]));
	                        } // for (j = 0; j < n; j++)

	                        temp1 = temp1 / Math.max(safmin[0], ulp * Math.max(temp1, anorm));
	                        temp2 = temp2 / Math.max(safmin[0], ulp * Math.max(temp2, bnorm));
	                        result[14] = Math.max(temp1, temp2);
	                        ntest = 15;
	                    } // if (tstdif)
	                    else { // !tstdif
	                        result[12] = 0.0;
	                        result[13] = 0.0;
	                        result[14] = 0.0;
	                        ntest = 12;
	                    } // else !tstdif
	                } // loop1

	                // End of Loop -- Check for result[j] > thresh
	                ntestt = ntestt + ntest;

	                // Print out tests which fail.
	                for (jr = 0; jr < ntest; jr++) {

	                    if (result[jr] >= thresh) {

	                        // If this is the first test to fail,
	                        // print a header to the data file.
	                        if (nerrs == 0) {
	                            System.out.println("DGG -- Real Generalized eigenvalue problem\n");

	                            // Matrix types
	                            System.out.println("Matrix types (see dchkgg for details):\n");
	                            System.out.println("Special Matrices:\n");
	                            System.out.println("J' = transposed Jordan block\n");
	                            System.out.println("1 = (0,0)\n");
	                            System.out.println("2 = (I,0)\n");
	                            System.out.println("3 = (0,I)\n");
	                            System.out.println("4 = (I,I)\n");
	                            System.out.println("5 = (J',J')\n");
	                            System.out.println("6 = (diag(J',I), diag(I,J'))\n");
	                            System.out.println("Diagonal Matrices: D = diag(0,1,2,...)\n");
	                            System.out.println("7 = (D,I)\n");
	                            System.out.println("8 = (I,D)\n");
	                            System.out.println("9 = (large*D, small*I)\n");
	                            System.out.println("10 = (small*D, large*I)\n");
	                            System.out.println("11 = ((large*I, small*D)\n");
	                            System.out.println("12 = (small*I , large*D)\n");
	                            System.out.println("13 = (large*D, large*I)\n");
	                            System.out.println("14 = (small*D, small*I)\n");
	                            System.out.println("15 = (D, reversed D)\n");
	                            System.out.println("Matrices Rotated by Random Orthogonal Matrices U,V:\n");
	                            System.out.println("16 = transposed Jordan Blocks\n");
	                            System.out.println("17 = arithm. alpha & beta\n");
	                            System.out.println("18 = clustered alpha, beta = 0,1\n");
	                            System.out.println("19 = geometric alpha, beta = 0, 1\n");
	                            System.out.println("20 = arithmetic alpha, beta = 0, 1\n");
	                            System.out.println("21 = random alpha, beta = 0, 1\n");
	                            System.out.println("Large & Small Matrices:\n");
	                            System.out.println("22 = (large, small)\n");
	                            System.out.println("23 = (small, large)\n");
	                            System.out.println("24 = (small, small)\n");
	                            System.out.println("25 = (large, large)\n");
	                            System.out.println("26 = random O(1) matrices\n");

	                            // Tests performed
	                            System.out.println("Tests performed:\n");
	                            System.out.println("H is Hessenberg, S is Schur\n");
	                            System.out.println("B, P, T are triangular\n");
	                            System.out.println("U, V, Q, and Z are orthogonal\n");
	                            System.out.println("L is the left eigevector\n");
	                            System.out.println("R is the right eigenvector\n");
	                            System.out.println("a is alpha, b is beta\n");
	                            System.out.println(" ' means transpose\n");
	                            System.out.println(" 1 = | A - U H V' | / ( |A| n ulp )\n");
	                            System.out.println(" 2 = | B - U T V' | / ( |B| n ulp )\n");
	                            System.out.println(" 3 = | I - UU' | / ( n ulp )\n");
	                            System.out.println(" 4 = | I - VV' | / ( n ulp )\n");
	                            System.out.println(" 5 = | H - Q S Z' | / ( |H| n ulp )\n");
	                            System.out.println(" 6 = | T - Q P Z' | / ( |T| n ulp )\n");
	                            System.out.println(" 7 = | I - QQ' | / ( n ulp )\n");
	                            System.out.println(" 8 = | I - ZZ' | / ( n ulp )\n");
	                            System.out.println(" 9 = max | (b S - a P)' | / const\n");
	                            System.out.println("10 = max | (b H - a T)' | / const\n");
	                            System.out.println("11 = max | (b S - a P) R | / const\n");
	                            System.out.println("12 = max | (b H' - a T) R' | / const\n");
	                        } // if (nerrs == 0)

	                        nerrs = nerrs + 1;
	                        System.out.println("Matrix order = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        System.out.println("result[" + jr + "] = " + result[jr] + "\n");
	                    } // if (result[jr] >= thresh)
	                } // for (jr = 0; jr < ntest; jr++)
	            } // for (jtype = 1; jtype <= mtypes; jtype++)
	        } // for (jsize = 1; jsize <= nsizes; jsize++)

	        // Summary
	        if (nerrs > 0) {
	            System.out.println(nerrs + " out of " + ntestt + " dchkgg tests failed to pass the threshold\n");
	        } else {
	            System.out.println("All " + ntestt + " dchkgg tests passed the threshold\n");
	        }

	        return;

	    } // dchkgg

	    /**
	     * This is a port of the porions of LAPACK version 3.1 test routine DCHKST used to test the symmetric eigenvalue
	     * routines dsytrd, dorgtr, dsteqr, dsterf, and dsteqr. Original DCHKST created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006
	     * 
	     * <p>
	     * dsytrd factors A as U S U', where ' means transpose, S is symmetric diagonal, and U is orthogonal. dsytrd can use
	     * either just the lower or just the upper triangle of A; dchkst checks both cases. U is represented as a product of
	     * the Householder transformations, whose vectors are stored in the first n-1 columns of V, and whose scale factors
	     * are in TAU.
	     * </p>
	     * 
	     * <p>
	     * dorgtr constructs the matrix U from the contents of V and TAU.
	     * </p>
	     * 
	     * <p>
	     * dsteqr factors S as Z D1 Z', where Z is the orthogonal matrix of eigenvectors and D1 is a diagonal matrix with
	     * the eigenvalues on the diagonal. D2 is the matrix of eigenvalues computed when Z is not computed.
	     * </p>
	     * 
	     * <p>
	     * dsterf computes D3, the matrix of eigenvalues, by the PWK method, which does not yield eigenvectors
	     * </p>
	     * 
	     * <p>
	     * When dchkst is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For each
	     * size ("n") and each type of matrix, one matrix will be generated and used to test the symmetric eigenroutines.
	     * For each matrix, a number of tests will be performed: (1) | A - V S V' | / ( |A| n ulp ) dsytrd(uplo = 'U', ... )
	     * (2) | I - UV' | / ( n ulp ) dorgtr( uplo = 'U', ... ) (3) | A - V S V' | / ( |A| n ulp ) dsytrd( uplo = 'L', ...
	     * ) (4) | I - UV' | / ( n ulp ) dorgtr( uplo = 'L', ... ) (5) | S - Z D Z' | / ( |S| n ulp) dsteqr('V', ...) (6) |
	     * I - ZZ' | / ( n ulp ) dsteqr('V', ...) (7) | D1 - D2 | / ( |D1| ulp ) dsteqr('N', ...) (8) | D1 - D3 | / ( |D1|
	     * ulp ) dsterf (9) 0 if the true eigenvalues (computed by sturm count) of S are within thresh of those in D1.
	     * 2*thresh if they are not. (Tested using dstech) The "sizes" are specified by an array nn(0:nsizes-1); the value
	     * of each element nn[j] specifies one size. The "types" are specified by a boolean array dotype(0:ntypes-1); if
	     * dotype[j] is true, then the matrix type "j" will be generated. Currently, the list of possible types is: (1) The
	     * zero matrix. (2) The identity matrix. (3) A diagonal matrix with evenly spaced entries 1, ..., ulp and random
	     * signs. (ulp = (first number larger than 1) - 1 ) (4) A diagonal matrix with geomtrically spaced entries 1, ...,
	     * ulp and random signs. (5) A diagonal matrix with "clustered" entries 1, ulp, ..., ulp and random signs. (6) Same
	     * as (4), but multiplied by sqrt( overflow threshold ) (7) Same as (4), but multiplied by sqrt( underflow threshold
	     * ) (8) A matrix of the form U' D U, where U is orthogonal and D has evenly spaced entries 1, ..., ulp with random
	     * signs on the diagonal. (9) A matrix of the form U' D U, where U is orthogonal and D has geometrically spaced
	     * entries 1, ..., ulp with random signs on the diagonal. (10) A matrix of the form U' D U, where U is orthogonal
	     * and D has "clustered" entries 1, ulp, ..., ulp with random signs on the diagonal. (11) Same as (8), but
	     * multiplied by sqrt( overflow threshold) (12) Same as (8), but multiplied by sqrt( underflow threshold) (13)
	     * Symmetric matrix with random entries chosen from (-1,1). (14) Same as (13), but multiplied by sqrt( overflow
	     * threshold) (15) Same as (13), but multiplied by sqrt( underflow threshold) (16) Same as (8), but diagonal
	     * elements are all positive. (17) Same as (9), but diagonal elements are all positive. (18) Same as (10), but
	     * diagonal elements are all positive. (19) Same as (16), but multiplied by sqrt( overflow threshold) (20) Same as
	     * (16), but multiplied by sqrt( underflow threshold) (21) A diagonally dominant tridiagonal matrix with
	     * geometrically spaced diagonal entries 1, ..., ulp.
	     * </p>
	     * 
	     * @param nsizes (input) int The number of sizes of matrices to use. If it is zero, dchkst does nothing. It must be
	     *            at least zero.
	     * @param nn (input) int[] of dimension (nsizes) An array containing the sizes to be used for the matrices. Zero
	     *            values will be skipped. The values must be at least zero.
	     * @param ntypes (input) int The number of elements in dotype. If it is zero, dchkst does nothing. It must be at
	     *            least zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined, which is
	     *            to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and dotype[maxtyp]
	     *            is true.
	     * @param dotype (input) boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix of
	     *            that size and of type j will be generated. If ntypes is smaller than the maximum number of types
	     *            defined (parameter maxtyp), then types ntypes+1 through maxtyp will not be generated. If ntypes is
	     *            larger than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
	     * @param iseed (input/output) int[] of dimension (4) On entry iseed specifies the seed of the random number
	     *            generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
	     *            Also, iseed[3] must be odd. The random number generator uses an linear congruential sequence limited
	     *            to small integers, and so should produce machine independent random numbers. The values of iseed are
	     *            changed on exit, and can be used in the next call to dchkst to continue the same random number
	     *            sequence.
	     * @param thresh (input) double A test will count as "failed" if the "error", computed as described above, exceeds
	     *            thresh. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple of
	     *            1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double) or the
	     *            size of the matrix. It must be at least zero.
	     * @param A (input/workspace/output) double[][] of dimension (lda, max(nn)) Used to hold the matrix whose
	     *            eigenvalues are to be computed. On exit, A contains the last matrix actually used.
	     * @param lda (input) int The leading dimension of A. It must be at least 1 and at least max(nn).
	     * @param AP (workspace) double[] of dimension (max(nn)*max(nn+1)/2) The matrix A stored in packed format.
	     * @param SD (workspace/output) double[] of dimension (max(nn)) The diagonal of the tridiagonal matrix computed by
	     *            dsytrd. On exit, SD and SE contain the tridiagonal form of the matrix in A.
	     * @param SE (workspace/output) double[] of dimension (max(nn)) The off-diagonal of the tridiagonal matrix computed
	     *            by dsytrd. On exit, SD and SE contain the tridiagonal form of the matrix in A.
	     * @param D1 (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr
	     *            simultaneously with Z. On exit, the eigenvalues in D1 correspond with the matrix in A.
	     * @param D2 (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr if Z is
	     *            not computed. On exit, the eigenvalues in D2 correspond with the matrix in A.
	     * @param D3 (workspace/output) double[] of dimension max(nn)) The eigenvalues of A, as computed by dsterf. On exit,
	     *            the eigenvalues in D3 correspond with the matrix in A.
	     * @param D4 double[]
	     * @param D5 double[]
	     * @param WA1 double[]
	     * @param WA2 double[]
	     * @param WA3 double[]
	     * @param WR double[]
	     * @param U (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix computed by dsytrd +
	     *            dorgtr.
	     * @param ldu (input) int The leading dimension of U, Z and V. It must be at least 1 and at least max(nn).
	     * @param V (workspace/output) double[][] of dimension (ldu, max(nn)) The Householder vectors computed by dsytrd in
	     *            reducing A to tridiagonal form. The vectors computed with uplo = 'U' are in the upper triangle, and
	     *            the vectors computed with uplo = 'L' are in the lower triangle. (As described in dsytrd, the sub- and
	     *            superdiagonal are not set to 1, although the true Householder vector has a 1 in that position. The
	     *            routines that use V, such as dorgtr, set those entries to 1 before using them, and then restore them
	     *            later.)
	     * @param VP (workspace) double[] of dimension(max(nn)*max(nn+1)/2) The matrix V stored in packed format.
	     * @param tau (workspace/output) double[] of dimension max(nn) The Householder factors computed by dsytrd in
	     *            reducing A to tridiagonal form.
	     * @param Z (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix of eigenvectors computed
	     *            by dsteqr.
	     * @param work (workspace/output) double[] of dimension (lwork)
	     * @param lwork (input) int The number of entries in work. This must be at least 1 + 4*nmax + 2 * nmax * lg nmax + 3
	     *            * nmax**2 where nmax = max(nn[j], 2) and lg = log base 2.
	     * @param iwork (workspace/output) int[] dimension (6+ 6*nmax + 5 * nmax * lg nmax) where nmax = max(nn[j], 2) and
	     *            lg = log base 2
	     * @param liwork (input) int length of iwork
	     * @param result (output) double[] of dimension (26) The values computed by the tests described above. The values
	     *            are currently limited to 1/ulp, to avoid overflow.
	     * @param info (output) int[] If 0, then everything ran OK. -1: nsizes < 0 -2: Some nn[j] < 0 -3: ntypes < 0 -5:
	     *            thresh < 0 -9: lda < 1 or lda < nmax, where nmax is max(nn[j]) -23: ldu < 1 or ldu < nmax -29: lwork
	     *            too small. If dlatmr, dlatms, dsytrd, dorgtr, dsteqr, ssterf, or dormc2 returns an error code, the
	     *            absolute value of it is returned.
	     */
	    private void dchkst(final int nsizes, final int[] nn, final int ntypes, final boolean[] dotype, final int[] iseed,
	            final double thresh, final double[][] A, final int lda, final double[] AP, final double[] SD,
	            final double[] SE, final double[] D1, final double[] D2, final double[] D3, final double[] D4,
	            final double[] D5, final double[] WA1, final double[] WA2, final double[] WA3, final double[] WR,
	            final double[][] U, final int ldu, final double[][] V, final double[] VP, final double[] tau,
	            final double[][] Z, final double[] work, final int lwork, final int[] iwork, final int liwork,
	            final double[] result, final int[] info) {
	        final int maxtyp = 21; // The number of types defined.
	        boolean badnn;
	        int i;
	        final int[] iinfo = new int[1];
	        int imode; // Values to be passed to the matrix generators
	        int itype;
	        int j;
	        int jc;
	        int jr;
	        int jsize;
	        int jtype;
	        int lgn;
	        int log2ui;
	        int mtypes;
	        int n;
	        int nblock; // Blocksize as returned by envir.
	        int nerrs; // The number of tests which have exceeded thresh so far
	        int nmats; // The number of matrices generated so far.
	        int nmax; // Largest value in nn.
	        int ntest; // The number of tests performed, or which can be performed
	        // so far, for the current matrix.
	        int ntestt; // The total number of tests performed so far.
	        double aninv;
	        double anorm; // Norm of A; passed to matrix generators.
	        double cond; // Values to be passed to the matrix generators.
	        final double[] ovfl = new double[1]; // Overflow threshold.
	        double rtovfl; // Square root of ovfl;
	        double rtunfl; // Square root of unfl
	        double temp1;
	        double temp2;
	        double temp3;
	        double temp4;
	        double ulp; // Finest relative precision
	        double ulpinv; // Inverse of finest relative precision
	        final double[] unfl = new double[1]; // Underflow threshold
	        final int[] idumma = new int[1];
	        final int[] ioldsd = new int[4];
	        final int[] iseed2 = new int[4];

	        // The general type (1-10) for type "j".
	        final int[] ktype = new int[] {1, 2, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 8, 8, 8, 9, 9, 9, 9, 9, 10};

	        // The order of magnitude ( O(1), O(overflow^(1/2), O(underflow^(1/2) )
	        final int[] kmagn = new int[] {1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 1, 2, 3, 1, 1, 1, 2, 3, 1};

	        // The mode value to be passed to the matrix generator for type "j".
	        final int[] kmode = new int[] {0, 0, 4, 3, 1, 4, 4, 4, 3, 1, 4, 4, 0, 0, 0, 4, 3, 1, 4, 4, 3};
	        final double[] dumma = new double[1];
	        String name;
	        String opts;
	        double[] work2;
	        double[] work3;
	        final double[] res = new double[2];
	        final double[][] dummy2 = new double[1][1];

	        idumma[0] = 1;
	        ntestt = 0;
	        info[0] = 0;

	        badnn = false;
	        nmax = 1;

	        for (j = 0; j < nsizes; j++) {
	            nmax = Math.max(nmax, nn[j]);

	            if (nn[j] < 0) {
	                badnn = true;
	            }
	        } // for (j = 0; j < nsizes; j++)

	        work2 = new double[3 * nmax];
	        work3 = new double[nmax];

	        name = new String("DSYTRD");
	        opts = new String("L");
	        nblock = ilaenv(1, name, opts, nmax, -1, -1, -1);
	        nblock = Math.min(nmax, Math.max(1, nblock));

	        // Check for errors
	        if (nsizes < 0) {
	            info[0] = -1;
	        } else if (badnn) {
	            info[0] = -2;
	        } else if (ntypes < 0) {
	            info[0] = -3;
	        } else if (lda < nmax) {
	            info[0] = -9;
	        } else if (ldu < nmax) {
	            info[0] = -23;
	        } else if ( (2 * Math.max(2, nmax) * Math.max(2, nmax)) > lwork) {
	            info[0] = -29;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dchkst had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (nsizes == 0) || (ntypes == 0)) {
	            return;
	        }

	        unfl[0] = dlamch('S');
	        ovfl[0] = 1.0 / unfl[0];
	        dlabad(unfl, ovfl);
	        ulp = dlamch('E') * dlamch('B');
	        ulpinv = 1.0 / ulp;
	        log2ui = (int) (Math.log(ulpinv) / Math.log(2.0));
	        rtunfl = Math.sqrt(unfl[0]);
	        rtovfl = Math.sqrt(ovfl[0]);

	        // Loop over sizes, types

	        for (i = 0; i < 4; i++) {
	            iseed2[i] = iseed[i];
	        }

	        nerrs = 0;
	        nmats = 0;

	        for (jsize = 1; jsize <= nsizes; jsize++) {
	            n = nn[jsize - 1];

	            if (n > 0) {
	                lgn = (int) (Math.log((double) n) / Math.log(2.0));

	                if (Math.pow(2.0, lgn) < n) {
	                    lgn = lgn + 1;
	                }

	                if (Math.pow(2.0, lgn) < n) {
	                    lgn = lgn + 1;
	                }
	            } // if (n > 0)

	            aninv = 1.0 / (double) (Math.max(1, n));

	            if (nsizes != 1) {
	                mtypes = Math.min(maxtyp, ntypes);
	            } else {
	                mtypes = Math.min(maxtyp + 1, ntypes);
	            }

	            for (jtype = 1; jtype <= mtypes; jtype++) {

	                if ( !dotype[jtype - 1]) {
	                    continue;
	                }

	                nmats = nmats + 1;
	                ntest = 0;

	                for (j = 0; j < 4; j++) {
	                    ioldsd[j] = iseed[j];
	                }

	                // Compute "A"
	                // Control parameters:
	                /*
	                 * kmagn kmode ktype = 1 O(1) clustered 1 zero = 2 large clustered 2 identity = 3 small exponential
	                 * (none) = 4 arithmetic diagonal, (w/ eigenvalues) = 5 random log symmetric, w/ eigenvalues = 6 random
	                 * (none) = 7 random diagonal = 8 random symmetric = 9 positive definite = 10 diagonally dominant
	                 * tridiagonal
	                 */

	                if (mtypes <= maxtyp) {
	                    itype = ktype[jtype - 1];
	                    imode = kmode[jtype - 1];

	                    // Compute norm

	                    if (kmagn[jtype - 1] == 1) {
	                        anorm = 1.0;
	                    } else if (kmagn[jtype - 1] == 2) {
	                        anorm = (rtovfl * ulp) * aninv;
	                    } else {
	                        anorm = rtunfl * n * ulpinv;
	                    }

	                    dlaset('F', lda, n, 0.0, 0.0, A, lda);
	                    iinfo[0] = 0;

	                    if (jtype <= 15) {
	                        cond = ulpinv;
	                    } else {
	                        cond = ulpinv * aninv / 10.0;
	                    }

	                    // Special Matrices -- Identity & Jordan block

	                    // Zero
	                    if (itype == 1) {
	                        iinfo[0] = 0;
	                    } // if (itype == 1)
	                    else if (itype == 2) {

	                        // Identity
	                        for (jc = 0; jc < n; jc++) {
	                            A[jc][jc] = anorm;
	                        }
	                    } // else if (itype == 2)
	                    else if (itype == 4) {

	                        // Diagonal Matrix, [Eigen]values, Specified
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, 0, 0, 'N', A, lda, work2, iinfo);
	                    } // else if (itype == 4)
	                    else if (itype == 5) {

	                        // Symmetric, eigenvalues specified
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);
	                    } // else if (itype == 5)
	                    else if (itype == 7) {

	                        // Diagonal, random eigenvalues
	                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
	                                idumma, 0, 0, 0.0, anorm, 'N', A, lda, iwork, iinfo);
	                    } // else if (itype == 7)
	                    else if (itype == 8) {

	                        // Symmetric, random eigenvalues
	                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
	                                idumma, n, n, 0.0, anorm, 'N', A, lda, iwork, iinfo);
	                    } // else if (itype == 8)
	                    else if (itype == 9) {

	                        // Positive definite, eigenvalues specified
	                        dlatms(n, n, 'S', iseed, 'P', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);
	                    } // else if (itype == 9)
	                    else if (itype == 10) {

	                        // Positive definite tridiagonal, eigenvalues specified
	                        dlatms(n, n, 'S', iseed, 'P', work, imode, cond, anorm, 1, 1, 'N', A, lda, work2, iinfo);

	                        for (i = 1; i < n; i++) {
	                            temp1 = Math.abs(A[i - 1][i]) / Math.sqrt(Math.abs(A[i - 1][i - 1] * A[i][i]));

	                            if (temp1 > 0.5) {
	                                A[i - 1][i] = 0.5 * Math.sqrt(Math.abs(A[i - 1][i - 1] * A[i][i]));
	                                A[i][i - 1] = A[i - 1][i];
	                            } // if (temp1 > 0.5)
	                        } // for (i = 1; i < n; i++)
	                    } // else if (itype == 10)
	                    else {
	                        iinfo[0] = 1;
	                    } // else

	                    if (iinfo[0] != 0) {
	                        System.out.println("Generator iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        return;
	                    } // if (iinfo[0] != 0)
	                } // if (mtypes <= maxtyp)

	                // Call dsytrd and dorgtr to compute S and U from upper triangle.
	                loop1: {
	                    dlacpy('U', n, n, A, lda, V, ldu);
	                    ntest = 1;
	                    dsytrd('U', n, V, ldu, SD, SE, tau, work, lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dsytrd(U) iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[0] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    dlacpy('U', n, n, V, ldu, U, ldu);
	                    ntest = 2;
	                    dorgtr('U', n, U, ldu, tau, work, lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dorgtr(U) iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[1] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    // Do tests 1 and 2
	                    dsyt21(2, 'U', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, result);
	                    dsyt21(3, 'U', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, res);
	                    result[1] = res[0];

	                    // Call dsytrd and dorgtr to compute S and U from
	                    // lower triangle, do tests.
	                    dlacpy('L', n, n, A, lda, V, ldu);

	                    ntest = 3;
	                    dsytrd('L', n, V, ldu, SD, SE, tau, work, lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dsytrd(L) iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[2] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    dlacpy('L', n, n, V, ldu, U, ldu);

	                    ntest = 4;
	                    dorgtr('L', n, U, ldu, tau, work, lwork, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dorgtr(L) iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[3] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    dsyt21(2, 'L', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, res);
	                    result[2] = res[0];
	                    dsyt21(3, 'L', n, 1, A, lda, SD, SE, U, ldu, V, ldu, tau, work, res);
	                    result[3] = res[0];

	                    // Call dsteqr to compute D1, D2, and Z, do tests.
	                    // Compute D1 and Z
	                    for (i = 0; i < n; i++) {
	                        D1[i] = SD[i];
	                    }

	                    if (n > 0) {

	                        for (i = 0; i < (n - 1); i++) {
	                            work[i] = SE[i];
	                        }
	                    } // if (n > 0)

	                    dlaset('F', n, n, 0.0, 1.0, Z, ldu);

	                    ntest = 5;
	                    dsteqr('V', n, D1, work, Z, ldu, work2, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dsteqr(V) iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[4] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    // Compute D2
	                    for (i = 0; i < n; i++) {
	                        D2[i] = SD[i];
	                    }

	                    if (n > 0) {

	                        for (i = 0; i < (n - 1); i++) {
	                            work[i] = SE[i];
	                        }
	                    } // if (n > 0)

	                    ntest = 7;
	                    dsteqr('N', n, D2, work, dummy2, ldu, work2, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dsteqr(N) iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[6] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    // Compute D3 (using PWK method)
	                    for (i = 0; i < n; i++) {
	                        D3[i] = SD[i];
	                    }

	                    if (n > 0) {

	                        for (i = 0; i < (n - 1); i++) {
	                            work[i] = SE[i];
	                        }
	                    } // if (n > 0)

	                    ntest = 8;
	                    dsterf(n, D3, work, iinfo);

	                    if (iinfo[0] != 0) {
	                        System.out.println("dsterf iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        if (iinfo[0] < 0) {
	                            return;
	                        } else {
	                            result[7] = ulpinv;

	                            break loop1;
	                        }
	                    } // if (iinfo[0] != 0)

	                    // Do tests 5 and 6
	                    dstt21(n, 0, SD, SE, D1, dumma, Z, ldu, work, res);
	                    result[4] = res[0];
	                    result[5] = res[1];

	                    // Do tests 7 and 8
	                    temp1 = 0.0;
	                    temp2 = 0.0;
	                    temp3 = 0.0;
	                    temp4 = 0.0;

	                    for (j = 0; j < n; j++) {
	                        temp1 = Math.max(temp1, Math.abs(D1[j]));
	                        temp1 = Math.max(temp1, Math.abs(D2[j]));
	                        temp2 = Math.max(temp2, Math.abs(D1[j] - D2[j]));
	                        temp3 = Math.max(temp3, Math.abs(D1[j]));
	                        temp3 = Math.max(temp3, Math.abs(D3[j]));
	                        temp4 = Math.max(temp4, Math.abs(D1[j] - D3[j]));
	                    } // for (j = 0; j < n; j++)

	                    result[6] = temp2 / Math.max(unfl[0], ulp * Math.max(temp1, temp2));
	                    result[7] = temp4 / Math.max(unfl[0], ulp * Math.max(temp3, temp4));

	                    // Do Test 9 -- Sturm Sequence of Eigenvalues
	                    // Go up by factors of two until it succeeds
	                    ntest = 9;
	                    temp1 = thresh * (0.5 - ulp);

	                    for (j = 0; j <= log2ui; j++) {
	                        dstech(n, SD, SE, D1, temp1, work, iinfo);

	                        if (iinfo[0] == 0) {
	                            break;
	                        }

	                        temp1 = 2.0 * temp1;
	                    } // for (j = 0; j <= log2ui; j++)

	                    result[8] = temp1;
	                } // loop1

	                ntestt = ntestt + ntest;

	                // End of loop -- Check for result[j] > thresh

	                for (jr = 0; jr < ntest; jr++) {

	                    if (result[jr] >= thresh) {

	                        // If this is the first data to fail,
	                        // print a header to the data file.
	                        if (nerrs == 0) {
	                            System.out.println("DST -- Real Symmetric eigenvalue problem\n");
	                            System.out.println("Matrix types (see dchkst for details):\n");
	                            System.out.println("Special matrices:\n");
	                            System.out.println("1 = Zero matrix\n");
	                            System.out.println("2 = Identity matrix\n");
	                            System.out.println("3 = Diagonal: evenly spaced entries\n");
	                            System.out.println("4 = Diagonal: geometrically spaced entries\n");
	                            System.out.println("5 = Diagonal: clustered entries\n");
	                            System.out.println("6 = Diagonal: large, evenly spaced\n");
	                            System.out.println("7 = Diagonal: small, evenly spaced\n");
	                            System.out.println("Dense Symmetric Matrices\n");
	                            System.out.println("8 = Evenly spaced eigenvalues\n");
	                            System.out.println("9 = Geometrically spaced eigenvalues\n");
	                            System.out.println("10 = Clustered eigenvalues\n");
	                            System.out.println("11 = Large, evenly spaced eigenvalues\n");
	                            System.out.println("12 = Small, evenly spaced eigenvalues\n");
	                            System.out.println("13 = Matrix with random O(1) entries\n");
	                            System.out.println("14 = Matrix with large random entries\n");
	                            System.out.println("15 = Matrix with small random entries\n");
	                            System.out.println("16 = Positive definite, evenly spaced eigenvalues\n");
	                            System.out.println("17 = Positive definite, geometrically spaced eigenvalues\n");
	                            System.out.println("18 = Positive definite, clustered eigenvalues\n");
	                            System.out.println("19 = Positive definite, small evenly spaced eigenvalues\n");
	                            System.out.println("20 = Positive definite, large evenly spaced eigenvalues\n");
	                            System.out.println("21 = Diagonally dominant tridiagonal,\n");
	                            System.out.println("     geometrically, spaced eigenvalues\n");

	                            // Tests performed
	                            System.out.println("Tests performed: see dchkst for details\n");
	                        } // if (nerrs == 0)

	                        nerrs = nerrs + 1;
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("result[" + jr + "] = " + result[jr] + "\n");
	                    } // if (result[jr] >= thresh)
	                } // for (jr = 0; jr < ntest; jr++)
	            } // for (jtype = 1; jtype <= mtypes; jtype++)
	        } // for (jsize = 1; jsize <= nsizes; jsize++)

	        // Summary
	        if (nerrs > 0) {
	            System.out.println("dchkst " + nerrs + " out of " + ntestt + " tests failed to pass the threshold\n");
	        } else {
	            System.out.println("All " + ntestt + " tests for dchkst passed the threshold\n");
	        }

	        return;
	    } // dchkst

	    /**
	     * Port of 12/3/93 linpack ddot routine Original version created by Jack Dongarra Forms the dot product of two
	     * vectors.
	     * 
	     * @param n int
	     * @param dx double[]
	     * @param incx int
	     * @param dy double[]
	     * @param incy int
	     * 
	     * @return double answer
	     */
	    private double ddot(final int n, final double[] dx, final int incx, final double[] dy, final int incy) {
	        double answer;
	        int ix;
	        int iy;
	        int i;
	        int m;
	        int mp1;

	        answer = 0.0;

	        if (n <= 0) {
	            return 0.0;
	        }

	        if ( (incx != 1) || (incy != 1)) {

	            // Code for unequal increments or equal increments not equal to 1
	            ix = 0;
	            iy = 0;

	            if (incx < 0) {
	                ix = ( -n + 1) * incx;
	            }

	            if (incy < 0) {
	                iy = ( -n + 1) * incy;
	            }

	            for (i = 0; i < n; i++) {
	                answer = answer + (dx[ix] * dy[iy]);
	                ix = ix + incx;
	                iy = iy + incy;
	            } // for (i = 0; i < n; i++)

	            return answer;
	        } // if ((incx != 1) || (incy != 1))

	        // Code for both increments equal to 1
	        m = n % 5;

	        if (m != 0) {

	            for (i = 0; i < m; i++) {
	                answer = answer + (dx[i] * dy[i]);
	            }

	            if (n < 5) {
	                return answer;
	            }
	        } // if (m != 0)

	        mp1 = m + 1;

	        for (i = mp1; i <= n; i += 5) {
	            answer = answer + (dx[i - 1] * dy[i - 1]) + (dx[i] * dy[i]) + (dx[i + 1] * dy[i + 1])
	                    + (dx[i + 2] * dy[i + 2]) + (dx[i + 3] * dy[i + 3]);
	        } // for (i = mp1; i <= n; i += 5)

	        return answer;
	    } // ddot

	    /**
	     * This is a port of version 3.1 LAPACK test routine DDRGEV Original DDRGEV created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2007 ddrgev checks the nonsymmetric generalized eigenvalue problem
	     * driver routine dggev.
	     * 
	     * <p>
	     * dggev computes for a pair of n-by-n nonsymmetric matrices (A,B) the generalized eigenvalues and, optionally, the
	     * left and right eigenvectors.
	     * </p>
	     * 
	     * <p>
	     * A generalized eigenvalue for a pair of matrices (A,B) is a scalar w or a ratio alpha/beta = w, such that A - w*B
	     * is singular. It is usually represented as the pair (alpha, beta), as there is reasonable interpretation for beta
	     * = 0, and even for both being zero.
	     * </p>
	     * 
	     * <p>
	     * A right generalized eigenvector corresponding to a generalized eigenvalue w for a pair of matrices (A, B) is a
	     * vector r such that (A - wB) * r = 0. A left generalized eigenvector is a vector L such that L**H * (A - wB) = 0,
	     * where L**H is the conjugate-transpose of L.
	     * </p>
	     * 
	     * <p>
	     * When ddrgev is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For each
	     * size ("n") and each type of matrix, a pair of matrices (A, B) will be generated and used for testing. For each
	     * matrix pair, the following tests will be performed and compared with the threshold thresh.
	     * </p>
	     * 
	     * <p>
	     * Results from dggev: (1) max over all left eigenvalue/-vector pairs (alpha/beta, L) of | VL**H * (beta A - alpha
	     * B) |/ (ulp max(|beta A|, |alpha B|)) where VL**H is the conjugate-transpose of VL. (2) | |VL(i)| - 1 | / ulp and
	     * whether largest component real VL(i) denotes the i-th column of VL. (3) max over all right eigenvalue/-vector
	     * pairs (alpha/beta, r) of | (beta A - alpha B) * VR | / ( ulp max(|beta A|, |alpha B|) ) (4) | |VR(i) - 1 | / ulp
	     * and whether largest component real VR(i) denotes the i-th column of VR. (5) W(full) = W(partial) W(full) denotes
	     * the eigenvalues computed when both L and r are also computed, and W(partial) denotes the eigenvalues computed
	     * when only W, only W and r, or only W and L are computed. (6) VL(full) = VL(partial) VL(full) denotes the left
	     * eigenvectors computed when both L and r are computed, and VL(partial) denotes the result when only L is computed.
	     * (7) VR(full) = VR(partial) VR(full) denotes the right eigenvectors computed when both L and r are also computed,
	     * and VR(partial) denotes the result when only r is computed.
	     * </p>
	     * 
	     * <p>
	     * Test Matrices: The sizes of the test matrices are specified by an array nn(0:nsizes-1); the value of each element
	     * nn[j] specifies one size. The "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j] is true,
	     * then a matrix type "j" will be generated. Currently, the list of possible types is: (1) (0, 0) (a pair of zero
	     * matrices) (2) (I, 0) (an identity and a zero matrix) (3) (0, I) (a zero and an identity matrix) (4) (I, I) (a
	     * pair of identity matrices) (5) (Jtranspose, Jtranspose) (a pair of transposed Jordan blocks) (6) (X, Y) where X =
	     * (Jtranspose 0) and Y = (I 0 ) (0 I) (0 Jtranspose) and I is a k by k identity and J a (k+1) by (k+1) Jordan
	     * block; k = (N-1)/2 (7) (D, I) where D is diag(0, 1,..., N-1) (a diagonal matrix with those diagonal entries.) (8)
	     * (I, D) (9) (big*D, small*I) where "big" is near overflow and small = 1/big (10) (small*D, big*I) (11) (big*I,
	     * small*D) (12) (small*I, big*D) (13) (big*D, big*I) (14) (small*D, small*I) (15) (D1, D2) where D1 is diag(0, 0,
	     * 1, ..., N-3, 0) and D2 is diag(0, N-3, N-4,..., 1, 0, 0) (16) Q (Jtranspose, Jtranspose) Z where Q and Z are
	     * random orthogonal matrices. (17) Q (T1, T2) Z where T1 and T2 are upper triangular matrices with random O(1)
	     * entries above the diagonal and diagonal entries diag(T1) = (0, 0, 1, ..., N-3, 0) and diag(T2) = (0, N-3, N-4,
	     * ..., 1, 0, 0) (18) Q (T1, T2) Z diag(T1) = (0, 0, 1, 1, s, ..., s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0) s =
	     * machine precision (19) Q (T1, T2) Z diag(T1) = (0,0,1,1, 1-d, ..., 1 - (N-5)*d=s, 0) diag(T2) = (0, 1, 0, 1, ...,
	     * 1, 0) (20) Q (T1, T2) Z diag(T1) = (0,0,1,1,a, ..., a**(N-5)=s, 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0) (21) Q
	     * (T1, T2) Z diag(T1) = (0, 0, 1, r1, r2, ..., r(N-4), 0) diag(T2) = (0, 1, 0, 1, ..., 1, 0, 0) where r1, ...,
	     * r(N-4) are random. (22) Q (big*T1, small*T2) Z diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0)
	     * (23) Q (small*T1, big*T2) Z diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0) (24) Q (small*T1,
	     * small*T2) Z diag(T1) = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0) (25) Q (big*T1, big*T2) Z diag(T1)
	     * = (0, 0, 1, ..., N-3, 0) diag(T2) = (0, 1, ..., 1, 0, 0) (26) Q(T1, T2) Z where T1 and T2 are random
	     * upper-triangular matrices.
	     * </p>
	     * 
	     * @param nsizes input int The number of sizes of matrices to use. If it is zero, ddrgev does nothing. nsizes >= 0.
	     * @param nn input int[] of dimension (nsizes) An array containing the sizes to be used for the matrices. Zero
	     *            values will be skipped. nn >= 0.
	     * @param ntypes input int The number of elements in dotype. If it is zero, ddrgev does nothing. It must be at least
	     *            zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined, which is to use
	     *            whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and dotype(maxtyp) is
	     *            true.
	     * @param dotype input boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix of
	     *            that size and of type j will be generated. If ntypes is smaller than the maximum number of types
	     *            defined(maxtyp), then types ntypes+1 through maxtyp will not be generated. If ntypes is larger than
	     *            maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
	     * @param iseed (input/output) int[] of dimension (4) On entry iseed specifies the seed of the random number
	     *            generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
	     *            Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence limited to
	     *            small integers, and so should produce machine independent random numbers. The values of iseed are
	     *            changed on exit, and can be used in the next call to ddrgev to continue the same random number
	     *            sequence.
	     * @param thresh input double A test will count as "failed" if the "error", computed as described above, exceeds
	     *            thresh. Note that the error is scaled to O(1), so thresh should be a reasonably small multiple of 1,
	     *            e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double) or the size
	     *            of the matrix. It must be at least zero.
	     * @param A (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original A matrix. Used as
	     *            input only if ntypes = maxtyp+1, dotype(0:maxtyp-1) = false, and dotype[maxtyp] = true.
	     * @param lda input int The leading dimension of A, B, S, and T. It must be at least 1 and at least max(nn).
	     * @param B (input/workspace) double[][] of dimension (lda, max(nn)) Used to hold the original B matrix. Used as
	     *            input only if ntypes = maxtyp+1, dotype(0:maxtyp-1) = false, and dotype[maxtyp] = true.
	     * @param S workspace double[][] of dimension (lda, max(nn)) The Schur form matrix computed from A by dggev. On
	     *            exit, S contains the Schur form matrix corresponding to the matrix in A.
	     * @param T workspace double[][] of dimension (lda, max(nn)) The upper triangular matrix computed from B by dggev.
	     * @param Q workspace double[][] of dimension (ldq, max(nn)) The (left) eigenvectors matrix computed by dggev.
	     * @param ldq input int The leading dimension of Q and Z. It must be at least 1 and at least max(nn).
	     * @param Z Z (workspace) double[][] of dimension (ldq, max(nn)) The (right) orthogonal matrix computed by dggev.
	     * @param QE QE (workspace) double[][] of dimension (ldqe, max(nn)) QE holds the computed right or left
	     *            eigenvectors.
	     * @param ldqe input int The leading dimension of QE. ldqe >= max(1,max(nn))
	     * @param alphar workspace double[] of dimension (max(nn))
	     * @param alphai workspace double[] of dimension (max(nn))
	     * @param beta workspace double[] of dimension (max(nn)) The generalized eigenvalues of (A,B) computed by dggev.
	     *            (alphar[k-1] + alphai[k-1]*i)/ beta[k-1] is the k-th generalized eigenvalue of A and B.
	     * @param alphr1 workspace double[] of dimension (max(nn))
	     * @param alphi1 workspace double[] of dimension (max(nn))
	     * @param beta1 workspace double[] of dimension (max(nn)) Like alphar, alphai, and beta, these arrays contain the
	     *            eigenvalues of A and B, but those computed when dggev only computes a partial eigendecomposition, i.e.
	     *            not the eigenvalues and left and right eigenvectors.
	     * @param work workspace double[] of dimension (lwork)
	     * @param lwork input int The nuber of entries in work. lwork >= max(8*N, N*(N+1)).
	     * @param result output double[] of dimension (2) The values are computed by the tests described above. The values
	     *            are currently limited to 1/ulp, to avoid overflow.
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value. > 0:
	     *            A routine returned an error code.
	     */
	    private void ddrgev(final int nsizes, final int[] nn, final int ntypes, final boolean[] dotype, final int[] iseed,
	            final double thresh, final double[][] A, final int lda, final double[][] B, final double[][] S,
	            final double[][] T, final double[][] Q, final int ldq, final double[][] Z, final double[][] QE,
	            final int ldqe, final double[] alphar, final double[] alphai, final double[] beta, final double[] alphr1,
	            final double[] alphi1, final double[] beta1, final double[] work, final int lwork, final double[] result,
	            final int[] info) {
	        final int maxtyp = 26;
	        boolean badnn;
	        int i;
	        int iadd;
	        final int[] ierr = new int[1];
	        int in;
	        int j;
	        int jc;
	        int jr;
	        int jsize;
	        int jtype;
	        int maxwrk = 1;
	        int minwrk;
	        int mtypes;
	        int n;
	        int n1;
	        int nerrs;
	        int nmats;
	        int nmax;
	        int ntestt;
	        final double[] safmax = new double[1];
	        final double[] safmin = new double[1];
	        double ulp;
	        double ulpinv;
	        final int[] iasign = new int[] {0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 2, 2, 2, 2, 2, 0};
	        final int[] ibsign = new int[] {0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	        final int[] ioldsd = new int[4];
	        final int[] kadd = new int[] {0, 0, 0, 0, 3, 2};
	        final int[] kamagn = new int[] {1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 2, 3, 1, 1, 1, 1, 1, 1, 1, 2, 3, 3, 2, 1};
	        final int[] katype = new int[] {0, 1, 0, 1, 2, 3, 4, 1, 4, 4, 1, 1, 4, 4, 4, 2, 4, 5, 8, 7, 9, 4, 4, 4, 4, 0};
	        final int[] kazero = new int[] {1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 3, 1, 3, 5, 5, 5, 5, 3, 3, 3, 3, 1};
	        final int[] kbmagn = new int[] {1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 2, 3, 1, 1, 1, 1, 1, 1, 1, 3, 2, 3, 2, 1};
	        final int[] kbtype = new int[] {0, 0, 1, 1, 2, -3, 1, 4, 1, 1, 4, 4, 1, 1, -4, 2, -4, 8, 8, 8, 8, 8, 8, 8, 8, 0};
	        final int[] kbzero = new int[] {1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 4, 1, 4, 6, 6, 6, 6, 4, 4, 4, 4, 1};
	        final int[] kclass = new int[] {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3};
	        final int[] ktrian = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
	        final int[] kz1 = new int[] {0, 1, 2, 1, 3, 3};
	        final int[] kz2 = new int[] {0, 0, 1, 2, 1, 1};
	        final double[] rmagn = new double[4];
	        String name;
	        String opts;
	        final double[] alpha = new double[1];
	        double[] x;
	        final double[] tau = new double[1];
	        double[] work2;

	        // Check for errors
	        info[0] = 0;
	        badnn = false;
	        nmax = 1;

	        for (j = 0; j < nsizes; j++) {
	            nmax = Math.max(nmax, nn[j]);

	            if (nn[j] < 0) {
	                badnn = true;
	            } // if (nn[j] < 0)
	        } // for (j = 0; j < nsizes; j++)

	        if (nsizes < 0) {
	            info[0] = -1;
	        } else if (badnn) {
	            info[0] = -2;
	        } else if (ntypes < 0) {
	            info[0] = -3;
	        } else if (thresh < 0.0) {
	            info[0] = -6;
	        } else if ( (lda <= 1) || (lda < nmax)) {
	            info[0] = -9;
	        } else if ( (ldq <= 1) || (ldq < nmax)) {
	            info[0] = -14;
	        } else if ( (ldqe <= 1) || (ldqe < nmax)) {
	            info[0] = -17;
	        }

	        // Compute workspace:
	        // (Note: Comments in the code beginning "Workspace:" describe the
	        // minimal amount of workspace needed at that point in the code, as well
	        // as the preferred amount for good performance. NB refers to the
	        // optimal block size for the immediately following subroutine, as
	        // returned by ilaenv.

	        minwrk = 1;

	        if ( (info[0] == 0) && (lwork >= 1)) {
	            minwrk = Math.max(1, 8 * nmax);
	            minwrk = Math.max(minwrk, nmax * (nmax + 1));
	            name = new String("DGEQRF");
	            opts = new String(" ");
	            maxwrk = (7 * nmax) + (nmax * ilaenv(1, name, opts, nmax, 1, nmax, 0));
	            maxwrk = Math.max(maxwrk, nmax * (nmax + 1));
	            work[0] = maxwrk;
	        } // if ((info[0] == 0) && (lwork >= 1))

	        if (lwork < minwrk) {
	            info[0] = -25;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error ddrgev had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (nsizes == 0) || (ntypes == 0)) {
	            return;
	        }

	        safmin[0] = dlamch('S');
	        ulp = dlamch('E') * dlamch('B');
	        safmin[0] = safmin[0] / ulp;
	        safmax[0] = 1.0 / safmin[0];
	        dlabad(safmin, safmax);
	        ulpinv = 1.0 / ulp;

	        // The values rmagn[2] and rmagn[3] depend on n, see below.
	        rmagn[0] = 0.0;
	        rmagn[1] = 1.0;

	        // Loop over sizes, types
	        ntestt = 0;
	        nerrs = 0;
	        nmats = 0;

	        for (jsize = 1; jsize <= nsizes; jsize++) {
	            n = nn[jsize - 1];
	            n1 = Math.max(1, n);
	            rmagn[2] = safmax[0] * ulp / n1;
	            rmagn[3] = safmin[0] * ulpinv * n1;

	            if (nsizes != 1) {
	                mtypes = Math.min(maxtyp, ntypes);
	            } else {
	                mtypes = Math.min(maxtyp + 1, ntypes);
	            }

	            for (jtype = 1; jtype <= mtypes; jtype++) {

	                if ( !dotype[jtype - 1]) {
	                    continue;
	                } // if (!dotype[jtype-1])

	                nmats = nmats + 1;

	                // Save iseed in case of an error.
	                for (j = 0; j < 4; j++) {
	                    ioldsd[j] = iseed[j];
	                }

	                // Generate test matrices A and B
	                // Description of control parameters
	                // kclass = 1 means without rotation, = 2 means with rotation
	                // = 3 means random
	                // katype: the "type" to be passed to dlatm4 for computing A.
	                // kazero: the pattern of zeros on the diagonal for A:
	                // = 1: ( xxx ), = 2: (0, xxx ), = 3: (0, 0, xxx, 0 ),
	                // = 4: ( 0, xxx, 0, 0 ), = 5: ( 0, 0, 1, xxx, 0 ),
	                // = 6: ( 0, 1, 0, xxx, 0 ). (xxx means a string of
	                // non-zero entries.)
	                // kamagn: the magnitude of the matrix: = 0: zero, = 1: O(1),
	                // = 2: large, = 3: small.
	                // iasign: 1 if the diagonal elements of A are to be multiplied
	                // by a random magnitude 1 number, = 2 if randomly
	                // chosen diagonal blocks are to be rotated to form
	                // 2 by 2 blocks.
	                // kbtype, kbzero, kbmagn, ibsign: the same, but for B.
	                // ktrian: = 0: don't fill in the upper triangle, = 1: do.
	                // kz1, kz2, kadd: used to implement kazero and kbzero.
	                // rmagn: used to implement kamagn and kbmagn.

	                if (mtypes <= maxtyp) {
	                    ierr[0] = 0;

	                    if (kclass[jtype - 1] < 3) {

	                        // Generate A (without rotation)
	                        if (Math.abs(katype[jtype - 1]) == 3) {
	                            in = (2 * ( (n - 1) / 2)) + 1;

	                            if (in != n) {
	                                dlaset('F', n, n, 0.0, 0.0, A, lda);
	                            }
	                        } // if (Math.abs(katype[jtype-1] == 3)
	                        else { // Math.abs(katype[jtype-1] != 3
	                            in = n;
	                        } // else Math.abs(katype[jtype-1] != 3

	                        dlatm4(katype[jtype - 1], in, kz1[kazero[jtype - 1] - 1], kz2[kazero[jtype - 1] - 1],
	                                iasign[jtype - 1], rmagn[kamagn[jtype - 1]], ulp, rmagn[ktrian[jtype - 1]
	                                        * kamagn[jtype - 1]], 2, iseed, A, lda);
	                        iadd = kadd[kazero[jtype - 1] - 1];

	                        if ( (iadd > 0) && (iadd <= n)) {
	                            A[iadd - 1][iadd - 1] = 1.0;
	                        } // if ((iadd > 0) && (iadd <= n))

	                        // Generate B (without rotation)
	                        if (Math.abs(kbtype[jtype - 1]) == 3) {
	                            in = (2 * ( (n - 1) / 2)) + 1;

	                            if (in != n) {
	                                dlaset('F', n, n, 0.0, 0.0, B, lda);
	                            }
	                        } // if (Math.abs(kbtype[jtype-1] == 3)
	                        else { // Math.abs(kbtype[jtype-1] != 3
	                            in = n;
	                        } // else Math.abs(kbtype[jtype-1] != 3

	                        dlatm4(kbtype[jtype - 1], in, kz1[kbzero[jtype - 1] - 1], kz2[kbzero[jtype - 1] - 1],
	                                ibsign[jtype - 1], rmagn[kbmagn[jtype - 1]], 1.0, rmagn[ktrian[jtype - 1]
	                                        * kbmagn[jtype - 1]], 2, iseed, B, lda);
	                        iadd = kadd[kbzero[jtype - 1] - 1];

	                        if ( (iadd != 0) && (iadd <= n)) {
	                            B[iadd - 1][iadd - 1] = 1.0;
	                        } // if ((iadd != 0) && (iadd <= n))

	                        if ( (kclass[jtype - 1] == 2) && (n > 0)) {

	                            // Include rotations
	                            // Generate Q, Z as Householder transformations
	                            // times a diagonal matrix
	                            for (jc = 1; jc <= (n - 1); jc++) {

	                                for (jr = jc; jr <= n; jr++) {
	                                    Q[jr - 1][jc - 1] = dlarnd(3, iseed);
	                                    Z[jr - 1][jc - 1] = dlarnd(3, iseed);
	                                } // for (jr = jc; jr <= n; jr++)

	                                alpha[0] = Q[jc - 1][jc - 1];
	                                x = new double[n - jc];

	                                for (i = 0; i < (n - jc); i++) {
	                                    x[i] = Q[jc + i][jc - 1];
	                                }

	                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
	                                Q[jc - 1][jc - 1] = alpha[0];

	                                for (i = 0; i < (n - jc); i++) {
	                                    Q[jc + i][jc - 1] = x[i];
	                                }

	                                work[jc - 1] = tau[0];

	                                if (Q[jc - 1][jc - 1] >= 0.0) {
	                                    work[ (2 * n) + jc - 1] = 1.0;
	                                } else {
	                                    work[ (2 * n) + jc - 1] = -1.0;
	                                }

	                                Q[jc - 1][jc - 1] = 1.0;
	                                alpha[0] = Z[jc - 1][jc - 1];

	                                for (i = 0; i < (n - jc); i++) {
	                                    x[i] = Z[jc + i][jc - 1];
	                                }

	                                dlarfg(n + 1 - jc, alpha, x, 1, tau);
	                                Z[jc - 1][jc - 1] = alpha[0];

	                                for (i = 0; i < (n - jc); i++) {
	                                    Z[jc + i][jc - 1] = x[i];
	                                }

	                                work[n + jc - 1] = tau[0];

	                                if (Z[jc - 1][jc - 1] >= 0.0) {
	                                    work[ (3 * n) + jc - 1] = 1.0;
	                                } else {
	                                    work[ (3 * n) + jc - 1] = -1.0;
	                                }

	                                Z[jc - 1][jc - 1] = 1.0;
	                            } // for (jc = 1; jc <= n-1; jc++)

	                            Q[n - 1][n - 1] = 1.0;
	                            work[n - 1] = 0.0;

	                            if (dlarnd(2, iseed) >= 0.0) {
	                                work[ (3 * n) - 1] = 1.0;
	                            } else {
	                                work[ (3 * n) - 1] = -1.0;
	                            }

	                            Z[n - 1][n - 1] = 1.0;
	                            work[ (2 * n) - 1] = 0.0;

	                            if (dlarnd(2, iseed) >= 0.0) {
	                                work[ (4 * n) - 1] = 1.0;
	                            } else {
	                                work[ (4 * n) - 1] = -1.0;
	                            }

	                            // Apply the diagonal matrices
	                            for (jc = 0; jc < n; jc++) {

	                                for (jr = 0; jr < n; jr++) {
	                                    A[jr][jc] = work[ (2 * n) + jr] * work[ (3 * n) + jc] * A[jr][jc];
	                                    B[jr][jc] = work[ (2 * n) + jr] * work[ (3 * n) + jc] * B[jr][jc];
	                                } // for (jr = 0; jr < n; jr++)
	                            } // for (jc = 0; jc < n; jc++)

	                            work2 = new double[n];
	                            dorm2r('L', 'N', n, n, n - 1, Q, ldq, work, A, lda, work2, ierr);

	                            if (ierr[0] != 0) {
	                                System.out.println("ddrgev had error in first dorm2r\n");
	                                System.out.println("ierr[0] = " + ierr[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(ierr[0]);

	                                return;
	                            }

	                            x = new double[n - 1];

	                            for (i = 0; i < (n - 1); i++) {
	                                x[i] = work[n + i];
	                            }

	                            dorm2r('R', 'T', n, n, n - 1, Z, ldq, x, A, lda, work2, ierr);

	                            if (ierr[0] != 0) {
	                                System.out.println("ddrgev had error in second dorm2r\n");
	                                System.out.println("ierr[0] = " + ierr[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(ierr[0]);

	                                return;
	                            }

	                            dorm2r('L', 'N', n, n, n - 1, Q, ldq, work, B, lda, work2, ierr);

	                            if (ierr[0] != 0) {
	                                System.out.println("ddrgev had error in third dorm2r\n");
	                                System.out.println("ierr[0] = " + ierr[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(ierr[0]);

	                                return;
	                            }

	                            dorm2r('R', 'T', n, n, n - 1, Z, ldq, x, B, lda, work2, ierr);

	                            if (ierr[0] != 0) {
	                                System.out.println("ddrgev had error in fourth dorm2r\n");
	                                System.out.println("ierr[0] = " + ierr[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(ierr[0]);

	                                return;
	                            }
	                        } // if ((kclass[jtype-1] == 2) && (n > 0))
	                    } // if (kclass[jtype-1] < 3)
	                    else { // kclass[jtype-1] >= 3

	                        // Random matrices
	                        for (jc = 0; jc < n; jc++) {

	                            for (jr = 0; jr < n; jr++) {
	                                A[jr][jc] = rmagn[kamagn[jtype - 1]] * dlarnd(2, iseed);
	                                B[jr][jc] = rmagn[kbmagn[jtype - 1]] * dlarnd(2, iseed);
	                            } // for (jr = 0; jr < n; jr++)
	                        } // for (jc = 0; jc < n; jc++)
	                    } // else kclass[jtype-1] >= 3
	                } // if (mtypes <= maxtyp)

	                for (i = 0; i < 7; i++) {
	                    result[i] = -1.0;
	                } // for (i = 0; i < 7; i++)

	                // Call dggev to compute eigevalues and eigenvectors
	                dlacpy(' ', n, n, A, lda, S, lda);
	                dlacpy(' ', n, n, B, lda, T, lda);
	                dggev('V', 'V', n, S, lda, T, lda, alphar, alphai, beta, Q, ldq, Z, ldq, work, lwork, ierr);

	                if ( (ierr[0] != 0) && (ierr[0] != (n + 1))) {
	                    result[0] = ulpinv;
	                    System.out.println("ddrgev had error in call to dggev1\n");
	                    System.out.println("ierr[0] = " + ierr[0] + "\n");
	                    System.out.println("n = " + n + "\n");
	                    System.out.println("jtype = " + jtype + "\n");
	                    System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                    System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                    System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                    System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    info[0] = Math.abs(ierr[0]);
	                } else { // No error in dggev1

	                    // Do the tests (1) and (2)
	                    dget52(true, n, A, lda, B, lda, Q, ldq, alphar, alphai, beta, work, result);

	                    if (result[1] > thresh) {
	                        System.out.println("ddrgev left eigenvectors from dggev1 incorrectly normalized\n");
	                        System.out.println("Bits of error = " + result[1] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    } // if (result[1] > thresh)

	                    // Do the tests 3 and 4
	                    x = new double[2];
	                    dget52(false, n, A, lda, B, lda, Z, ldq, alphar, alphai, beta, work, x);
	                    result[2] = x[0];
	                    result[3] = x[1];

	                    if (result[3] > thresh) {
	                        System.out.println("ddrgev right eigenvectors from dggev1 incorrectly normalized\n");
	                        System.out.println("Bits of error = " + result[3] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                    } // if (result[3] > thresh)

	                    // Do the test (5)
	                    dlacpy(' ', n, n, A, lda, S, lda);
	                    dlacpy(' ', n, n, B, lda, T, lda);
	                    dggev('N', 'N', n, S, lda, T, lda, alphr1, alphi1, beta1, Q, ldq, Z, ldq, work, lwork, ierr);

	                    if ( (ierr[0] != 0) && (ierr[0] != (n + 1))) {
	                        result[0] = ulpinv;
	                        System.out.println("ddrgev had error in call to dggev2\n");
	                        System.out.println("ierr[0] = " + ierr[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(ierr[0]);
	                    } // if ((ierr[0] != 0) && (ierr[0] != n+1))
	                    else { // no error in dggev2

	                        for (j = 0; j < n; j++) {

	                            if ( (alphar[j] != alphr1[j]) || (alphai[j] != alphi1[j]) || (beta[j] != beta1[j])) {
	                                result[4] = ulpinv;
	                            }
	                        } // for (j = 0; j < n; j++)

	                        // Do the test (6): Compute eigenvalues and left
	                        // eigenvectors, and test them
	                        dlacpy(' ', n, n, A, lda, S, lda);
	                        dlacpy(' ', n, n, B, lda, T, lda);
	                        dggev('V', 'N', n, S, lda, T, lda, alphr1, alphi1, beta1, QE, ldqe, Z, ldq, work, lwork, ierr);

	                        if ( (ierr[0] != 0) && (ierr[0] != (n + 1))) {
	                            result[0] = ulpinv;
	                            System.out.println("ddrgev had error in call to dggev3\n");
	                            System.out.println("ierr[0] = " + ierr[0] + "\n");
	                            System.out.println("n = " + n + "\n");
	                            System.out.println("jtype = " + jtype + "\n");
	                            System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                            System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                            System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                            System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                            info[0] = Math.abs(ierr[0]);
	                        } // if ((ierr[0] != 0) && (ierr[0] != n+1))
	                        else { // no error in dggev3

	                            for (j = 0; j < n; j++) {

	                                if ( (alphar[j] != alphr1[j]) || (alphai[j] != alphi1[j]) || (beta[j] != beta1[j])) {
	                                    result[5] = ulpinv;
	                                }
	                            } // for (j = 0; j < n; j++)

	                            for (j = 0; j < n; j++) {

	                                for (jc = 0; jc < n; jc++) {

	                                    if (Q[j][jc] != QE[j][jc]) {
	                                        result[5] = ulpinv;
	                                    }
	                                }
	                            } // for (j = 0; j < n; j++)

	                            // Do the test(7): Compute eigenvalues and right
	                            // eigenvectors, and test them
	                            dlacpy(' ', n, n, A, lda, S, lda);
	                            dlacpy(' ', n, n, B, lda, T, lda);
	                            dggev('N', 'V', n, S, lda, T, lda, alphr1, alphi1, beta1, Q, ldq, QE, ldqe, work, lwork,
	                                    ierr);

	                            if ( (ierr[0] != 0) && (ierr[0] != (n + 1))) {
	                                result[0] = ulpinv;
	                                System.out.println("ddrgev had error in call to dggev4\n");
	                                System.out.println("ierr[0] = " + ierr[0] + "\n");
	                                System.out.println("n = " + n + "\n");
	                                System.out.println("jtype = " + jtype + "\n");
	                                System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                                System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                                System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                                System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                                info[0] = Math.abs(ierr[0]);
	                            } // if ((ierr[0] != 0) && (ierr[0] != n+1))
	                            else { // no error in dggev4

	                                for (j = 0; j < n; j++) {

	                                    if ( (alphar[j] != alphr1[j]) || (alphai[j] != alphi1[j]) || (beta[j] != beta1[j])) {
	                                        result[6] = ulpinv;
	                                    }
	                                } // for (j = 0; j < n; j++)

	                                for (j = 0; j < n; j++) {

	                                    for (jc = 0; jc < n; jc++) {

	                                        if (Z[j][jc] != QE[j][jc]) {
	                                            result[6] = ulpinv;
	                                        }
	                                    }
	                                } // for (j = 0; j < n; j++)
	                            } // else no error in dggev4
	                        } // else no error in dggev3
	                    } // else no error in dggev2
	                } // else no error in dggev1

	                // End of loop -- Check for result[j] > thresh
	                ntestt = ntestt + 7;

	                // Print out which tests fail
	                for (jr = 0; jr < 7; jr++) {

	                    if (result[jr] >= thresh) {

	                        // If this is the first test to fail,
	                        // print a header to the data file
	                        if (nerrs == 0) {
	                            System.out.println("dggev real generalized eigenvalue problem driver\n");

	                            // Matrix types
	                            System.out.println("Matrix types (see ddrgev for details):\n");
	                            System.out.println("Special Matrices:\n");
	                            System.out.println("J' = transposed Jordan block\n");
	                            System.out.println("1 = (0,0)\n");
	                            System.out.println("2 = (I,0)\n");
	                            System.out.println("3 = (0,I)\n");
	                            System.out.println("4 = (I,I)\n");
	                            System.out.println("5 = (J',J')\n");
	                            System.out.println("6 = (diag(J',I), diag(I,J'))\n");
	                            System.out.println("Diagonal Matrices: D = diag(0,1,2,...)\n");
	                            System.out.println("7 = (D,I)\n");
	                            System.out.println("8 = (I,D)\n");
	                            System.out.println("9 = (large*D, small*I)\n");
	                            System.out.println("10 = (small*D, large*I)\n");
	                            System.out.println("11 = ((large*I, small*D)\n");
	                            System.out.println("12 = (small*I , large*D)\n");
	                            System.out.println("13 = (large*D, large*I)\n");
	                            System.out.println("14 = (small*D, small*I)\n");
	                            System.out.println("15 = (D, reversed D)\n");
	                            System.out.println("Matrices Rotated by Random Orthogonal Matrices U,V:\n");
	                            System.out.println("16 = transposed Jordan Blocks\n");
	                            System.out.println("17 = arithm. alpha & beta\n");
	                            System.out.println("18 = clustered alpha, beta = 0,1\n");
	                            System.out.println("19 = geometric alpha, beta = 0, 1\n");
	                            System.out.println("20 = arithmetic alpha, beta = 0, 1\n");
	                            System.out.println("21 = random alpha, beta = 0, 1\n");
	                            System.out.println("Large & Small Matrices:\n");
	                            System.out.println("22 = (large, small)\n");
	                            System.out.println("23 = (small, large)\n");
	                            System.out.println("24 = (small, small)\n");
	                            System.out.println("25 = (large, large)\n");
	                            System.out.println("26 = random O(1) matrices\n");

	                            // Tests performed
	                            System.out.println("Tests performed:\n");
	                            System.out.println("1 = max | (b A - a B)' * L | / const\n");
	                            System.out.println("2 = | | Vr[i]| - 1 | / ulp\n");
	                            System.out.println("3 = max | ( b A - a B) * r | / const\n");
	                            System.out.println("4 = | | VL[i] | - 1 | / ulp\n");
	                            System.out.println("5 = 0 if W same no matter if r or L computed\n");
	                            System.out.println("6 = 0 if L same no matter if L computed\n");
	                            System.out.println("7 = 0 if r same no matter if r computed\n");
	                        } // if (nerrs == 0)

	                        nerrs = nerrs + 1;
	                        System.out.println("Matrix order = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        System.out.println("result[" + jr + "] = " + result[jr] + "\n");
	                    } // if (result[jr] >= thresh)
	                } // for (jr = 0; jr < 7; jr++)
	            } // for (jtype = 1; jtype <= mtypes; jtype++)
	        } // for (jsize = 1; jsize <= nsizes; jsize++)

	        // Summary
	        if (nerrs > 0) {
	            System.out.println(nerrs + " out of " + ntestt + " dggev tests failed to pass the threshold\n");
	        } else {
	            System.out.println("All " + ntestt + " dggev tests passed the threshold\n");
	        }

	        work[0] = maxwrk;

	        return;
	    } // ddrgev

	    /**
	     * This is a port of that portion of the version 3.1 LAPACK test routine DDRVSG that tests the DSYGV that computes
	     * all eigenvalues and, optionally, eigenvectors of a real symmetric-definite generalized eigenproblem. Original
	     * DDRVSG created by Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006 When ddrvsg is
	     * called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For each size ("n") and
	     * each type of matrix, one matrix A of the given type will be generated; a random well- conditioned matrix B is
	     * also generated and the pair (A,B) is used to test the drivers.
	     * 
	     * For each pair (A,B), the following tests are performed: (1) dsygv with itype = 1 and uplo = 'U': |A Z - B Z D | /
	     * (|A| |Z| n ulp) (2) dysgv with itype = 1 and uplo = 'L' (3) dsygv with itype = 2 and uplo = 'U' |A B Z - Z D |/
	     * (|A| |Z| n ulp) (4) dsygv with itype = 2 and uplo = 'L' (5) dsygv with itype = 3 and uplo = 'U' | B A Z - Z D | /
	     * ( |A| |Z| n ulp) (6) dsygv with itype = 3 and uplo = 'L'
	     * 
	     * <p>
	     * The "sizes" are specified by an array nn(0:nsizes-1); the value of each element nn[j] specifies one size. The
	     * "types" are specified by a logical array dotype(0:ntypes-1); if dotype[j] is true, then matrix type "j" will be
	     * generated. This type is used for the matrix A which has half-bandwidth ka. B is generated as a well-conditioned
	     * positive definite matrix with half-bandwidth kb (<= ka). Currently, the list of possible types for A is: (1) The
	     * zero matrix. (2) The identity matrix. (3) A diagonal matrix with evenly spaced entries 1, ..., ulp and random
	     * signs. (ulp = (first number larger than 1) - 1) (4) A diagonal matrix with geometrically spaced entries 1, ...,
	     * ulp and random signs. (5) A diagonal matrix with "clustered" entries 1, ulp, ... , ulp and random signs. (6) Same
	     * as (4), but multiplied by sqrt(overflow threshold) (7) Same as (4), but multiplied by sqrt(underflow threshold)
	     * (8) A matrix of the form U* D U, where U is orthogonal and D has evenly spaced entries 1, ..., ulp with random
	     * signs on the diagonal. (9) A matrix of the form U* D U, where U is orthogonal and D has geometrically spaced
	     * entries 1, ..., ulp with random signs on the diagonal. (10) A matrix of the form U* D U, where U is orthgonal and
	     * D has "clustered" entries 1, ulp, ..., ulp with random signs on the diagonal. (11) Same as (8), but multiplied by
	     * sqrt(overflow threshold) (12) Same as (8), but multiplied by sqrt(underflow threshold) (13) Symmetric matrix,
	     * with random entries chosen from (-1,1). (14) Same as (13), but multiplied by sqrt(overflow threshold). (15) Same
	     * as (13), but multiplied by sqrt(underflow threshold). (16) Same as (8), but with ka = 1 and kb = 1. (17) Same as
	     * (8), but with ka = 2 and kb = 1. (18) Same as (8), but with ka = 2 and kb = 2. (19) Same as (8), but with ka = 3
	     * and kb = 1. (20) Same as (8), but with ka = 3 and kb = 2. (21) Same as (8), but with ka = 3 and kb = 3.
	     * </p>
	     * 
	     * @param nsizes input int The number of sizes of matrices to use. If it is zero, ddrvsg does nothing. It must be at
	     *            least zero.
	     * @param nn input int[] of dimension nsizes. An array containing the sizes to be used for the matrices. Zero values
	     *            will be skipped. The values must be at least zero.
	     * @param ntypes input int The number of elements in dotype. If it is zero, ddrvsg does nothing. It must be at least
	     *            zero. If it is maxtyp+1 and nsizes is 1, then an addtional type, maxtyp+1 is defined, which is to use
	     *            whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and dotype(maxtyp) is
	     *            true.
	     * @param dotype input boolean[] of dimension ntypes. If dotype[j-1] is true, then for each size in nn a matrix of
	     *            that size and of type j will be generated. If ntypes is smaller than the maximum number of types
	     *            defined by maxtyp, then types ntypes+1 through maxtyp will not be generated. If ntypes is larger than
	     *            maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
	     * @param iseed input/output int[] of dimension 4. On entry, iseed specifies the seed of the random number
	     *            generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
	     *            Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence limited to
	     *            small integers, and so should produce machine independent random numbers. The values of iseed are
	     *            changed on exit, and can be used in the next call to ddrvsg to continue the same random number
	     *            sequence.
	     * @param thresh input double A test will count as "failed" if the "error", computed as described above, exceeds
	     *            thres. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple of 1,
	     *            e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double) or the size
	     *            of the matrix. It must be at least zero.
	     * @param A input/output double[][] of dimension lda by max(nn). Used to hold the matrix whose eigenvalues are to be
	     *            computed. On exit, A contains the last matrix actually used.
	     * @param lda input int The leading dimension of A and AB. It must be at least 1 and at least max(nn).
	     * @param B input/output double[][] of dimension ldb by max(nn). Used to hold the symmetric positive definite matrix
	     *            for the generalized problem. On exit, B contains the last matrix actually used.
	     * @param ldb input int The leading dimension of B and BB. It must be at least 1 and at least max(nn).
	     * @param D input/output double[] of dimension max(nn). The eigenvalues of A. On exit, the eigevalues in D must
	     *            correspond with the matrix in A.
	     * @param Z input/output double[][] of dimension ldz by max(nn). The matrix of eigenvectors.
	     * @param ldz input int The leading dimension of Z. It must be at least 1 and at least max(nn).
	     * @param AB workspace double[][] of dimension lda by max(nn).
	     * @param BB workspace double[][] of dimension ldb by max(nn).
	     * @param AP workspace double[] of dimension (max(nn)**2)
	     * @param BP workspace double[] of dimension (max(nn)**2)
	     * @param work workspace double[] of dimension nwork.
	     * @param nwork input int The number of entries in work. This must be at least 1 + 5*n + 2*n*lg(n) + 3*n**2 where n
	     *            = max(nn[j]) and lg(n) = smallest integer k such that 2**k >= n.
	     * @param iwork workspace int[] of dimension liwork.
	     * @param liwork input int The number of entries in iwork. This must be at least 6*n.
	     * @param result output double[] of dimension 70. The values computed by the tests described above.
	     * @param info output int[] If 0, then everything ran OK. -1: nsizes < 0 -2: Some nn[j] < 0 -3: ntypes < 0 -5:
	     *            thresh < 0 -9: lda < 1 or lda < nmax, where nmax is max(nn[j]). -16: ldz < 1 or ldz < nmax. -21: nwork
	     *            too small. -23: liwork too small. If dsygv returns an error code, the absolute value of it is
	     *            returned.
	     */
	    private void ddrvsg(final int nsizes, final int[] nn, final int ntypes, final boolean[] dotype, final int[] iseed,
	            final double thresh, final double[][] A, final int lda, final double[][] B, final int ldb,
	            final double[] D, final double[][] Z, final int ldz, final double[][] AB, final double[][] BB,
	            final double[] AP, final double[] BP, final double[] work, final int nwork, final int[] iwork,
	            final int liwork, final double[] result, final int[] info) {

	        // The number of types defined
	        final int maxtyp = 21;

	        // The number of tests that have been run on this matrix
	        int ntest;

	        // The total number of tests for this call.
	        int ntestt;

	        // Largest value in nn
	        int nmax;

	        // The number of matrices generated so far.
	        int nmats;

	        // The number of tests which have exceeded thresh so far (computed by
	        // dlafts).
	        final int[] nerrs = new int[1];

	        // Values to be passed to the matrix conditioners
	        int imode;
	        double cond;

	        // Norm of A; passed to the matrix generators.
	        double anorm;

	        // Overflow threshold
	        final double[] ovfl = new double[1];

	        // Underflow threshold
	        final double[] unfl = new double[1];

	        // Finest relative precision
	        double ulp;

	        // Inverse of finest relative precision
	        double ulpinv;

	        // Square root of ovfl
	        double rtovfl;

	        // Square root of unfl
	        double rtunfl;

	        // The folowing three arrays decode jtype:
	        // The general type (1-10) for type "j"
	        final int[] ktype = new int[] {1, 2, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 8, 8, 8, 9, 9, 9, 9, 9, 9};

	        // The mode value to be passed to the matrix generator for type "j".
	        final int[] kmode = new int[] {0, 0, 4, 3, 1, 4, 4, 4, 3, 1, 4, 4, 0, 0, 0, 4, 4, 4, 4, 4, 4};

	        // The order of magnitude (O(1), O(overflow^(1/2)), O(underflow^(1/2))
	        final int[] kmagn = new int[] {1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 1, 2, 3, 1, 1, 1, 1, 1, 1};
	        boolean badnn;
	        int i;
	        final int[] iseed2 = new int[4];
	        double aninv;
	        int jsize;
	        int n;
	        int mtypes;
	        int jtype;
	        int ka9;
	        int kb9;
	        final int[] ioldsd = new int[4];
	        int itype = 1;
	        final int[] iinfo = new int[1];
	        int ka;
	        int kb = 0;
	        int jcol;
	        int il;
	        int iu;
	        int itemp;
	        int ibtype;
	        int ibuplo;
	        char uplo;
	        int j;
	        double[] work2;
	        double[] work3;
	        final int[] idumma = new int[1];
	        final double[] resultBuf = new double[1];
	        final String dsgString = new String("DSG");

	        // Check for errors
	        ntestt = 0;
	        info[0] = 0;

	        badnn = false;
	        nmax = 0;

	        for (j = 0; j < nsizes; j++) {
	            nmax = Math.max(nmax, nn[j]);

	            if (nn[j] < 0) {
	                badnn = true;
	            }
	        } // for (j = 0; j < nsizes; j++)

	        if (nsizes < 0) {
	            info[0] = -1;
	        } else if (badnn) {
	            info[0] = -2;
	        } else if (ntypes < 0) {
	            info[0] = -3;
	        } else if ( (lda <= 1) || (lda < nmax)) {
	            info[0] = -9;
	        } else if ( (ldz <= 1) || (ldz < nmax)) {
	            info[0] = -16;
	        } else if ( (2 * Math.max(nmax, 3) * Math.max(nmax, 3)) > nwork) {
	            info[0] = -21;
	        } else if ( (2 * Math.max(nmax, 3) * Math.max(nmax, 3)) > liwork) {
	            info[0] = -23;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error ddrvsg had info = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (nsizes == 0) || (ntypes == 0)) {
	            return;
	        }

	        unfl[0] = dlamch('S');
	        ovfl[0] = dlamch('O');
	        dlabad(unfl, ovfl);
	        ulp = dlamch('E') * dlamch('B');
	        ulpinv = 1.0 / ulp;
	        rtunfl = Math.sqrt(unfl[0]);
	        rtovfl = Math.sqrt(ovfl[0]);

	        for (i = 0; i < 4; i++) {
	            iseed2[i] = iseed[i];
	        }

	        // Loop over sizes, types
	        nerrs[0] = 0;
	        nmats = 0;

	        for (jsize = 1; jsize <= nsizes; jsize++) {
	            n = nn[jsize - 1];
	            work2 = new double[n];
	            work3 = new double[n];
	            aninv = 1.0 / Math.max(1, n);

	            if (nsizes != 1) {
	                mtypes = Math.min(maxtyp, ntypes);
	            } else {
	                mtypes = Math.min(maxtyp + 1, ntypes);
	            }

	            ka9 = 0;
	            kb9 = 0;

	            for (jtype = 1; jtype <= mtypes; jtype++) {

	                if ( !dotype[jtype - 1]) {
	                    continue;
	                }

	                nmats = nmats + 1;
	                ntest = 0;

	                for (j = 0; j < 4; j++) {
	                    ioldsd[j] = iseed[j];
	                }

	                // Compute "A"

	                // Control parameters:

	                // KMAGN KMODE KTYPE
	                // = 1 O(1) clustered 1 zero
	                // = 2 large clustered 2 identity
	                // = 3 small exponential (none)
	                // = 4 arithmetic diagonal, w/ eigenvalues
	                // = 5 random log hermitian, w/ eigenvalues
	                // = 6 random (none)
	                // = 7 random diagonal
	                // = 8 random hermitian
	                // = 9 banded, w/ eigenvalues

	                if (mtypes <= maxtyp) {
	                    itype = ktype[jtype - 1];
	                    imode = kmode[jtype - 1];

	                    // Compute norm
	                    switch (kmagn[jtype - 1]) {

	                        case 1:
	                            anorm = 1.0;
	                            break;

	                        case 2:
	                            anorm = (rtovfl * ulp) * aninv;
	                            break;

	                        case 3:
	                            anorm = rtunfl * n * ulpinv;
	                            break;

	                        default: // Should never happen
	                            anorm = 1.0;
	                    } // switch(kmagn[jtype-1]

	                    iinfo[0] = 0;
	                    cond = ulpinv;

	                    // Special Matrices -- Identity & Jordan block

	                    if (itype == 1) {

	                        // Zero
	                        ka = 0;
	                        kb = 0;
	                        dlaset('F', lda, n, 0.0, 0.0, A, lda);
	                    } // if (itype == 1)
	                    else if (itype == 2) {
	                        // Identity

	                        ka = 0;
	                        kb = 0;
	                        dlaset('F', lda, n, 0.0, 0.0, A, lda);

	                        for (jcol = 0; jcol < n; jcol++) {
	                            A[jcol][jcol] = anorm;
	                        }
	                    } // else if (itype == 2)
	                    else if (itype == 4) {
	                        // Diagonal Matrix, [Eigen]values Specified

	                        ka = 0;
	                        kb = 0;
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, 0, 0, 'N', A, lda, work2, iinfo);

	                        for (i = 0; i < n; i++) {
	                            work[i + n] = work2[i];
	                        }
	                    } // else if (itype == 4)
	                    else if (itype == 5) {
	                        // Symmetric, eigenvalues specified

	                        ka = Math.max(0, n - 1);
	                        kb = ka;
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);

	                        for (i = 0; i < n; i++) {
	                            work[i + n] = work2[i];
	                        }
	                    } // else if (itype == 5)
	                    else if (itype == 7) {
	                        // Diagonal, random eigenvalues

	                        ka = 0;
	                        kb = 0;
	                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
	                                idumma, 0, 0, 0.0, anorm, 'N', A, lda, iwork, iinfo);

	                        for (i = 0; i < n; i++) {
	                            work[i + n] = work2[i];
	                            work[i + (2 * n)] = work3[i];
	                        }
	                    } // else if (itype == 7)
	                    else if (itype == 8) {
	                        // Symmetric, random eigenvalues

	                        ka = Math.max(0, n - 1);
	                        kb = ka;
	                        dlatmr(n, n, 'S', iseed, 'H', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
	                                idumma, n, n, 0.0, anorm, 'N', A, lda, iwork, iinfo);

	                        for (i = 0; i < n; i++) {
	                            work[i + n] = work2[i];
	                            work[i + (2 * n)] = work3[i];
	                        }
	                    } // else if (itype == 8)
	                    else if (itype == 9) {
	                        // Symmetric banded, eigenvalues specified

	                        // The following values are used for the half-bandwidths.

	                        // ka = 1 kb = 1
	                        // ka = 2 kb = 1
	                        // ka = 2 kb = 2
	                        // ka = 3 kb = 1
	                        // ka = 3 kb = 2
	                        // ka = 3 kb = 3

	                        kb9 = kb9 + 1;

	                        if (kb9 > ka9) {
	                            ka9 = ka9 + 1;
	                            kb9 = 1;
	                        } // if (kb9 > ka9)

	                        ka = Math.max(0, Math.min(n - 1, ka9));
	                        kb = Math.max(0, Math.min(n - 1, kb9));
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, ka, ka, 'N', A, lda, work2, iinfo);

	                        for (i = 0; i < n; i++) {
	                            work[i + n] = work2[i];
	                        }
	                    } // else if (itype == 9)
	                    else {
	                        iinfo[0] = 1;
	                    }

	                    if (iinfo[0] != 0) {
	                        System.out.println("ddrvsg generator returned iinfo = " + iinfo[0] + " n = " + n + " jtype = "
	                                + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + " ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + " ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        return;
	                    } // if (iinfo[0] != 0)
	                } // if (mtypes <= maxtyp)

	                if (n <= 1) {
	                    il = 1;
	                    iu = n;
	                } // if (n <= 1)
	                else { // n > 1
	                    il = (int) (1 + ( (n - 1) * dlarnd(1, iseed2)));
	                    iu = (int) (1 + ( (n - 1) * dlarnd(1, iseed2)));

	                    if (il > iu) {
	                        itemp = il;
	                        il = iu;
	                        iu = itemp;
	                    } // if (il > iu)
	                } // else n > 1

	                // Call dsygv, do tests

	                // Loop over three generalized problems
	                // ibtype = 1: A*x = (lambda)*B*x
	                // ibtype = 2: A*B*x = (lambda)*x
	                // ibtype = 3: B*A*x = (lambda)*x

	                for (ibtype = 1; ibtype <= 3; ibtype++) {

	                    // Loop over the setting uplo
	                    for (ibuplo = 1; ibuplo <= 2; ibuplo++) {

	                        if (ibuplo == 1) {
	                            uplo = 'U';
	                        } else {
	                            uplo = 'L';
	                        }

	                        // Generate random well-conditioned positive definite matrix B,
	                        // of bandwidth not greater than that of A.

	                        dlatms(n, n, 'U', iseed, 'P', work, 5, 10.0, 1.0, kb, kb, uplo, B, ldb, work2, iinfo);

	                        if (iinfo[0] != 0) {
	                            System.out.println("On call to create B ddrvsg generator returned iinfo = " + iinfo[0]
	                                    + "ibtype = " + ibtype + " n = " + n + " jtype = " + jtype + "\n");
	                            System.out.println("ioldsd[0] = " + ioldsd[0] + " ioldsd[1] = " + ioldsd[1] + "\n");
	                            System.out.println("ioldsd[2] = " + ioldsd[2] + " ioldsd[3] = " + ioldsd[3] + "\n");
	                            info[0] = Math.abs(iinfo[0]);

	                            return;
	                        }

	                        for (i = 0; i < n; i++) {
	                            work[i + n] = work2[i];
	                        }

	                        // Test dsygv

	                        ntest = ntest + 1;

	                        dlacpy(' ', n, n, A, lda, Z, ldz);
	                        dlacpy(uplo, n, n, B, ldb, BB, ldb);

	                        dsygv(ibtype, 'V', uplo, n, Z, ldz, BB, ldb, D, work, nwork, iinfo);

	                        if (iinfo[0] != 0) {
	                            System.out.println("dsygv V uplo = " + uplo + " iinfo[0] = " + iinfo[0] + " n = " + n + "\n");
	                            System.out.println("jtype = " + jtype + " ioldsd[0] = " + ioldsd[0] + "\n");
	                            System.out.println("ioldsd[1] = " + ioldsd[1] + " ioldsd[2] = " + ioldsd[2] + " ioldsd[3] = "
	                                    + ioldsd[3] + "\n");
	                            info[0] = Math.abs(iinfo[0]);

	                            if (iinfo[0] < 0) {
	                                return;
	                            } else {
	                                result[ntest - 1] = ulpinv;
	                            }
	                        } // if (iinfo[0] != 0)
	                        else {

	                            // Do Test
	                            dsgt01(ibtype, uplo, n, n, A, lda, B, ldb, Z, ldz, D, work, resultBuf);
	                            result[ntest - 1] = resultBuf[0];
	                        }
	                    } // for (ibuplo = 1; ibuplo <= 2; ibuplo++)
	                } // for (ibtype = 1; ibtype <= 3; ibtype++)

	                // End of loop - Check for result[j] > thresh
	                ntestt = ntestt + ntest;
	                dlafts(dsgString, n, n, jtype, ntest, result, ioldsd, thresh, nerrs);
	            } // for (jtype = 1; jtype <= mtypes; jtype++)
	        } // for (jsize = 1; jsize <= nsizes; jsize++)

	        // Summary
	        if (nerrs[0] > 0) {
	            System.out.println("dsygv: " + nerrs[0] + " out of " + ntestt + " tests failed to pass the threshold\n");
	        } else {
	            System.out.println("All " + ntestt + " tests for dsygv passed the threshold\n");
	        }
	    } // ddrvsg

	    /**
	     * This is a port of the part of version 3.1 LAPACK test routine DDRVST used to test dsyev. Original DDRVST created
	     * by Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006 ddrvst checks the symmetric
	     * eigenvalue problem driver dsyev. dsyev computes all eigenvalues and, optionally, eigenvectors of a real symmetric
	     * matrix.
	     * 
	     * <p>
	     * When ddrvst is called, a number of matrix "sizes" ("n's") and a number of matrix "types" are specified. For each
	     * size ("n") and each type of matrix, one matrix will be generated and used to test the dsyev driver. For each
	     * matrix, the following tests will be performed: (1) | A - Z D Z' | / ( |A| n ulp ) (2) | I - Z Z' | / ( n ulp )
	     * (3) | D1 - D2 | / ( |D1| ulp ) where Z is the matrix of eigenvectors returned when the eigenvector option is
	     * given and D1 and D2 are the eigenvalues returned with and without the eigenvector option.
	     * </p>
	     * 
	     * <p>
	     * The "sizes" are specified by an array nn(0:nsizes-1); the value of each element nn[j] specifies one size. The
	     * "types" are specified by a boolean array dotype(0:ntypes-1); if dotype[j] is true, then matrix type "j" will be
	     * generated. Currently, the list of possible types is: (1) The zero matrix. (2) The identity matrix. (3) A diagonal
	     * matrix with evenly spaced eigenvalues 1, ..., ulp and random signs. (ulp = (first number larger than 1) - 1) (4)
	     * A diagonal matrix with geometrically spaced eigenvalues 1, ..., ulp and random signs. (5) A diagonal matrix with
	     * "clustered" eigenvalues 1, ulp, ..., ulp and random signs. (6) Same as (4), but multiplied by sqrt(overflow
	     * threshold) (7) Same as (4), but multiplied by sqrt(underflow threshold) (8) A matrix of the form U' D U, where U
	     * is orthogonal and D has evenly spaced entries 1, ..., ulp with random signs on the diagonal. (9) A matrix of the
	     * form U' D U, where U is orthogonal and D has geometrically spaced entries 1, ..., ulp with random signs on the
	     * diagonal. (10) A matrix of the form U' D U, where U is orthogonal and D has "clustered" entries 1, ulp, ..., ulp
	     * with random signs on the diagonal. (11) Same as (8), but multiplied by sqrt( overflow threshold) (12) Same as
	     * (8), but multiplied by sqrt( underflow threshold) (13) Symmetric matrix with random entries chosen from (-1,1).
	     * (14) Same as (13), but multiplied by sqrt( overflow threshold) (15) Same as (13), but multiplied by
	     * sqrt(underflow threshold) (16) A band matrix with half bandwidth randomly chosen between 0 and n-1, with evenly
	     * spaced eigenvalues 1, ..., ulp with random signs. (17) Same as (16), but multiplied by sqrt(overflow threshold)
	     * (18) Same as (16), but multiplied by sqrt(underflow threshold)
	     * </p>
	     * 
	     * <p>
	     * The tests performed are: (1) | A - U S U' | / ( |A| n ulp ) dsyev('L', 'V', ... ) (2) | I - U U' | / ( n ulp )
	     * dsyev('L', 'V', ... ) (3) |D(with Z) - D(w/o Z)| / (|D| ulp) dsyev('L', 'N', ... ) Tests 1 through 3 are repeated
	     * with uplo = 'U'
	     * </p>
	     * 
	     * @param nsizes (input) int The number of sizes of matrices to use. If it is zero, ddrvst does nothing. It must be
	     *            at least zero.
	     * @param nn (input) int[] of dimension (nsizes) An array containing the sizes to be used for the matrices. Zero
	     *            values will be skipped. The values must be at least zero.
	     * @param ntypes (input) int The number of elements in dotype. If it is zero, ddrvst does nothing. It must be at
	     *            least zero. If it is maxtyp+1 and nsizes is 1, then an additional type, maxtyp+1 is defined, which is
	     *            to use whatever matrix is in A. This is only useful if dotype(0:maxtyp-1) is false and dotype[maxtyp]
	     *            is true.
	     * @param dotype (input) boolean[] of dimension (ntypes) If dotype[j] is true, then for each size in nn a matrix of
	     *            that size and of type j will be generated. If ntypes is smaller than the maximum number of types
	     *            defined (parameter maxtyp), then types ntypes+1 through maxtyp will not be generated. If ntypes is
	     *            larger than maxtyp, dotype[maxtyp] through dotype[ntypes-1] will be ignored.
	     * @param iseed (input/output) int[] of dimension (4) On entry iseed specifies the seed of the random number
	     *            generator. The array elements should be between 0 and 4095; if not they will be reduced mod 4096.
	     *            Also, iseed[3] must be odd. The random number generator uses a linear congruential sequence limited
	     *            to small integers, and so should produce machine independent random numbers. The values of iseed are
	     *            changed on exit, and can be used in the next call to ddrvst to continue the same random number
	     *            sequence.
	     * @param thresh (input) double A test will count as "failed" if the "error", computed as described above, exceeds
	     *            thresh. Note that the error is scaled to be O(1), so thresh should be a reasonably small multiple of
	     *            1, e.g., 10 or 100. In particular, it should not depend on the precision (single vs. double) or the
	     *            size of the matrix. It must be at least zero.
	     * @param A (input/workspace/output) double[][] of dimension (lda, max(nn)) Used to hold the matrix whose
	     *            eigenvalues are to be computed. On exit, A contains the last matrix actually used.
	     * @param lda (input) int The leading dimension of A. It must be at least 1 and at least max(nn).
	     * @param D1 (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr
	     *            simultaneously with Z. On exit, the eigenvalues in D1 correspond with the matrix in A.
	     * @param D2 (workspace/output) double[] of dimension (max(nn)) The eigenvalues of A, as computed by dsteqr if Z is
	     *            not computed. On exit, the eigenvalues in D2 correspond with the matrix in A.
	     * @param D3 (workspace/output) double[] of dimension max(nn)) The eigenvalues of A, as computed by dsterf. On exit,
	     *            the eigenvalues in D3 correspond with the matrix in A.
	     * @param D4 double[] of dimension (max(nn))
	     * @param eveigs double[] of dimension (max(nn)) The eigenvalues as computed by dstev('N', ... )
	     * @param WA1 double[]
	     * @param WA2 double[]
	     * @param WA3 double[]
	     * @param U (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix computed by dsytrd +
	     *            dorgtr.
	     * @param ldu (input) int The leading dimension of U, Z and V. It must be at least 1 and at least max(nn).
	     * @param V (workspace/output) double[][] of dimension (ldu, max(nn)) The Householder vectors computed by dsytrd in
	     *            reducing A to tridiagonal form.
	     * @param tau (workspace/output) double[] of dimension max(nn) The Householder factors computed by dsytrd in
	     *            reducing A to tridiagonal form.
	     * @param Z (workspace/output) double[][] of dimension (ldu, max(nn)) The orthogonal matrix of eigenvectors computed
	     *            by dsteqr.
	     * @param work (workspace/output) double[] of dimension (lwork)
	     * @param lwork (input) int The number of entries in work. This must be at least 1 + 4*nmax + 2 * nmax * lg nmax + 4
	     *            * nmax**2 where nmax = max(nn[j], 2) and lg = log base 2.
	     * @param iwork workspace int[] of dim (6 + 6*nmax + 5* nmax * lg nmax) where nmax = max(nn[j], 2) and lg = log base
	     *            2.
	     * @param liwork (input) int length of iwork
	     * @param result (output) double[] of dimension (105) The values computed by the tests described above. The values
	     *            are currently limited to 1/ulp, to avoid overflow.
	     * @param info (output) int[] If 0, then everything ran OK. -1: nsizes < 0 -2: Some nn[j] < 0 -3: ntypes < 0 -5:
	     *            thresh < 0 -9: lda < 1 or lda < nmax, where nmax is max(nn[j]) -16: ldu < 1 or ldu < nmax -21: lwork
	     *            too small. If dlatmr, dlatms, dsytrd, dorgtr, dsteqr, dsterf, or dormtr returns an error code, the
	     *            absolute value of it is returned.
	     */
	    private void ddrvst(final int nsizes, final int[] nn, final int ntypes, final boolean[] dotype, final int[] iseed,
	            final double thresh, final double[][] A, final int lda, final double[] D1, final double[] D2,
	            final double[] D3, final double[] D4, final double[] eveigs, final double[] WA1, final double[] WA2,
	            final double[] WA3, final double[][] U, final int ldu, final double[][] V, final double[] tau,
	            final double[][] Z, final double[] work, final int lwork, final int[] iwork, final int liwork,
	            final double[] result, final int[] info) {
	        final int maxtyp = 18; // The number of types defined
	        boolean badnn;
	        char uplo;
	        int i;
	        int idiag;
	        int ihbw;
	        final int[] iinfo = new int[1];
	        int iL;
	        int imode; // Value to be passed to the matrix generators
	        int irow;
	        int itemp;
	        int itype;
	        int iu;
	        int iuplo;
	        int j;
	        int j1;
	        int j2;
	        int jcol;
	        int jsize;
	        int jtype;
	        int lgn;
	        int mtypes;
	        int n;
	        final int[] nerrs = new int[1]; // The number of tests which have exceeded thresh
	        // so far (computed by dlafts).
	        int nmats; // The number of matrices generated so far.
	        int nmax; // Largest value in nn.
	        int ntest; // The number of tests performed, or which can
	        // be performed so far, for the current matrix
	        int ntestt; // The total number of tests performed so far.
	        double aninv;
	        double anorm; // Norm of A; passed to the matrix generators.
	        double cond; // Value to be passed to the matrix generators.
	        final double[] ovfl = new double[1]; // Overflow threshold
	        double rtovfl; // Square root of overflow threshold
	        double rtunfl; // Square root of underflow threshold
	        double temp1;
	        double temp2;
	        double ulp; // Finest relative precision
	        double ulpinv; // Inverse of finest relative precision
	        final double[] unfl = new double[1]; // Underflow threshold
	        final int[] idumma = new int[1];
	        final int[] ioldsd = new int[4];
	        final int[] iseed2 = new int[4];
	        final int[] iseed3 = new int[4];

	        // The order of magnitude (O(1), O(overflow^(1/2)), O(underflow^(1/2))
	        final int[] kmagn = new int[] {1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 1, 2, 3, 1, 2, 3};

	        // The mode value to be passed to the matrix generator for type "j".
	        final int[] kmode = new int[] {0, 0, 4, 3, 1, 4, 4, 4, 3, 1, 4, 4, 0, 0, 0, 4, 4, 4};

	        // The general type (1-10) for type "j".
	        final int[] ktype = new int[] {1, 2, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 8, 8, 8, 9, 9, 9};
	        double[] work2;
	        double[] work3;
	        final double[] res = new double[2];
	        String typeString;

	        // Check for errors
	        ntestt = 0;
	        info[0] = 0;

	        badnn = false;
	        nmax = 1;

	        for (j = 0; j < nsizes; j++) {
	            nmax = Math.max(nmax, nn[j]);

	            if (nn[j] < 0) {
	                badnn = true;
	            }
	        } // for (j = 0; j < nsizes; j++)

	        work2 = new double[3 * nmax];
	        work3 = new double[nmax];

	        if (nsizes < 0) {
	            info[0] = -1;
	        } else if (badnn) {
	            info[0] = -2;
	        } else if (ntypes < 0) {
	            info[0] = -3;
	        } else if (lda < nmax) {
	            info[0] = -9;
	        } else if (ldu < nmax) {
	            info[0] = -16;
	        } else if ( (2 * Math.max(2, nmax) * Math.max(2, nmax)) > lwork) {
	            info[0] = -21;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error ddrvst had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (nsizes == 0) || (ntypes == 0)) {
	            return;
	        }

	        unfl[0] = dlamch('S');
	        ovfl[0] = dlamch('O');
	        dlabad(unfl, ovfl);
	        ulp = dlamch('E') * dlamch('B');
	        ulpinv = 1.0 / ulp;
	        rtunfl = Math.sqrt(unfl[0]);
	        rtovfl = Math.sqrt(ovfl[0]);

	        // Loop over sizes, types
	        for (i = 0; i < 4; i++) {
	            iseed2[i] = iseed[i];
	            iseed3[i] = iseed[i];
	        }

	        nerrs[0] = 0;
	        nmats = 0;

	        for (jsize = 1; j <= nsizes; jsize++) {
	            n = nn[jsize - 1];

	            if (n > 0) {
	                lgn = (int) (Math.log((double) n) / Math.log(2.0));

	                if (Math.pow(2.0, lgn) < n) {
	                    lgn = lgn + 1;
	                }

	                if (Math.pow(2.0, lgn) < n) {
	                    lgn = lgn + 1;
	                }
	            } // if (n > 0)

	            aninv = 1.0 / (double) Math.max(1, n);

	            if (nsizes != 1) {
	                mtypes = Math.min(maxtyp, ntypes);
	            } else {
	                mtypes = Math.min(maxtyp + 1, ntypes);
	            }

	            for (jtype = 1; jtype <= mtypes; jtype++) {

	                if ( !dotype[jtype - 1]) {
	                    continue;
	                }

	                nmats = nmats + 1;
	                ntest = 0;

	                for (j = 0; j < 4; j++) {
	                    ioldsd[j] = iseed[j];
	                }

	             // Compute "A"
	                // Control parameters:
	                /*
	                 * kmagn kmode       ktype 
	           = 1     O(1)  clustered 1 zero 
	           = 2     large clustered 2 identity 
	           = 3     small exponential (none) 
	           = 4           arithmetic  diagonal, (w/ eigenvalues) 
	           = 5           random log  symmetric, w/ eigenvalues 
	           = 6           random      (none) 
	           = 7                       random diagonal 
	           = 8                       random symmetric 
	           = 9                       band symmetric, w/ eigenvalues
	                 */

	                if (mtypes <= maxtyp) {
	                    itype = ktype[jtype - 1];
	                    imode = kmode[jtype - 1];

	                    // Compute norm

	                    if (kmagn[jtype - 1] == 1) {
	                        anorm = 1.0;
	                    } else if (kmagn[jtype - 1] == 2) {
	                        anorm = (rtovfl * ulp) * aninv;
	                    } else {
	                        anorm = rtunfl * n * ulpinv;
	                    }

	                    dlaset('F', lda, n, 0.0, 0.0, A, lda);
	                    iinfo[0] = 0;
	                    cond = ulpinv;

	                    // Special Matrices -- Identity & Jordan block

	                    // Zero
	                    if (itype == 1) {
	                        iinfo[0] = 0;
	                    } else if (itype == 2) {

	                        // Identity
	                        for (jcol = 0; jcol < n; jcol++) {
	                            A[jcol][jcol] = anorm;
	                        }
	                    } else if (itype == 4) {

	                        // Diagonal Matrix, [Eigen]values, Specified
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, 0, 0, 'N', A, lda, work2, iinfo);
	                    } else if (itype == 5) {

	                        // Symmetric, eigenvalues specified
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, n, n, 'N', A, lda, work2, iinfo);
	                    } else if (itype == 7) {

	                        // Diagonal, random eigenvalues
	                        idumma[0] = 1;
	                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
	                                idumma, 0, 0, 0.0, anorm, 'N', A, lda, iwork, iinfo);
	                    } // else if (itype == 7)
	                    else if (itype == 8) {

	                        // Symmetric, random eigenvalues
	                        idumma[0] = 1;
	                        dlatmr(n, n, 'S', iseed, 'S', work, 6, 1.0, 1.0, 'T', 'N', work2, 1, 1.0, work3, 1, 1.0, 'N',
	                                idumma, n, n, 0.0, anorm, 'N', A, lda, iwork, iinfo);
	                    } // else if (itype == 8)
	                    else if (itype == 9) {

	                        // Symmetric banded, eigenvalues specified
	                        ihbw = (int) ( (n - 1) * dlarnd(1, iseed3));
	                        dlatms(n, n, 'S', iseed, 'S', work, imode, cond, anorm, ihbw, ihbw, 'Z', U, ldu, work2, iinfo);

	                        // Store as dense matrix for most routines
	                        dlaset('F', lda, n, 0.0, 0.0, A, lda);

	                        for (idiag = -ihbw; idiag <= ihbw; idiag++) {
	                            irow = ihbw - idiag + 1;
	                            j1 = Math.max(1, idiag + 1);
	                            j2 = Math.min(n, n + idiag);

	                            for (j = j1; j <= j2; j++) {
	                                i = j - idiag;
	                                A[i - 1][j - 1] = U[irow - 1][j - 1];
	                            }
	                        } // for (idiag = -ihbw; idiag <= ihbw; idiag++)
	                    } // else if (itype == 9)
	                    else {
	                        iinfo[0] = 1;
	                    } // else

	                    if (iinfo[0] != 0) {
	                        System.out.println("Generator iinfo[0] = " + iinfo[0] + "\n");
	                        System.out.println("n = " + n + "\n");
	                        System.out.println("jtype = " + jtype + "\n");
	                        System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                        System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                        System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                        System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                        info[0] = Math.abs(iinfo[0]);

	                        return;
	                    } // if (iinfo[0] != 0)

	                } // if (mtypes <= maxtyp)

	                if (n <= 1) {
	                    iL = 1;
	                    iu = n;
	                } else { // n > 1
	                    iL = 1 + ( (n - 1) * (int) (dlarnd(1, iseed2)));
	                    iu = 1 + ( (n - 1) * (int) (dlarnd(1, iseed2)));

	                    if (iL > iu) {
	                        itemp = iL;
	                        iL = iu;
	                        iu = itemp;
	                    }
	                } // else n > 1

	                // Test storing upper or lower triangular part of matrix.
	                for (iuplo = 0; iuplo <= 1; iuplo++) {

	                    if (iuplo == 0) {
	                        uplo = 'L';
	                        ntest = 1;
	                    } else {
	                        uplo = 'U';
	                        ntest = 4;
	                    }

	                    loop1: {
	                        dlacpy(' ', n, n, A, lda, V, ldu);
	                        dsyev('V', uplo, n, A, ldu, D1, work, lwork, iinfo);

	                        if (iinfo[0] != 0) {
	                            System.out.println("dsyev(V, " + uplo + " ) iinfo[0] = " + iinfo[0] + "\n");
	                            System.out.println("n = " + n + "\n");
	                            System.out.println("jtype = " + jtype + "\n");
	                            System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                            System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                            System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                            System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                            info[0] = Math.abs(iinfo[0]);

	                            if (iinfo[0] < 0) {
	                                return;
	                            } else {
	                                result[ntest - 1] = ulpinv;
	                                result[ntest] = ulpinv;
	                                result[ntest + 1] = ulpinv;

	                                break loop1;
	                            }
	                        } // if (iinfo[0] != 0)

	                        // Do tests 1 and 2 or 4 and 5
	                        dsyt21(1, uplo, n, 0, V, ldu, D1, D2, A, ldu, Z, ldu, tau, work, res);
	                        result[ntest - 1] = res[0];
	                        result[ntest] = res[1];

	                        dlacpy(' ', n, n, V, ldu, A, lda);

	                        ntest = ntest + 2;
	                        dsyev('N', uplo, n, A, ldu, D3, work, lwork, iinfo);

	                        if (iinfo[0] != 0) {
	                            System.out.println("dsyev(N, " + uplo + " ) iinfo[0] = " + iinfo[0] + "\n");
	                            System.out.println("n = " + n + "\n");
	                            System.out.println("jtype = " + jtype + "\n");
	                            System.out.println("ioldsd[0] = " + ioldsd[0] + "\n");
	                            System.out.println("ioldsd[1] = " + ioldsd[1] + "\n");
	                            System.out.println("ioldsd[2] = " + ioldsd[2] + "\n");
	                            System.out.println("ioldsd[3] = " + ioldsd[3] + "\n");
	                            info[0] = Math.abs(iinfo[0]);

	                            if (iinfo[0] < 0) {
	                                return;
	                            } else {
	                                result[ntest - 1] = ulpinv;

	                                break loop1;
	                            }
	                        } // if (iinfo[0] != 0)

	                        // Do test 3 or 6
	                        temp1 = 0.0;
	                        temp2 = 0.0;

	                        for (j = 0; j < n; j++) {
	                            temp1 = Math.max(temp1, Math.abs(D1[j]));
	                            temp1 = Math.max(temp1, Math.abs(D3[j]));
	                            temp2 = Math.max(temp2, Math.abs(D1[j] - D3[j]));
	                        } // for (j = 0; j < n; j++)

	                        result[ntest - 1] = temp2 / Math.max(unfl[0], ulp * Math.max(temp1, temp2));
	                    } // loop1
	                } // for (iuplo = 0; iuplo <= 1; iuplo++)

	                // End of Loop -- Check for result[j] > thresh
	                ntestt = ntestt + ntest;
	                typeString = new String("DST");
	                dlafts(typeString, n, n, jtype, ntest, result, ioldsd, thresh, nerrs);
	            } // for (jtype = 1; jtype <= mtypes; jtype++)
	        } // for (jsize = 1; j <= nsizes; jsize++)

	        // Summary
	        if (nerrs[0] > 0) {
	            System.out.println("ddrvst " + nerrs[0] + " out of " + ntestt + " tests failed to pass the threshold\n");
	        } else {
	            System.out.println("All " + ntestt + " tests for ddrvst passed the threshold\n");
	        }

	        return;

	    } // ddrvst

	    /**
	     * This is a port of the 2/8/89 Blas routine Original version written by: Jack Dongarra, Argonne National Laboratory
	     * Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms
	     * Group Ltd. dgemm performs one of the matrix-matrix operations C = alpha*op(A)*op(B) + beta*C, where op(X) is one
	     * of op(X) = X or op(X) = X', alpha and beta are scalars, and A, B, and C are matrices, with op(A) an m by k
	     * matrix, op(B) a k by n matrix, and C an m by n matrix.
	     * 
	     * @param transa input char On entry, transa specifies the form of op(A) to be used in the matrix multiplication as
	     *            follows:' = 'N' or 'n', op(A) = A. = 'T' or 't', op(A) = A'. = 'C' or 'c', op(A) = A'.
	     * @param transb input char On entry, transb specifies the form of op(B) to be used in the matrix multiplication as
	     *            follows: = 'N' or 'n', op(B) = B. = 'T' or 't', op(B) = B'. = 'C' or 'c', op(B) = B'.
	     * @param m input int On entry, m specifies the number of rows of the matrix op(A) and of the matrix C. m must be at
	     *            least zero.
	     * @param n input int On entry, n specifies the number of columns of the matrix op(B) and the number of columns of
	     *            the matrix C. n must be at least zero.
	     * @param k input int On entry, k specifies the number of columns of the matrix op(A) and the number of rows of the
	     *            matrix op(B). k must be at least zero.
	     * @param alpha input double specified scalar
	     * @param A input double[][] dimension lda by ka, where ka is k when transa = 'N' or 'n', and is m otherwise. Before
	     *            entry with transa = 'N' or 'n', the leading m by k part of the array A must contain the matrix A,
	     *            otherwise the leading k by m part of the array A must contain the matrix A
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            When transa = 'N' or 'n' then lda must be at least max(1,m), otherwise lda must be at least max(1,k)
	     * @param B input double[][] dimension ldb by kb, where kb is n when transb = 'N' or 'n', and is k otherwise. Before
	     *            entry with transb = 'N' or 'n', the leading k by n part of the array B must contain the matrix B,
	     *            otherwise the leading n by k part of the array B must contain the matrix B
	     * @param ldb input int On entry, ldb specifies the first dimension of B as declared in the calling (sub) program.
	     *            When transb = 'N' or 'n' then ldb must be at least max(1,k), otherwise ldb must be at least max(1,n).
	     * @param beta input double specified scalar When beta is supplied as zero, then C need not be set on input.
	     * @param C input/output double[][] dimension ldc by n. Before entry, the leading m by n part of the array C must
	     *            contain the matrix C, except when beta is zero, in which case C need not be set on entry. On exit, the
	     *            array C is overwritten by the m by n matrix (alpha*op(A)*op(B) + beta*C).
	     * @param ldc input int On entry, ldc specifies the first dimension of C as declared in the calling (sub) program.
	     *            ldc must be at least max(1,m).
	     */
	    private void dgemm(final char transa, final char transb, final int m, final int n, final int k, final double alpha,
	            final double[][] A, final int lda, final double[][] B, final int ldb, final double beta,
	            final double[][] C, final int ldc) {
	        boolean nota;
	        boolean notb;
	        int i;
	        int info;
	        int j;
	        int L;
	        int nrowa;
	        int nrowb;
	        double temp;

	        // Set nota and notb as true if A and B respectively are not transposed
	        // and set nrowa and nrowb as the number of rows of A
	        // and the number of rows of B respectively.

	        if ( (transa == 'N') || (transa == 'n')) {
	            nota = true;
	        } else {
	            nota = false;
	        }

	        if ( (transb == 'N') || (transb == 'n')) {
	            notb = true;
	        } else {
	            notb = false;
	        }

	        if (nota) {
	            nrowa = m;
	        } else {
	            nrowa = k;
	        }

	        if (notb) {
	            nrowb = k;
	        } else {
	            nrowb = n;
	        }

	        // Test the input parameters
	        info = 0;

	        if ( ( !nota) && (transa != 'C') && (transa != 'c') && (transa != 'T') && (transa != 't')) {
	            info = 1;
	        } else if ( ( !notb) && (transb != 'C') && (transb != 'c') && (transb != 'T') && (transb != 't')) {
	            info = 2;
	        } else if (m < 0) {
	            info = 3;
	        } else if (n < 0) {
	            info = 4;
	        } else if (k < 0) {
	            info = 5;
	        } else if (lda < Math.max(1, nrowa)) {
	            info = 8;
	        } else if (ldb < Math.max(1, nrowb)) {
	            info = 10;
	        } else if (ldc < Math.max(1, m)) {
	            info = 13;
	        }

	        if (info != 0) {
	            System.err.println("Error dgemm has info = " + info);

	            return;
	        } // if (info != 0)

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || ( ( (alpha == 0.0) || (k == 0)) && (beta == 1.0))) {
	            return;
	        }

	        if (alpha == 0.0) {

	            if (beta == 0.0) {

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = 0.0;
	                    }
	                }
	            } // if (beta == 0.0)
	            else { // beta != 0.0

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = beta * C[i][j];
	                    }
	                }
	            } // else beta != 0.0

	            return;
	        } // if (alpha == 0.0)

	        if (notb) {

	            if (nota) {

	                // Form C = alpha*A*B + beta*C.
	                for (j = 0; j < n; j++) {

	                    if (beta == 0.0) {

	                        for (i = 0; i < m; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    } // if (beta == 0.0)
	                    else if (beta != 1.0) {

	                        for (i = 0; i < m; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    } // else if (beta != 1.0)

	                    for (L = 0; L < k; L++) {

	                        if (B[L][j] != 0.0) {
	                            temp = alpha * B[L][j];

	                            for (i = 0; i < m; i++) {
	                                C[i][j] = C[i][j] + (temp * A[i][L]);
	                            }
	                        } // if (B[L][j] != 0.0)
	                    } // for (L = 0; L < k; L++)
	                } // for (j = 0; j < n; j++)
	            } // if (nota)
	            else { // !nota

	                // Form C = alpha*A'*B + beta*C
	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        temp = 0.0;

	                        for (L = 0; L < k; L++) {
	                            temp = temp + (A[L][i] * B[L][j]);
	                        }

	                        if (beta == 0.0) {
	                            C[i][j] = alpha * temp;
	                        } else {
	                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
	                        }
	                    } // for (i = 0; i < m; i++)
	                } // for (j = 0; j < n; j++)
	            } // else !nota
	        } // if (notb)
	        else { // !notb

	            if (nota) {

	                // Form C = alpha*A*B' + beta*C
	                for (j = 0; j < n; j++) {

	                    if (beta == 0.0) {

	                        for (i = 0; i < m; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    } // if (beta == 0.0)
	                    else if (beta != 1.0) {

	                        for (i = 0; i < m; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    } // else if (beta != 1.0)

	                    for (L = 0; L < k; L++) {

	                        if (B[j][L] != 0.0) {
	                            temp = alpha * B[j][L];

	                            for (i = 0; i < m; i++) {
	                                C[i][j] = C[i][j] + (temp * A[i][L]);
	                            }
	                        } // if (B[j][L] != 0.0)
	                    } // for (L = 0; L < k; L++)
	                } // for (j = 0; j < n; j++)
	            } // if (nota)
	            else { // !nota

	                // Form C = alpha*A'*B' + beta*C
	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        temp = 0.0;

	                        for (L = 0; L < k; L++) {
	                            temp = temp + (A[L][i] * B[j][L]);
	                        }

	                        if (beta == 0.0) {
	                            C[i][j] = alpha * temp;
	                        } else {
	                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
	                        }
	                    } // for (i = 0; i < m; i++)
	                } // for (j = 0; j < n; j++)
	            } // else !nota
	        } // else !notb

	        return;
	    } // dgemm

	    /**
	     * Routine ported from 10/22/86 blas dgemv subroutine Original version written by: Jack Dongarra, Argonne National
	     * Lab. Jeremy Du Croz, Nag Central Office Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National
	     * Labs. dgemv performs one of the matrix-vector operations y = alpha*A*x + beta*y, or y = alpha*A'*x + beta*y,
	     * where alpha and beta are scalars, x and y are vectors, and A is an m by n matrix
	     * 
	     * @param trans input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n' y =
	     *            alpha*A*x + beta*y = 'T' or 't' y = alpha*A'*x + beta*y = 'C' or 'c' y = alpha*A'*x + beta*y
	     * @param m input int On entry, m specifies the mumber of rows of matrix A. m must be at least zero.
	     * @param n input int On entry, n specifies the number of columns of matrix A. n must be at least zero.
	     * @param alpha input double specified scalar
	     * @param A input double[][] dimension lda by n Before entry, the leading m by n part of the array A must contain
	     *            the matrix of coefficients.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1, m).
	     * @param x input double[] array of dimension at least (1 + (n-1)*abs(incx)) when trans = 'N' or 'n' and at least (1
	     *            + (m-1)*abs(incx)) otherwise. Before entry, the incremented array x must contain the vector x.
	     * @param incx input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     * @param beta input double specified scalar When beta is supplied as zero, then y need not be set on input.
	     * @param y input/output double[] array of dimension at least (1 + (m-1)*abs(incy)) when trans = 'N' or 'n' and at
	     *            least (1 + (n-1)*abs(incy)) otherwise. Before entry with beta non-zero, the incremented array y must
	     *            contain the vector y. On exit, array y is overwritten with the updated vector y.
	     * @param incy input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
	     */
	    private void dgemv(final char trans, final int m, final int n, final double alpha, final double[][] A,
	            final int lda, final double[] x, final int incx, final double beta, final double[] y, final int incy) {
	        int info;
	        int lenx;
	        int leny;
	        int kx;
	        int ky;
	        int i;
	        int iy;
	        int jx;
	        int j;
	        int jy;
	        int ix;
	        double temp;

	        // Test the input parameters
	        info = 0;

	        if ( (trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C') && (trans != 'c')) {
	            info = 1;
	        } else if (m < 0) {
	            info = 2;
	        } else if (n < 0) {
	            info = 3;
	        } else if (lda < Math.max(1, m)) {
	            info = 6;
	        } else if (incx == 0) {
	            info = 8;
	        } else if (incy == 0) {
	            info = 11;
	        }

	        if (info != 0) {
	            System.err.println("Error dgemv has info = " + info);

	            return;
	        } // if (info != 0)

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || ( (alpha == 0.0) && (beta == 1.0))) {
	            return;
	        }

	        // Set lenx and leny, the lengths of vectors x and y, and set up the
	        // start points in arrays x and y.

	        if ( (trans == 'N') || (trans == 'n')) {
	            lenx = n;
	            leny = m;
	        } else {
	            lenx = m;
	            leny = n;
	        }

	        if (incx > 0) {
	            kx = 1;
	        } else {
	            kx = 1 - ( (lenx - 1) * incx);
	        }

	        if (incy > 0) {
	            ky = 1;
	        } else {
	            ky = 1 - ( (leny - 1) * incy);
	        }

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through A.
	        // First form y = beta*y.
	        if (beta != 1.0) {

	            if (incy == 1) {

	                if (beta == 0.0) {

	                    for (i = 0; i < leny; i++) {
	                        y[i] = 0.0;
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (i = 0; i < leny; i++) {
	                        y[i] = beta * y[i];
	                    }
	                } // else beta != 0.0
	            } // if (incy == 1)
	            else { // incy != 1
	                iy = ky - 1;

	                if (beta == 0.0) {

	                    for (i = 1; i <= leny; i++) {
	                        y[iy] = 0.0;
	                        iy = iy + incy;
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (i = 1; i <= leny; i++) {
	                        y[iy] = beta * y[iy];
	                        iy = iy + incy;
	                    }
	                } // else beta != 0.0
	            } // else incy != 1
	        } // if (beta != 1.0)

	        if (alpha == 0.0) {
	            return;
	        }

	        if ( (trans == 'N') || (trans == 'n')) {

	            // Form y = alpha*A*x + y.
	            jx = kx - 1;

	            if (incy == 1) {

	                for (j = 0; j < n; j++) {

	                    if (x[jx] != 0.0) {
	                        temp = alpha * x[jx];

	                        for (i = 0; i < m; i++) {
	                            y[i] = y[i] + (temp * A[i][j]);
	                        } // for (i = 0; i < m; i++)
	                    } // if (x[jx] != 0.0)

	                    jx = jx + incx;
	                } // for (j = 0; j < n; j++)
	            } // if (incy == 1)
	            else { // incy != 1

	                for (j = 0; j < n; j++) {

	                    if (x[jx] != 0.0) {
	                        temp = alpha * x[jx];
	                        iy = ky - 1;

	                        for (i = 0; i < m; i++) {
	                            y[iy] = y[iy] + (temp * A[i][j]);
	                            iy = iy + incy;
	                        } // for (i = 0; i < m; i++)
	                    } // if (x[jx] != 0.0)

	                    jx = jx + incx;
	                } // for (j = 0; j < n; j++)
	            } // else incy != 1
	        } // if (trans == 'N') || (trans == 'n'))
	        else { // trans != 'N' && trans != 'n'

	            // Form y = alpha*A'*x + y.
	            jy = ky - 1;

	            if (incx == 1) {

	                for (j = 0; j < n; j++) {
	                    temp = 0.0;

	                    for (i = 0; i < m; i++) {
	                        temp = temp + (A[i][j] * x[i]);
	                    } // for (i = 0; i < m; i++)

	                    y[jy] = y[jy] + (alpha * temp);
	                    jy = jy + incy;
	                } // for (j = 0; j < n; j++)
	            } // if (incx == 1)
	            else { // incx != 1

	                for (j = 0; j < n; j++) {
	                    temp = 0.0;
	                    ix = kx - 1;

	                    for (i = 0; i < m; i++) {
	                        temp = temp + (A[i][j] * x[ix]);
	                        ix = ix + incx;
	                    } // for (i = 0; i < m; i++)

	                    y[jy] = y[jy] + (alpha * temp);
	                    jy = jy + incy;
	                } // for (j = 0; j < n; j++)
	            } // else incx != 1
	        } // else trans != 'N' && trans != 'n'

	        return;
	    } // dgemv

	    /**
	     * This is a port of version 3.1 LAPACK test routine DGENND. Univ. of Tennessee, Univ. of California Berkeley and
	     * NAG Ltd.. February 2008
	     * 
	     * .. Scalar Arguments .. INTEGER M, N, LDA .. .. Array Arguments .. DOUBLE PRECISION A( LDA, * ) ..
	     * 
	     * Purpose =======
	     * 
	     * DGENND tests that its argument has a non-negative diagonal.
	     * 
	     * Arguments =========
	     * 
	     * M (input) INTEGER The number of rows in A.
	     * 
	     * N (input) INTEGER The number of columns in A.
	     * 
	     * A (input) DOUBLE PRECISION array, dimension (LDA, N) The matrix.
	     * 
	     * LDA (input) INTEGER Leading dimension of A.
	     */
	    private boolean dgennd(final int m, final int n, final double A[][], final int lda) {
	        int i;
	        int k;

	        k = Math.min(m, n);
	        for (i = 0; i < k; i++) {
	            if (A[i][i] < 0.0) {
	                return false;
	            }
	        }
	        return true;
	    } // dgennd;

	    /**
	     * This is a port of the version 3.2 LAPACK routine DGEQR2 Original DGEQR2 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd. November, 2006 dgeqr2 computes a QR factorization of
	     * a real m by n matrix A: A = Q * R
	     * 
	     * @param m input int The number of rows of the matrix A. m >= 0.
	     * @param n input int The number of columns of the matrix A. n >= 0.
	     * @param A (input/output) double[][] of dimension (lda,n) On entry, the m by n matrix A. On exit, the elements on
	     *            and above the diagonal of the array contain the min(m,n) by n upper trapezoidal matrix R (R is upper
	     *            triangular if m >= n). The elements below the diagonal, with the array tau, represent the orthogonal
	     *            matrix Q as a product of elementary reflectors. The matrix Q is represented as a product of elementary
	     *            reflectors Q = H(1) H(2) . . . H(k), where k = min(m,n). Each H(i) has the form H(i) = I - tau * v *
	     *            v' where tau is a real scalar, and v is a real vector with v(0:i-2) = 0 and v(i-1) = 1; v(i:m-1) is
	     *            stored on exit in A(i:m-1, i-1), and tau in tau[i-1].
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     * @param tau output double[] of dimension min(m,n) The scalar factors of the elementary reflectors.
	     * @param work (workspace) double[] of dimension (n)
	     * @param info output int[] = 0: successful exit, < 0: If info[0] = -i, the i-th argument had an illegal value.
	     */
	    private void dgeqr2(final int m, final int n, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int[] info) {
	        int i;
	        int k;
	        double aii;
	        final double[] alpha = new double[1];
	        final double[] t = new double[1];
	        double[] x;
	        double[][] array1;
	        int row1;
	        int j;
	        int p;

	        // Test the input arguments
	        info[0] = 0;

	        if (m < 0) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -4;
	        }

	        if (info[0] != 0) {
	            System.err.print("Error dgeqr2 had info[0] = " + info[0] + "\n");
	            System.err.println("Error dgeqr2 had info[0] = " + info[0]);

	            return;
	        }

	        k = Math.min(m, n);

	        for (i = 1; i <= k; i++) {

	            // Generate elementary reflector H(i) to annihilate A(i:m-1,i-1)
	            alpha[0] = A[i - 1][i - 1];
	            x = new double[m - i];

	            for (j = 0; j < (m - i); j++) {
	                x[j] = A[Math.min(i, m - 1) + j][i - 1];
	            }

	            dlarfp(m - i + 1, alpha, x, 1, t);
	            A[i - 1][i - 1] = alpha[0];

	            for (j = 0; j < (m - i); j++) {
	                A[Math.min(i, m - 1) + j][i - 1] = x[j];
	            }

	            tau[i - 1] = t[0];

	            if (i < n) {

	                // Apply H(i) to A(i-1:m-1,i:n-1) from the left
	                aii = A[i - 1][i - 1];
	                A[i - 1][i - 1] = 1.0;
	                x = new double[m - i + 1];

	                for (j = 0; j < (m - i + 1); j++) {
	                    x[j] = A[i - 1 + j][i - 1];
	                }

	                row1 = Math.max(1, m - i + 1);
	                array1 = new double[row1][n - i];

	                for (j = 0; j < row1; j++) {

	                    for (p = 0; p < (n - i); p++) {
	                        array1[j][p] = A[i - 1 + j][i + p];
	                    }
	                }

	                dlarf('L', m - i + 1, n - i, x, 1, t[0], array1, row1, work);

	                for (j = 0; j < row1; j++) {

	                    for (p = 0; p < (n - i); p++) {
	                        A[i - 1 + j][i + p] = array1[j][p];
	                    }
	                }

	                A[i - 1][i - 1] = aii;
	            } // if (i < n)
	        } // for (i = 1; i <= k; i++)

	        return;
	    } // dgeqr2

	    /**
	     * This is a port of version 3.2 LAPACK routine DGEQRF Original DGEQRF created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dgeqrf computes a QR factorization of
	     * a real m by n matrix A: A = Q * R.
	     * 
	     * @param m input int The number of rows of the matrix A. m >= 0.
	     * @param n input int The number of columns of the matrix A. n >= 0.
	     * @param A input/output double[][] of dimension (lda,n) On entry, the m by n matrix A. On exit, the elements on and
	     *            above the diagonal of the array contain the min(m,n)-by-n upper trapezoidal matrix R ( R is upper
	     *            triangular if m >= n); the elements below the diagonal, with the array tau, represent the orthogonal
	     *            matrix Q as a product of min(m,n) elementary reflectors. The matrix Q is represented as a product of
	     *            elementary reflectors Q = H(1) H(2) . . . H(k), where k = min(m,n) Each H(i) has the form H(i) = I -
	     *            tau * v * v' where tau is a real scalar, and v is a real vector with v(0:i-2) = 0 and v(i-1) = 1;
	     *            v(i:m-1) is stored on exit in A(i:m-1,i-1), and tau in tau[i-1].
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     * @param tau output double[] of dimension min(m,n). The scalar factors of the elementary reflectors.
	     * @param work (workspace/output) double[] of dimension (max(1,lwork)) On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= max(1,n). For optimum performance, lwork >=
	     *            n*nb, where nb is the optimal blocksize. If lwork = -1, then a workspace query is assumed; the routine
	     *            only calculates the optimal size of the work array, returns this value as the first entry of the work
	     *            array, and no error message related to lwork is output.
	     * @param info output int[] = 0: successful exit, < 0: If info[0] = -i, the i-th argument had an illegal value
	     */
	    private void dgeqrf(final int m, final int n, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int lwork, final int[] info) {
	        boolean lquery;
	        int i;
	        int ib;
	        final int[] iinfo = new int[1];
	        int iws;
	        int k;
	        int ldwork = 1;
	        int lwkopt;
	        int nb;
	        int nbmin;
	        int nx;
	        String name;
	        String opts;
	        double[][] array1;
	        double[][] array2;
	        int row1;
	        int p;
	        int q;
	        double[] x;
	        double[][] work2d;
	        double[][] w2d;

	        // Test the input arguments
	        info[0] = 0;
	        name = new String("DGEQRF");
	        opts = new String(" ");
	        nb = ilaenv(1, name, opts, m, n, -1, -1);
	        lwkopt = n * nb;
	        work[0] = lwkopt;
	        lquery = (lwork == -1);

	        if (m < 0) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -4;
	        } else if ( (lwork < Math.max(1, n)) && ( !lquery)) {
	            info[0] = -7;
	        }

	        if (info[0] != 0) {
	            System.err.print("Error dgeqrf had info[0] = " + info[0] + "\n");
	            System.err.println("Error dgeqrf had info[0] = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        k = Math.min(m, n);

	        if (k == 0) {
	            work[0] = 1;

	            return;
	        } // if (k == 0)

	        nbmin = 2;
	        nx = 0;
	        iws = n;

	        if ( (nb > 1) && (nb < k)) {

	            // Determine when to cross over from blocked to unblocked code.
	            nx = Math.max(0, ilaenv(3, name, opts, m, n, -1, -1));

	            if (nx < k) {

	                // Determine if workspace is large enough for blocked code.
	                ldwork = n;
	                iws = ldwork * nb;

	                if (lwork < iws) {

	                    // Not enough space to use optimal nb: reduce nb and
	                    // determine the minimum value of nb.
	                    nb = lwork / ldwork;
	                    nbmin = Math.max(2, ilaenv(2, name, opts, m, n, -1, -1));
	                } // if (lwork < iws)
	            } // if (nx < k)
	        } // if ((nb > 1) && (nb < k))

	        if ( (nb >= nbmin) && (nb < k) && (nx < k)) {

	            // Use blocked code initially.
	            for (i = 1; i <= (k - nx); i += nb) {
	                ib = Math.min(k - i + 1, nb);

	                // Compute the QR factorization of the current block
	                // A(i-1:m-1, i-1:i+ib-2)
	                row1 = Math.max(1, m - i + 1);
	                array1 = new double[row1][ib];

	                for (p = 0; p < row1; p++) {

	                    for (q = 0; q < ib; q++) {
	                        array1[p][q] = A[i - 1 + p][i - 1 + q];
	                    }
	                }

	                x = new double[Math.min(m - i + 1, ib)];
	                dgeqr2(m - i + 1, ib, array1, row1, x, work, iinfo);

	                for (p = 0; p < row1; p++) {

	                    for (q = 0; q < ib; q++) {
	                        A[i - 1 + p][i - 1 + q] = array1[p][q];
	                    }
	                }

	                for (p = 0; p < Math.min(m - i + 1, ib); p++) {
	                    tau[i - 1 + p] = x[p];
	                }

	                if ( (i + ib) <= n) {

	                    // Form the triangular factor of the block reflector
	                    // H = H(i) H(i+1) . . . H(i+ib-1)
	                    x = new double[ib];

	                    for (p = 0; p < ib; p++) {
	                        x[p] = tau[i - 1 + p];
	                    }

	                    work2d = new double[ldwork][ib];
	                    dlarft('F', 'C', m - i + 1, ib, array1, row1, x, work2d, ldwork);

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            A[i - 1 + p][i - 1 + q] = array1[p][q];
	                        }
	                    }

	                    // Apply H' to A(i-1:m-1,i+ib-1:n-1) from the left
	                    array2 = new double[m - i + 1][n - i - ib + 1];

	                    for (p = 0; p < (m - i + 1); p++) {

	                        for (q = 0; q < (n - i - ib + 1); q++) {
	                            array2[p][q] = A[i - 1 + p][i + ib - 1 + q];
	                        }
	                    }

	                    w2d = new double[ldwork][ib];
	                    dlarfb('L', 'T', 'F', 'C', m - i + 1, n - i - ib + 1, ib, array1, row1, work2d, ldwork, array2, m
	                            - i + 1, w2d, ldwork);

	                    for (p = 0; p < (m - i + 1); p++) {

	                        for (q = 0; q < (n - i - ib + 1); q++) {
	                            A[i - 1 + p][i + ib - 1 + q] = array2[p][q];
	                        }
	                    }
	                } // if (i+ib <= n)
	            } // for (i = 1; i <= k - nx; i += nb)
	        } // if ((nb >= nbmin) && (nb < k) && (nx < k))
	        else {
	            i = 1;
	        }

	        // Use unblocked code to factor the last or only block
	        if (i <= k) {
	            x = new double[Math.min(m - i + 1, n - i + 1)];
	            row1 = Math.max(1, m - i + 1);
	            array1 = new double[row1][n - i + 1];

	            for (p = 0; p < row1; p++) {

	                for (q = 0; q < (n - i + 1); q++) {
	                    array1[p][q] = A[i - 1 + p][i - 1 + q];
	                }
	            }

	            dgeqr2(m - i + 1, n - i + 1, array1, row1, x, work, iinfo);

	            for (p = 0; p < Math.min(m - i + 1, n - i + 1); p++) {
	                tau[i - 1 + p] = x[p];
	            }

	            for (p = 0; p < row1; p++) {

	                for (q = 0; q < (n - i + 1); q++) {
	                    A[i - 1 + p][i - 1 + q] = array1[p][q];
	                }
	            }
	        }

	        work[0] = iws;

	        return;
	    } // dgeqrf

	    /**
	     * This is a port of the 10/22/86 Blas routine DGER Original version written by: Jack Dongarra, Argonne National
	     * Lab. Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National
	     * Labs. dger performs the rank 1 operation A = alpha*x*y' + A, where alpha is a scalar, x is an m element vector, y
	     * is an n element vector, and A is an m by n matrix.
	     * 
	     * @param m input int On entry, m specifies the number of rows of the matrix A. m must be at least zero.
	     * @param n input int On entry, n specifies the number of columns of the matrix A. n must be at least zero.
	     * @param alpha input double Specified scalar
	     * @param x input double[] of dimension at least (1 + (m-1)*abs(incx)). Before entry, the incremented array x must
	     *            contain the m element vector x.
	     * @param incx input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     * @param y input double[] of dimension at least (1 + (n-1)*abs(incy)). Before entry, the incremented array y must
	     *            contain the n element vector y.
	     * @param incy input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
	     * @param A double[][] of dimension lda by n. Before entry, the leading m by n part of the array A must contain the
	     *            matrix of coefficients. On exit, A is overwritten by the updated matrix.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1,m).
	     */
	    private void dger(final int m, final int n, final double alpha, final double[] x, final int incx, final double[] y,
	            final int incy, final double[][] A, final int lda) {
	        double temp;
	        int i;
	        int info;
	        int ix;
	        int j;
	        int jy;
	        int kx;

	        // Test the input parameters.
	        info = 0;

	        if (m < 0) {
	            info = 1;
	        } else if (n < 0) {
	            info = 2;
	        } else if (incx == 0) {
	            info = 5;
	        } else if (incy == 0) {
	            info = 7;
	        } else if (lda < Math.max(1, m)) {
	            info = 9;
	        }

	        if (info != 0) {
	            System.err.println("Error dger had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || (alpha == 0.0)) {
	            return;
	        }

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through A.
	        if (incy > 0) {
	            jy = 0;
	        } else {
	            jy = - (n - 1) * incy;
	        }

	        if (incx == 1) {

	            for (j = 0; j < n; j++) {

	                if (y[jy] != 0.0) {
	                    temp = alpha * y[jy];

	                    for (i = 0; i < m; i++) {
	                        A[i][j] = A[i][j] + (x[i] * temp);
	                    }
	                } // if (y[jy] != 0.0)

	                jy = jy + incy;
	            } // for (j = 0; j < n; j++)
	        } // if (incx == 1)
	        else { // incx != 1

	            if (incx > 0) {
	                kx = 1;
	            } else {
	                kx = 1 - ( (m - 1) * incx);
	            }

	            for (j = 0; j < n; j++) {

	                if (y[jy] != 0.0) {
	                    temp = alpha * y[jy];
	                    ix = kx - 1;

	                    for (i = 0; i < m; i++) {
	                        A[i][j] = A[i][j] + (x[ix] * temp);
	                        ix = ix + incx;
	                    } // for (i = 0; i < m; i++)
	                } // if (y[jy] != 0.0)

	                jy = jy + incy;
	            } // for (j = 0; j < n; j++)
	        } // else incx != 1

	        return;
	    } // dger

	    /**
	     * This is a port of version 3.1 LAPACK test routine DGET51 Original DGET51 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dget51 generally checks a decomposition of the form A = U B V'
	     * where ' means transpose and U and V are orthogonal. Specifically, if itype = 1 result = | A - U B V' | / ( |A| n
	     * ulp ) If itype = 2, then: result = | A - B | / ( |A| n ulp ) If itype = 3, then: result = | I - UU' | / ( n ulp )
	     * 
	     * @param itype input int Specifies the type of tests to be performed. = 1: result = | A - U B V' | / ( |A| n ulp )
	     *            = 2: result = | A - B | / ( |A| n ulp ) = 3: result = | I - UU' | / ( n ulp )
	     * @param n input int The size of the matrix. If it is zero, dget51 does nothing. It must be at least zero.
	     * @param A (input) double[][] of dimension (lda, n) The original (unfactored) matrix.
	     * @param lda (input) int The leading dimension fo A. It must be at least 1 and at least n.
	     * @param B (input) double[][] of dimension (ldb,n) The factored matrix.
	     * @param ldb (input) int The leading dimension of B. It must be at least 1 and at least n.
	     * @param U (input) double[][] of dimension (ldu, n) The orthogonal matrix on the left-hand side in the
	     *            decomposition. Not referenced if itype = 2.
	     * @param ldu (input) int The leading dimension of U. ldu must be at least n and at least 1.
	     * @param V (input) double[][] of dimension (ldv,n) The orthogonal matrix on the right-hand side in the
	     *            decomposition. Not referenced if itype = 2 or itype = 3.
	     * @param ldv (input) int The leading dimension of V. ldv must be at least n and at least 1.
	     * @param work (workspace) double[] of dimension (2*n**2)
	     * @param result (output) double[] The values computed by the test specified by itype. The value is currently
	     *            limited to 1/ulp, to avoid overflow. Errors are flagged by result = 10/ulp.
	     */
	    private void dget51(final int itype, final int n, final double[][] A, final int lda, final double[][] B,
	            final int ldb, final double[][] U, final int ldu, final double[][] V, final int ldv, final double[] work,
	            final double[] result) {
	        int jcol;
	        int jdiag;
	        int jrow;
	        double anorm;
	        double ulp;
	        double unfl;
	        double wnorm;
	        double[][] work2d;
	        double[][] C;

	        result[0] = 0.0;

	        if (n <= 0) {
	            return;
	        }

	        unfl = dlamch('S');
	        ulp = dlamch('E') * dlamch('B');

	        // Some error checks
	        if ( (itype < 1) || (itype > 3)) {
	            result[0] = 10.0 / ulp;

	            return;
	        }

	        if (itype <= 2) {

	            // Tests scaled by the norm(A)
	            anorm = Math.max(dlange('1', n, n, A, lda, work), unfl);

	            if (itype == 1) {

	                // itype = 1: Compute W = A - UBV'
	                work2d = new double[n][n];
	                dlacpy(' ', n, n, A, lda, work2d, n);
	                C = new double[n][n];
	                dgemm('N', 'N', n, n, n, 1.0, U, ldu, B, ldb, 0.0, C, n);
	                dgemm('N', 'C', n, n, n, -1.0, C, n, V, ldv, 1.0, work2d, n);
	            } // if (itype == 1)
	            else { // itype == 2

	                // Compute w = A - B
	                work2d = new double[n][n];
	                dlacpy(' ', n, n, B, ldb, work2d, n);

	                for (jcol = 0; jcol < n; jcol++) {

	                    for (jrow = 0; jrow < n; jrow++) {
	                        work2d[jrow][jcol] = work2d[jrow][jcol] - A[jrow][jcol];
	                    }
	                }
	            } // else itype == 2

	            // Compute norm(W) / (ulp*norm(A))
	            wnorm = dlange('1', n, n, work2d, n, work);

	            if (anorm > wnorm) {
	                result[0] = (wnorm / anorm) / (n * ulp);
	            } else if (anorm < 1.0) {
	                result[0] = (Math.min(wnorm, n * anorm) / anorm) / (n * ulp);
	            } else {
	                result[0] = Math.min(wnorm / anorm, (double) n) / (n * ulp);
	            }
	        } // if (itype <= 2)
	        else { // itype == 3

	            // Tests not scaled by norm(A)
	            // Compute UU" - I
	            C = new double[n][n];
	            dgemm('N', 'C', n, n, n, 1.0, U, ldu, U, ldu, 0.0, C, n);

	            for (jdiag = 0; jdiag < n; jdiag++) {
	                C[jdiag][jdiag] = C[jdiag][jdiag] - 1.0;
	            } // for (jdiag = 0; jdiag < n; jdiag++)

	            result[0] = Math.min(dlange('1', n, n, C, n, work), (double) n) / (n * ulp);
	        } // else itype == 3

	        return;
	    } // dget51

	    /**
	     * This is a port of version 3.1 LAPACK test routine DGET52 Original DGET52 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dget52 does an eigenvector check for the generalized eigenvalue
	     * problem.
	     * 
	     * <p>
	     * The basic test for right eigenvectors is: | b[j] A E[j] - a[j] B E[j] | result[0] = max
	     * ------------------------------- j n ulp max( |b[j] A|, |a[j] B| using the 1-norm. Here a[j]/b[j] = w is the
	     * (j+1)-th generalized eigenvalue of A - w B, or, equivalently, b[j]/a[j] = m is the (j+1)-st generalized
	     * eigenvalue of m A - B.
	     * </p>
	     * 
	     * <p>
	     * For real eigenvalues, the test is straightforward. For complex eigenvalues, E[j] and a[j] are complex,
	     * represented by Er[j] + i*Ei[j] and ar[j] + i*ai[j], respectively, so the test for that eigenvector becomes
	     * max(|Wr|, |Wi| ) ---------------------------------------------- n ulp max( |b[j] A|, (|ar[j]| + |ai[j]|) |B| )
	     * where Wr = b[j] A Er[j] - ar[j] B Er[j] + ai[j] B Ei[j] Wi = b[j] A Ei[j] - ai[j] B Er[j] - ar[j] B Ei[j] T T _
	     * For left eigenvectors, A , B , a, and b are used.
	     * </p>
	     * 
	     * <p>
	     * dget52 also tests the normalization of E. Each eigenvector is supposed to be normalized so that the maximum
	     * "absolute value" of its elements is 1, where in this case, "absolute value" of a complex value x is |Re(x)| +
	     * |Im(x)|; let us call this maximum "absolute value" norm of a vector v M(v). If a[j] = b[j] = 0, then the
	     * eigenvector is set to be the (j+1)-st coordinate vector. The normalization test is: result[1] = max | M(v[j]) -
	     * 1| / (n ulp) eigenvectors v[j]
	     * </p>
	     * 
	     * @param left input boolean = true: The eigenvectors in the columns of E are assumed to be*left* eigenvectors. =
	     *            false: The eigenvectors in the columns of E are assumed to be*right* eigenvectors.
	     * @param n input int The size of the matrices. If it is zero, dget52 does nothing. It must be at least zero.
	     * @param A input double[][] of dimension (lda, n) The matrix A.
	     * @param lda input int The leading dimension of A. It must be at least 1 and at least n.
	     * @param B input double[][] of dimension (ldb, n) The matrix B.
	     * @param ldb input int The leading dimension of B. It must be at least 1 and at least n.
	     * @param E input double[][] of dimension (lde,n) The matrix of eigenvectors. It must be O(1). Complex eigenvalues
	     *            and eigenvectors always come in pairs, the eigenvalue and its conjugate being stored in adjacent
	     *            elements of alphar, alphai, and beta. Thus, if a[j]/b[j] and a[j+1]/b[j+1] are a complex conjugate
	     *            pair of generalized eigenvalues, then E(,j) contains the real part of the eigenvector and E(,j+1)
	     *            contains the imaginary part. Note that whether E(,j) is a real eigenvector or part of a complex one is
	     *            specified by whether alphai[j] is zero or not.
	     * @param lde input int The leading dimension of E. It must be at least 1 and at least n.
	     * @param alphar input double[] of dimension (n). The real parts of the values a[j] as described above, which, along
	     *            with b[j], define the generalized eigenvalues. Complex eigenvalues always come in complex conjugate
	     *            pairs a[j]/b[j] and a[j+1]/b[j+1], which are stored in adjacent elements in alphar, alphai, and beta.
	     *            Thus, if the j-th and (j+1)-st eigenvalues form a pair, alphar[j+1]/beta[j+1] is assumed to be equal
	     *            to alphar[j]/beta[j].
	     * @param alphai input double[] of dimension (n) The imaginary parts of the values of a[j] as described above,
	     *            which, along with b[j], define the generalized eigenvalues. If alphai[j] = 0, then the eigenvalue is
	     *            real, otherwise it is part of a complex conjugate pair. Complex eigenvalues always come in complex
	     *            conjugate pairs a[j]/b[j] and a[j+1]/b[j+1], which are stored in adjacent elements in alphar, alphai,
	     *            and beta. Thus, if the j-th and (j+1)-st eigenvalues form a pair, alphai[j+1]/beta[j+1] is assumed to
	     *            be equal to -alphai[j]/beta[j]. Also, nonzero values in alphai are assumed to always come in adjacent
	     *            pairs.
	     * @param beta input double[] of dimension (n). The values b[j] as described above, which, along with a[j], define
	     *            the generalized eigenvalues.
	     * @param work workspace double[] of dimension (n**2+n)
	     * @param result output double[] of dimension (2) The values computed by the test described above. If A E or B E is
	     *            likely to overflow, then result(0:1) is set to 10 / ulp.
	     */
	    private void dget52(final boolean left, final int n, final double[][] A, final int lda, final double[][] B,
	            final int ldb, final double[][] E, final int lde, final double[] alphar, final double[] alphai,
	            final double[] beta, final double[] work, final double[] result) {
	        boolean ilcplx;
	        char normab;
	        char trans;
	        int i;
	        int j;
	        int p;
	        int jvec;
	        double abmax;
	        double acoef;
	        double alfmax;
	        double anorm;
	        double bcoefi;
	        double bcoefr;
	        double betmax;
	        double bnorm;
	        double enorm;
	        double enrmer;
	        double errnrm;
	        double safmax;
	        double safmin;
	        double salfi;
	        double salfr;
	        double sbeta;
	        double scale;
	        double temp1;
	        double ulp;
	        final double[] x = new double[n];
	        final double[] y = new double[n];
	        final double[][] array1 = new double[n][n];

	        result[0] = 0.0;
	        result[1] = 0.0;

	        if (n <= 0) {
	            return;
	        }

	        safmin = dlamch('S');
	        safmax = 1.0 / safmin;
	        ulp = dlamch('E') * dlamch('B');

	        if (left) {
	            trans = 'T';
	            normab = 'I';
	        } else {
	            trans = 'N';
	            normab = 'O';
	        }

	        // Norm of A, B, and E
	        anorm = Math.max(dlange(normab, n, n, A, lda, work), safmin);
	        bnorm = Math.max(dlange(normab, n, n, B, ldb, work), safmin);
	        enorm = Math.max(dlange('O', n, n, E, lde, work), ulp);
	        alfmax = safmax / Math.max(1.0, bnorm);
	        betmax = safmax / Math.max(1.0, anorm);

	        // Compute error matrix.
	        // Column i = (b[i] A - a[i] B) E[i] / max( |a[i] B| | b[i] A| )
	        ilcplx = false;

	        for (jvec = 1; jvec <= n; jvec++) {

	            if (ilcplx) {

	                // 2nd Eigenvalue/-vector of pair -- do nothing
	                ilcplx = false;
	            } // if (ilcplx)
	            else { // !ilcplx
	                salfr = alphar[jvec - 1];
	                salfi = alphai[jvec - 1];
	                sbeta = beta[jvec - 1];

	                if (salfi == 0.0) {

	                    // Real eigenvalue and -vector
	                    abmax = Math.max(Math.abs(salfr), Math.abs(sbeta));

	                    if ( (Math.abs(salfr) > alfmax) || (Math.abs(sbeta) > betmax) || (abmax < 1.0)) {
	                        scale = 1.0 / Math.max(abmax, safmin);
	                        salfr = scale * salfr;
	                        sbeta = scale * sbeta;
	                    } // if ((Math.abs(salfr) > alfmax) || (Math.abs(sbeta) > betmax)

	                    temp1 = Math.max(Math.abs(salfr) * bnorm, Math.abs(sbeta) * anorm);
	                    temp1 = Math.max(temp1, safmin);
	                    scale = 1.0 / temp1;
	                    acoef = scale * sbeta;
	                    bcoefr = scale * salfr;

	                    for (j = 0; j < n; j++) {
	                        x[j] = E[j][jvec - 1];
	                        y[j] = work[ (n * (jvec - 1)) + j];
	                    }

	                    dgemv(trans, n, n, acoef, A, lda, x, 1, 0.0, y, 1);
	                    dgemv(trans, n, n, -bcoefr, B, lda, x, 1, 1.0, y, 1);

	                    for (j = 0; j < n; j++) {
	                        work[ (n * (jvec - 1)) + j] = y[j];
	                    }
	                } // if (salfi == 0.0)
	                else { // salfi != 0.0

	                    // Complex conjugate pair
	                    ilcplx = true;

	                    if (jvec == n) {
	                        result[0] = 10.0 / ulp;

	                        return;
	                    } // if (jvec == n)

	                    abmax = Math.max(Math.abs(salfr) + Math.abs(salfi), Math.abs(sbeta));

	                    if ( ( (Math.abs(salfr) + Math.abs(salfi)) > alfmax) || (Math.abs(sbeta) > betmax) || (abmax < 1.0)) {
	                        scale = 1.0 / Math.max(abmax, safmin);
	                        salfr = scale * salfr;
	                        salfi = scale * salfi;
	                        sbeta = scale * sbeta;
	                    } // if ((Math.abs(salfr) + Math.abs(salfi) > alfmax) ||

	                    temp1 = Math.max( (Math.abs(salfr) + Math.abs(salfi)) * bnorm, Math.abs(sbeta) * anorm);
	                    temp1 = Math.max(temp1, safmin);
	                    scale = 1.0 / temp1;
	                    acoef = scale * sbeta;
	                    bcoefr = scale * salfr;
	                    bcoefi = scale * salfi;

	                    if (left) {
	                        bcoefi = -bcoefi;
	                    } // if (left)

	                    for (j = 0; j < n; j++) {
	                        x[j] = E[j][jvec - 1];
	                        y[j] = work[ (n * (jvec - 1)) + j];
	                    }

	                    dgemv(trans, n, n, acoef, A, lda, x, 1, 0.0, y, 1);
	                    dgemv(trans, n, n, -bcoefr, B, lda, x, 1, 1.0, y, 1);

	                    for (j = 0; j < n; j++) {
	                        x[j] = E[j][jvec];
	                    }

	                    dgemv(trans, n, n, bcoefi, B, lda, x, 1, 1.0, y, 1);

	                    for (j = 0; j < n; j++) {
	                        work[ (n * (jvec - 1)) + j] = y[j];
	                    }

	                    for (j = 0; j < n; j++) {
	                        y[j] = work[ (n * jvec) + j];
	                    }

	                    dgemv(trans, n, n, acoef, A, lda, x, 1, 0.0, y, 1);

	                    for (j = 0; j < n; j++) {
	                        x[j] = E[j][jvec - 1];
	                    }

	                    dgemv(trans, n, n, -bcoefi, B, lda, x, 1, 1.0, y, 1);

	                    for (j = 0; j < n; j++) {
	                        x[j] = E[j][jvec];
	                    }

	                    dgemv(trans, n, n, -bcoefr, B, lda, x, 1, 1.0, y, 1);

	                    for (j = 0; j < n; j++) {
	                        work[ (n * jvec) + j] = y[j];
	                    }
	                } // else salfi != 0.0
	            } // else !ilcplx
	        } // for (jvec = 1; jvec <= n; jvec++)

	        p = 0;

	        for (j = 0; j < n; j++) {

	            for (i = 0; i < n; i++) {
	                array1[i][j] = work[p++];
	            }
	        }

	        errnrm = dlange('O', n, n, array1, n, x) / enorm;

	        // Compute result[0]
	        result[0] = errnrm / ulp;

	        // Normalization of E
	        enrmer = 0.0;
	        ilcplx = false;

	        for (jvec = 1; jvec <= n; jvec++) {

	            if (ilcplx) {
	                ilcplx = false;
	            } // if (ilcplx)
	            else { // !ilcplx
	                temp1 = 0.0;

	                if (alphai[jvec - 1] == 0.0) {

	                    for (j = 1; j <= n; j++) {
	                        temp1 = Math.max(temp1, Math.abs(E[j - 1][jvec - 1]));
	                    }

	                    enrmer = Math.max(enrmer, temp1 - 1.0);
	                } // if (alphai[jvec-1] == 0.0)
	                else { // alphai[jvec-1] != 0.0
	                    ilcplx = true;

	                    for (j = 1; j <= n; j++) {
	                        temp1 = Math.max(temp1, Math.abs(E[j - 1][jvec - 1]) + Math.abs(E[j - 1][jvec]));
	                    }

	                    enrmer = Math.max(enrmer, temp1 - 1.0);
	                } // else alphai[jvec-1] != 0.0
	            } // else !ilcplx
	        } // for (jvec = 1; jvec <= n; jvec++)

	        // Compute result[1]: the nromalization error in E.
	        result[1] = enrmer / (n * ulp);

	        return;
	    } // dget52

	    /**
	     * This is a port of version 3.1 LAPACK routine DGGBAK Original DGGBAK created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dggbak forms the right or left eigenvectors of a real
	     * generalized eigenvalue problem A*x = lambda*B*x, by backward transformation on the computed eigenvectors of the
	     * balanced pair of matrices output by dggbal.
	     * 
	     * @param job input char Specifies the type of backward transformation required: = 'N': do nothing, return
	     *            immediately, = 'P': do backward transformation for permutation only, = 'S': do backward transformation
	     *            for scaling only, = 'B': do backward transformations for both permutation and scaling job must be the
	     *            same as the argument job supplied to dggbal.
	     * @param side input char = 'R': V contains right eigenvectors, = 'L': V contains left eigenvectors
	     * @param n input int The number of rows of the matrix V. n >= 0.
	     * @param ilo input int
	     * @param ihi input int The integers ilo and ihi determined by dggbal. 1 <= ilo <= ihi <= n, if n > 0; ilo = 1 and
	     *            ihi = 0, if n = 0.
	     * @param lscale input double[] of dimension (n) Details of the permutations and/or scaling factors applied to the
	     *            left side of A and B, as returned by dggbal.
	     * @param rscale input double[] of dimension (n) Details of the permutations and/or scaling factors applied to the
	     *            right side of A and B, as returned by dggbal.
	     * @param m input int The number of columns of the matrix V. m >= 0.
	     * @param V (input/output) double[][] of dimension (ldv,m) On entry, the matrix of right or left eigenvectors to be
	     *            transformed, as returned by dtgevc. On exit, V is overwritten by the transformed eigenvectors.
	     * @param ldv input int The leading dimension of the matrix V. ldv >= max(1,n).
	     * @param info output int[] = 0: successful exit, < 0: If info[0] = -i, the i-th argument had an illegal value.
	     *            Further Details: See R. C. Ward, Balancing the generalized eigenvalue problem, SIAM J. Sci. Stat.
	     *            Comp. 2 (1981), 141-152.
	     */
	    private void dggbak(final char job, final char side, final int n, final int ilo, final int ihi,
	            final double[] lscale, final double[] rscale, final int m, final double[][] V, final int ldv,
	            final int[] info) {
	        boolean leftv;
	        boolean rightv;
	        int i;
	        int k;
	        double[] dx;
	        int j;
	        double temp;

	        // Test the input parameters
	        if ( (side == 'R') || (side == 'r')) {
	            rightv = true;
	        } else {
	            rightv = false;
	        }

	        if ( (side == 'L') || (side == 'l')) {
	            leftv = true;
	        } else {
	            leftv = false;
	        }

	        info[0] = 0;

	        if ( (job != 'N') && (job != 'n') && (job != 'P') && (job != 'p') && (job != 'S') && (job != 's')
	                && (job != 'B') && (job != 'b')) {
	            info[0] = -1;
	        } else if ( ( !rightv) && ( !leftv)) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -3;
	        } else if (ilo < 1) {
	            info[0] = -4;
	        } else if ( (n == 0) && (ihi == 0) && (ilo != 1)) {
	            info[0] = -4;
	        } else if ( (n > 0) && ( (ihi < ilo) || (ihi > Math.max(1, n)))) {
	            info[0] = -5;
	        } else if ( (n == 0) && (ilo == 1) && (ihi != 0)) {
	            info[0] = -5;
	        } else if (m < 0) {
	            info[0] = -8;
	        } else if (ldv < Math.max(1, n)) {
	            info[0] = -10;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dggbak had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if (m == 0) {
	            return;
	        }

	        if ( (job == 'N') || (job == 'n')) {
	            return;
	        }

	        if (ilo != ihi) {

	            // Backward balance
	            if ( (job == 'S') || (job == 's') || (job == 'B') || (job == 'b')) {

	                // Backward transformation on right eigenvectors
	                if (rightv) {
	                    dx = new double[m];

	                    for (i = ilo - 1; i < ihi; i++) {

	                        for (k = 0; k < m; k++) {
	                            dx[k] = V[i][k];
	                        }

	                        dscal(m, rscale[i], dx, 1);

	                        for (k = 0; k < m; k++) {
	                            V[i][k] = dx[k];
	                        }
	                    } // for (i = ilo - 1; i < ihi; i++)
	                } // if (rightv)

	                // Backward transformation on left eigenvectors
	                if (leftv) {
	                    dx = new double[m];

	                    for (i = ilo - 1; i < ihi; i++) {

	                        for (k = 0; k < m; k++) {
	                            dx[k] = V[i][k];
	                        }

	                        dscal(m, lscale[i], dx, 1);

	                        for (k = 0; k < m; k++) {
	                            V[i][k] = dx[k];
	                        }
	                    } // for (i = ilo - 1; i < ihi; i++)
	                } // if (leftv)

	            } // if ((job == 'S') || (job == 's') || (job == 'B') || (job == 'b'))
	        } // if (ilo != ihi)

	        // Backward permutation
	        if ( (job == 'P') || (job == 'p') || (job == 'B') || (job == 'b')) {

	            // Backward permutation on right eigenvectors
	            if (rightv) {

	                if (ilo != 1) {

	                    for (i = ilo - 1; i >= 1; i--) {
	                        k = (int) Math.round(rscale[i - 1]);

	                        if (k == i) {
	                            continue;
	                        } // if (k == i)

	                        for (j = 0; j < m; j++) {
	                            temp = V[i - 1][j];
	                            V[i - 1][j] = V[k - 1][j];
	                            V[k - 1][j] = temp;
	                        }
	                    } // for (i = ilo - 1; i >= 1; i--)
	                } // if (ilo != 1)

	                if (ihi != n) {

	                    for (i = ihi + 1; i <= n; i++) {
	                        k = (int) Math.round(rscale[i - 1]);

	                        if (k == i) {
	                            continue;
	                        } // if (k == i)

	                        for (j = 0; j < m; j++) {
	                            temp = V[i - 1][j];
	                            V[i - 1][j] = V[k - 1][j];
	                            V[k - 1][j] = temp;
	                        }
	                    } // for (i = ihi+1; i <= n; i++)
	                } // if (ihi != n)
	            } // if (rightv)

	            // Backward permutation on left eigenvectors
	            if (leftv) {

	                if (ilo != 1) {

	                    for (i = ilo - 1; i >= 1; i--) {
	                        k = (int) Math.round(lscale[i - 1]);

	                        if (k == i) {
	                            continue;
	                        } // if (k == i)

	                        for (j = 0; j < m; j++) {
	                            temp = V[i - 1][j];
	                            V[i - 1][j] = V[k - 1][j];
	                            V[k - 1][j] = temp;
	                        }
	                    } // for (i = ilo - 1; i >= 1; i--)
	                } // if (ilo != 1)

	                if (ihi != n) {

	                    for (i = ihi + 1; i <= n; i++) {
	                        k = (int) Math.round(lscale[i - 1]);

	                        if (k == i) {
	                            continue;
	                        } // if (k == i)

	                        for (j = 0; j < m; j++) {
	                            temp = V[i - 1][j];
	                            V[i - 1][j] = V[k - 1][j];
	                            V[k - 1][j] = temp;
	                        }
	                    } // for (i = ihi+1; i <= n; i++)
	                } // if (ihi != n)
	            } // if (leftv)

	        } // if ((job == 'P') || (job == 'p') || (job == 'B') || (job == 'b'))

	        return;
	    } // dggbak

	    /**
	     * This is a port of the version 3.1 LAPACK routine DGGBAL Original DGGBAL created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dggbal balances a pair of general real matrices (A,B). This
	     * involves, first, permuting A and B by similarity transformations to isolate eigenvalues in the first 1 to ilo-1
	     * and last ihi+1 to n elements on the diagonal; and second, applying a diagonal similarity transformation to rows
	     * and columns ilo to ihi to make the rows and columns as close in norm as possbile. Both steps are optional.
	     * 
	     * <p>
	     * Balancing may reduce the 1-norm of the matrices, and improve the accuracy of the computed eigenvalues and/or
	     * eigenvectors in the generalized eigenvector problem A*x = lambda*B*x.
	     * </p>
	     * 
	     * @param job input char Specifies the operations to be performed on A and B: = 'N': none: simply set ilo = 1, ihi =
	     *            n, lscale[i] = 1.0 and rscale[i] = 1.0 for i = 0,...,n-1. = 'P': permute only = 'S': scale only = 'B':
	     *            both permute and scale.
	     * @param n input int The order of matrices A and B. n >= 0.
	     * @param A input/output double[][] of dimension (lda,n) On entry, the input matrix A. On exit, A is overwritten by
	     *            the balanced matrix. If job = 'N', A is not referenced.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param B input/output double[][] of dimension (ldb,n) On entry, the input matrix B. On exit, B is overwritten by
	     *            the balanced matrix. If job = 'N', B is not referenced.
	     * @param ldb input int The leading dimension of the array B. ldb >= max(1,n).
	     * @param ilo output int[]
	     * @param ihi output int[] ilo and ihi are set to integers such that on exit A[i][j] = 0 and B[i][j] = 0 if i > j
	     *            and j = 0,...,ilo-2 and i = ihi,...,n-1. if job = 'N' or 'S', ilo = 1 and ihi = n.
	     * @param lscale output double[] of dimension n Details of the permutations and scaling factors applied to the left
	     *            side of A and B. If p[j] is the index of the row interchanged with row j, and d[j] is the scaling
	     *            factor applied to row j, then lscale[j] = p[j] for j = 0,...,ilo-2 = d[j] for j = ilo-1,...,ihi-1 =
	     *            p[j] for j = ihi,...,n-1. The order in which the interchanges are made is n-1 to ihi, then 0 to ilo-2.
	     * @param rscale output double[] of dimension n Details of the permutations and scaling factors applied to the right
	     *            side of A and B. If p[j] is the index of the column interchanged with column j, and d[j] is the
	     *            scaling factor applied to column j, then rscale[j] = p[j] for j = 0,...,ilo-2 = d[j] for j =
	     *            ilo-1,...,ihi-1 = p[j] for j = ihi,...,n-1. The order in which the interchanges are made is n-1 to
	     *            ihi, then 0 to ilo-2.
	     * @param work workspace double[] of dimension lwork lwork must be at least max(1,6*n) when job = 'S' or 'B', and at
	     *            least 1 when job = 'N' or 'P'.
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value.
	     *            Further details: See R.C. Ward, Balancing the generalized eigenvalue problem, SIAM J. Sci. Stat. Comp.
	     *            2 (1981), 141-152.
	     */
	    private void dggbal(final char job, final int n, final double[][] A, final int lda, final double[][] B,
	            final int ldb, final int[] ilo, final int[] ihi, final double[] lscale, final double[] rscale,
	            final double[] work, final int[] info) {
	        final double sclfac = 10.0;
	        int i;
	        int icab;
	        int iflow;
	        int ip1;
	        int ir;
	        int irab;
	        int it;
	        int j;
	        int jc;
	        int jp1;
	        int k;
	        int kount;
	        int L;
	        int lcab;
	        int lm1 = 0;
	        int lrab;
	        int lsfmax;
	        int lsfmin;
	        int m;
	        int nr;
	        int nrp2;
	        double alpha;
	        double basl;
	        double beta;
	        double cab;
	        double cmax;
	        double coef;
	        double coef2;
	        double coef5;
	        double cor;
	        double ew;
	        double ewc;
	        double gamma;
	        double pgamma = 1.0;
	        double rab;
	        double sfmax;
	        double sfmin;
	        double sum;
	        double t;
	        double ta;
	        double tb;
	        double tc;
	        boolean first;
	        boolean second;
	        boolean group;
	        int p;
	        double temp;
	        double[] w;
	        double[] x;
	        double[] y;
	        double[] z;
	        double dmax;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (job != 'N') && (job != 'n') && (job != 'P') && (job != 'p') && (job != 'S') && (job != 's')
	                && (job != 'B') && (job != 'b')) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -4;
	        } else if (ldb < Math.max(1, n)) {
	            info[0] = -6;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dggbal had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            ilo[0] = 1;
	            ihi[0] = n;

	            return;
	        }

	        if (n == 1) {
	            ilo[0] = 1;
	            ihi[0] = n;
	            lscale[0] = 1.0;
	            rscale[0] = 1.0;

	            return;
	        }

	        if ( (job == 'N') || (job == 'n')) {
	            ilo[0] = 1;
	            ihi[0] = n;

	            for (i = 0; i < n; i++) {
	                lscale[i] = 1.0;
	                rscale[i] = 1.0;
	            }

	            return;
	        } // if ((job == 'N') || (job == 'n'))

	        k = 1;
	        L = n;

	        if ( (job != 'S') && (job != 's')) {
	            first = false;
	            group = true;
	            second = true;

	            loop1: do {

	                // Permute the matrices A and B to isolate the eigenvalues
	                // Find row with one nonzero in columns 0 through L-1
	                loop2: {

	                    if (group) {

	                        if (first) {
	                            L = lm1;

	                            if (L == 1) {
	                                rscale[0] = 1.0;
	                                lscale[0] = 1.0;

	                                break loop1;
	                            } // if (L == 1)
	                        } // if (first)

	                        first = true;
	                        lm1 = L - 1;

	                        loop3: for (i = L; i >= 1; i--) {

	                            loop4: {

	                                loop5: {

	                                    for (j = 1; j <= lm1; j++) {
	                                        jp1 = j + 1;

	                                        if ( (A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
	                                            break loop5;
	                                        }
	                                    } // for (j = 1; j <= lm1; j++)

	                                    j = L;

	                                    break loop4;
	                                } // loop5

	                                for (j = jp1; j <= L; j++) {

	                                    if ( (A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
	                                        continue loop3;
	                                    }
	                                } // for (j = jp1; j <= L; j++)

	                                j = jp1 - 1;
	                            } // loop4

	                            m = L;
	                            iflow = 1;

	                            break loop2;
	                        } // for (i = L; i >= 1; i--)

	                        second = false;
	                    } // if (group)

	                    // Find column with one nonzero in rows k through n.
	                    if (second) {
	                        k = k + 1;
	                    } // if (second)

	                    second = true;

	                    loop6: for (j = k; j <= L; j++) {

	                        loop7: {

	                            loop8: {

	                                for (i = k; i <= lm1; i++) {
	                                    ip1 = i + 1;

	                                    if ( (A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
	                                        break loop8;
	                                    }
	                                } // for (i = k; i <= lm1; i++)

	                                i = L;

	                                break loop7;
	                            } // loop8

	                            for (i = ip1; i <= L; i++) {

	                                if ( (A[i - 1][j - 1] != 0.0) || (B[i - 1][j - 1] != 0.0)) {
	                                    continue loop6;
	                                }
	                            } // for (i = ip1; i <= L: i++)

	                            i = ip1 - 1;
	                        } // loop7

	                        m = k;
	                        iflow = 2;

	                        break loop2;
	                    } // for (j = k; j <= L; j++)

	                    break loop1;
	                } // loop2

	                // Permute rows m and i
	                lscale[m - 1] = i;

	                if (i != m) {

	                    for (p = 0; p < (n - k + 1); p++) {
	                        temp = A[i - 1][p + k - 1];
	                        A[i - 1][p + k - 1] = A[m - 1][p + k - 1];
	                        A[m - 1][p + k - 1] = temp;
	                        temp = B[i - 1][p + k - 1];
	                        B[i - 1][p + k - 1] = B[m - 1][p + k - 1];
	                        B[m - 1][p + k - 1] = temp;
	                    } // for (p = 0; p < n-k+1; p++)
	                } // if (i != m)

	                // Permute columns m and j
	                rscale[m - 1] = j;

	                if (j != m) {

	                    for (p = 0; p < L; p++) {
	                        temp = A[p][j - 1];
	                        A[p][j - 1] = A[p][m - 1];
	                        A[p][m - 1] = temp;
	                        temp = B[p][j - 1];
	                        B[p][j - 1] = B[p][m - 1];
	                        B[p][m - 1] = temp;
	                    } // for (p = 0; p < L; p++)
	                } // if (j != m)

	                if (iflow == 1) {
	                    group = true;
	                } // if (iflow == true)
	                else { // iflow == 2
	                    group = false;
	                } // else iflow == 2
	            } while (true); // loop1
	        } // if ((job != 'S') && (job != 's'))

	        ilo[0] = k;
	        ihi[0] = L;

	        if ( (job == 'P') || (job == 'P')) {

	            for (i = ilo[0]; i <= ihi[0]; i++) {
	                lscale[i - 1] = 1.0;
	                rscale[i - 1] = 1.0;
	            }

	            return;
	        }

	        if (ilo[0] == ihi[0]) {
	            return;
	        }

	        // Balance the submatrix in rows ilo to ihi
	        nr = ihi[0] - ilo[0] + 1;

	        for (i = ilo[0] - 1; i < ihi[0]; i++) {
	            rscale[i] = 0.0;
	            lscale[i] = 0.0;

	            work[i] = 0.0;
	            work[i + n] = 0.0;
	            work[i + (2 * n)] = 0.0;
	            work[i + (3 * n)] = 0.0;
	            work[i + (4 * n)] = 0.0;
	            work[i + (5 * n)] = 0.0;
	        } // for (i = ilo[0]-1; i < ihi[0]; i++)

	        // Compute right side vector in resulting linear equations
	        basl = 0.434294481903251 * Math.log(sclfac);

	        for (i = ilo[0] - 1; i < ihi[0]; i++) {

	            for (j = ilo[0] - 1; j < ihi[0]; j++) {
	                tb = B[i][j];
	                ta = A[i][j];

	                if (ta != 0.0) {
	                    ta = 0.434294481903251 * Math.log(Math.abs(ta)) / basl;
	                }

	                if (tb != 0.0) {
	                    tb = 0.434294481903251 * Math.log(Math.abs(tb)) / basl;
	                }

	                work[i + (4 * n)] = work[i + (4 * n)] - ta - tb;
	                work[j + (5 * n)] = work[j + (5 * n)] - ta - tb;
	            } // for (j = ilo[0] - 1; j < ihi[0]; j++)
	        } // for (i = ilo[0] - 1; i < ihi[0]; i++)

	        coef = 1.0 / (2.0 * nr);
	        coef2 = coef * coef;
	        coef5 = 0.5 * coef2;
	        nrp2 = nr + 2;
	        beta = 0.0;
	        it = 1;

	        // Start generalized conjugate gradient iteration
	        loop9: do {
	            x = new double[nr];
	            y = new double[nr];

	            for (p = 0; p < nr; p++) {
	                x[p] = work[ilo[0] - 1 + (4 * n) + p];
	                y[p] = work[ilo[0] - 1 + (5 * n) + p];
	            }

	            gamma = ddot(nr, x, 1, x, 1) + ddot(nr, y, 1, y, 1);
	            ew = 0.0;
	            ewc = 0.0;

	            for (i = ilo[0] - 1; i < ihi[0]; i++) {
	                ew = ew + work[i + (4 * n)];
	                ewc = ewc + work[i + (5 * n)];
	            }

	            gamma = (coef * gamma) - (coef2 * ( (ew * ew) + (ewc * ewc))) - (coef5 * (ew - ewc) * (ew - ewc));

	            if (gamma == 0.0) {
	                break loop9;
	            }

	            if (it != 1) {
	                beta = gamma / pgamma;
	            }

	            t = coef5 * (ewc - (3.0 * ew));
	            tc = coef5 * (ew - (3.0 * ewc));

	            for (p = 0; p < nr; p++) {
	                work[ilo[0] - 1 + p] = beta * work[ilo[0] - 1 + p];
	            }

	            for (p = 0; p < nr; p++) {
	                work[ilo[0] - 1 + n + p] = beta * work[ilo[0] - 1 + n + p];
	            }

	            for (p = 0; p < nr; p++) {
	                work[ilo[0] - 1 + n + p] += coef * work[ilo[0] - 1 + (4 * n) + p];
	            }

	            for (p = 0; p < nr; p++) {
	                work[ilo[0] - 1 + p] += coef * work[ilo[0] - 1 + (5 * n) + p];
	            }

	            for (i = ilo[0] - 1; i < ihi[0]; i++) {
	                work[i] = work[i] + tc;
	                work[i + n] = work[i + n] + t;
	            }

	            // Apply matrix to vector
	            for (i = ilo[0] - 1; i < ihi[0]; i++) {
	                kount = 0;
	                sum = 0.0;

	                for (j = ilo[0] - 1; j < ihi[0]; j++) {

	                    if (A[i][j] != 0.0) {
	                        kount = kount + 1;
	                        sum = sum + work[j];
	                    } // if (A[i][j] != 0.0)

	                    if (B[i][j] != 0.0) {
	                        kount = kount + 1;
	                        sum = sum + work[j];
	                    } // if (B[i][j] != 0.0)
	                } // for (j = ilo[0]-1; j < ihi[0]; j++)

	                work[i + (2 * n)] = (kount * work[i + n]) + sum;
	            } // for (i = ilo[0]-1; i < ihi[0]; i++)

	            for (j = ilo[0] - 1; j < ihi[0]; j++) {
	                kount = 0;
	                sum = 0.0;

	                for (i = ilo[0] - 1; i < ihi[0]; i++) {

	                    if (A[i][j] != 0.0) {
	                        kount = kount + 1;
	                        sum = sum + work[i + n];
	                    } // if (A[i][j] != 0.0)

	                    if (B[i][j] != 0.0) {
	                        kount = kount + 1;
	                        sum = sum + work[i + n];
	                    } // if (B[i][j] != 0.0)
	                } // for (i = ilo[0]-1; i < ihi[0]; i++)

	                work[j + (3 * n)] = (kount * work[j]) + sum;
	            } // for (j = ilo[0]-1; j < ihi[0]; j++)

	            w = new double[nr];
	            x = new double[nr];
	            y = new double[nr];
	            z = new double[nr];

	            for (p = 0; p < nr; p++) {
	                w[p] = work[ilo[0] - 1 + n + p];
	                x[p] = work[ilo[0] - 1 + (2 * n) + p];
	                y[p] = work[ilo[0] - 1 + p];
	                z[p] = work[ilo[0] - 1 + (3 * n) + p];
	            }

	            sum = ddot(nr, w, 1, x, 1) + ddot(nr, y, 1, z, 1);
	            alpha = gamma / sum;

	            // Determine correction to current iteration
	            cmax = 0.0;

	            for (i = ilo[0] - 1; i < ihi[0]; i++) {
	                cor = alpha * work[i + n];

	                if (Math.abs(cor) > cmax) {
	                    cmax = Math.abs(cor);
	                }

	                lscale[i] = lscale[i] + cor;
	                cor = alpha * work[i];

	                if (Math.abs(cor) > cmax) {
	                    cmax = Math.abs(cor);
	                }

	                rscale[i] = rscale[i] + cor;
	            } // for (i = ilo[0]-1; i < ihi[0]; i++)

	            if (cmax < 0.5) {
	                break loop9;
	            } // if (cmax < 0.5)

	            for (p = 0; p < nr; p++) {
	                work[ilo[0] - 1 + (4 * n) + p] += -alpha * work[ilo[0] - 1 + (2 * n) + p];
	            }

	            for (p = 0; p < nr; p++) {
	                work[ilo[0] - 1 + (5 * n) + p] += -alpha * work[ilo[0] - 1 + (3 * n) + p];
	            }

	            pgamma = gamma;
	            it = it + 1;
	        } while (it <= nrp2); // loop9

	        // End generalized conjugate gradient iteration
	        sfmin = dlamch('S');
	        sfmax = 1.0 / sfmin;
	        lsfmin = (int) ( (0.434294481903251 * Math.log(sfmin) / basl) + 1.0);
	        lsfmax = (int) (0.434294481903251 * Math.log(sfmax) / basl);

	        for (i = ilo[0]; i <= ihi[0]; i++) {
	            dmax = A[i - 1][ilo[0] - 1];
	            irab = 1;

	            for (p = 1; p < (n - ilo[0] + 1); p++) {

	                if (A[i - 1][ilo[0] - 1 + p] > dmax) {
	                    dmax = A[i - 1][ilo[0] - 1 + p];
	                    irab = p + 1;
	                }
	            }

	            rab = Math.abs(A[i - 1][irab + ilo[0] - 2]);
	            dmax = B[i - 1][ilo[0] - 1];
	            irab = 1;

	            for (p = 1; p < (n - ilo[0] + 1); p++) {

	                if (B[i - 1][ilo[0] - 1 + p] > dmax) {
	                    dmax = B[i - 1][ilo[0] - 1 + p];
	                    irab = p + 1;
	                }
	            }

	            rab = Math.max(rab, Math.abs(B[i - 1][irab + ilo[0] - 2]));
	            lrab = (int) ( (0.434294481903251 * Math.log(rab + sfmin) / basl) + 1.0);

	            if (lscale[i - 1] >= 0) {
	                ir = (int) (lscale[i - 1] + 0.5);
	            } else {
	                ir = (int) (lscale[i - 1] - 0.5);
	            }

	            ir = Math.min(Math.max(ir, lsfmin), lsfmax);
	            ir = Math.min(ir, lsfmax - lrab);
	            lscale[i - 1] = Math.pow(sclfac, (double) (ir));
	            dmax = A[0][i - 1];
	            icab = 1;

	            for (p = 1; p < ihi[0]; p++) {

	                if (A[p][i - 1] > dmax) {
	                    dmax = A[p][i - 1];
	                    icab = p + 1;
	                }
	            }

	            cab = Math.abs(A[icab - 1][i - 1]);
	            dmax = B[0][i - 1];
	            icab = 1;

	            for (p = 1; p < ihi[0]; p++) {

	                if (B[p][i - 1] > dmax) {
	                    dmax = B[p][i - 1];
	                    icab = p + 1;
	                }
	            }

	            cab = Math.max(cab, Math.abs(B[icab - 1][i - 1]));
	            lcab = (int) ( (0.434294481903251 * Math.log(cab + sfmin) / basl) + 1.0);

	            if (rscale[i - 1] >= 0.0) {
	                jc = (int) (rscale[i - 1] + 0.5);
	            } else {
	                jc = (int) (rscale[i - 1] - 0.5);
	            }

	            jc = Math.min(Math.max(jc, lsfmin), lsfmax);
	            jc = Math.min(jc, lsfmax - lcab);
	            rscale[i - 1] = Math.pow(sclfac, (double) (jc));
	        } // for (i = ilo[0]; i <= ihi[0]; i++)

	        // Row scaling of matrices A and B
	        for (i = ilo[0]; i <= ihi[0]; i++) {

	            for (p = 0; p < (n - ilo[0] + 1); p++) {
	                A[i - 1][ilo[0] - 1 + p] = lscale[i - 1] * A[i - 1][ilo[0] - 1 + p];
	                B[i - 1][ilo[0] - 1 + p] = lscale[i - 1] * B[i - 1][ilo[0] - 1 + p];
	            }
	        } // for (i = ilo[0]; i <= ihi[0]; i++)

	        // Column scaling of matrices A and B
	        for (j = ilo[0]; j <= ihi[0]; j++) {

	            for (p = 0; p < ihi[0]; p++) {
	                A[p][j - 1] = rscale[j - 1] * A[p][j - 1];
	                B[p][j - 1] = rscale[j - 1] * B[p][j - 1];
	            }
	        } // for (j = ilo[0]; j <= ihi[0]; j++)

	        return;
	    } // dggbal

	    /**
	     * This is a port of version 3.1 LAPACK routine DGGHRD Original DGGHRD created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dgghrd reduces a pair of real matrices (A,B) to generalized
	     * upper Hessenberg form using orthogonal transformations, where A is a general matrix and B is upper triangular.
	     * The form of the generalized eigenvalue problem is A*x = lambda*B*x and B is typically made upper triangular by
	     * computing its QR factorization and moving the orthogonal matrix Q to the left side of the equation.
	     * 
	     * <p>
	     * This subroutine simultaneously reduces A to a Hessenberg matrix H: Q**T * A * Z = H and transforms B to another
	     * upper triangular matrix T: Q**T * B * Z = T in order to reduce the problem to its standard form H*y = lambda*T*y
	     * where y = z**T * x
	     * </p>
	     * 
	     * <p>
	     * The orthogonal matrices Q and Z are determined as products of Givens rotations. They may either be formed
	     * explicitly, or they may be postmultiplied into input matrices Q1 and Z1, so that Q1 * A * Z1**T = (Q1*Q) * H *
	     * (Z1*Z)**T Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
	     * </p>
	     * 
	     * <p>
	     * If Q1 is the orthogonal matrix from the QR factorization of B in the original equation A*x = lambda*b*x, then
	     * dgghrd reduces the original problem to the generalized Hessenberg form.
	     * </p>
	     * 
	     * @param compq input char = 'N': do not compute Q = 'I': Q is initialized to the unit matrix, and the orthogonal
	     *            matrix Q is returned = 'V': Q must contain an orthogonal matrix Q1 on entry, and the product Q1*Q is
	     *            returned
	     * @param compz input char = 'N': do not compute Z = 'I': Z is initialized to the unit matrix, and the orthogonal
	     *            matrix Z is returned = 'V': Z must contain an orthogonal matrix Z1 on entry, and the product Z1*Z is
	     *            returned
	     * @param n input int The order of the matrices A and B. n >= 0.
	     * @param ilo input int
	     * @param ihi input int ilo and ihi mark the rows and columns of A which are to be reduced. It is assumed that A is
	     *            already upper triangular in rows and columns 0:ilo-2 and ih:n-1. ilo and ihi are normally set by a
	     *            previous call to dggbal; otherwise they should be set to 1 and n respectively. 1 <= ilo <= ihi <= n,
	     *            if n > 0; ilo = 1 and ihi = 0, if n == 0.
	     * @param A input/output double[][] of dimension (lda,n) On entry, the n by n general matrix to be reduced. On exit,
	     *            the upper triangle and the first subdiagonal of A are overwritten with the upper Hessenberg matrix H,
	     *            and the rest is set to zero.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param B input/output double[][] of dimension (ldb,n) On entry, the n by n upper triangular matrix B. On exit,
	     *            the upper triangular matrix T = Q**T B Z. The elements below the diagonal are set to zero.
	     * @param ldb input int The leading dimension of the array B. ldb >= max(1,n).
	     * @param Q input/output double[][] of dimension (ldq,n). On entry, if compq = 'V', the orthogonal matix Q1,
	     *            typically from the QR factorization of B. On exit, if compq = 'I', the orthogonal matrix Q, and if
	     *            compq = 'V', the product Q1*Q. Not referenced if compq = 'N'.
	     * @param ldq input int The leading dimension of the array Q. ldq >= n if compq = 'V' or 'I'; ldq >= 1 otherwise.
	     * @param Z input/output double[][] of dimension (ldz,n) On entry, if compz = 'V', the orthogonal matrix Z1. On
	     *            exit, if compz = 'I', the orthogonal matrix Z, and if compz = 'V', the product Z1*Z. Not referenced if
	     *            compz = 'N'.
	     * @param ldz input int The leading dimension of the array Z. ldz >= n if compz = 'V' or 'I'; ldz >= 1 otherwise.
	     * @param info output int[] = 0: successful exit. < 0: If info = -i, the i-th argument had an illegal value. Further
	     *            details: This routine reduces A to Hessenberg and B to triangular form by an unblocked reduction, as
	     *            described in Matrix Computations by Golub and Van Loan (Johns Hopkins Press).
	     */
	    private void dgghrd(final char compq, final char compz, final int n, final int ilo, final int ihi,
	            final double[][] A, final int lda, final double[][] B, final int ldb, final double[][] Q, final int ldq,
	            final double[][] Z, final int ldz, final int[] info) {
	        boolean ilq;
	        boolean ilz;
	        int icompq;
	        int icompz;
	        int jcol;
	        int jrow;
	        final double[] c = new double[1];
	        final double[] s = new double[1];
	        double temp;
	        final double[] aout = new double[1];
	        final double[] bout = new double[1];
	        double[] dx;
	        double[] dy;
	        int i;

	        // Decode compq
	        if ( (compq == 'N') || (compq == 'n')) {
	            ilq = false;
	            icompq = 1;
	        } else if ( (compq == 'V') || (compq == 'v')) {
	            ilq = true;
	            icompq = 2;
	        } else if ( (compq == 'I') || (compq == 'i')) {
	            ilq = true;
	            icompq = 3;
	        } else {
	            ilq = false;
	            icompq = 0;
	        }

	        // Decode compz
	        if ( (compz == 'N') || (compz == 'n')) {
	            ilz = false;
	            icompz = 1;
	        } else if ( (compz == 'V') || (compz == 'v')) {
	            ilz = true;
	            icompz = 2;
	        } else if ( (compz == 'I') || (compz == 'i')) {
	            ilz = true;
	            icompz = 3;
	        } else {
	            ilz = false;
	            icompz = 0;
	        }

	        // Test the input parameters
	        info[0] = 0;

	        if (icompq <= 0) {
	            info[0] = -1;
	        } else if (icompz <= 0) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -3;
	        } else if (ilo < 1) {
	            info[0] = -4;
	        } else if ( (ihi > n) || (ihi < (ilo - 1))) {
	            info[0] = -5;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -7;
	        } else if (ldb < Math.max(1, n)) {
	            info[0] = -9;
	        } else if ( (ilq && (ldq < n)) || (ldq < 1)) {
	            info[0] = -11;
	        } else if ( (ilz && (ldz < n)) || (ldz < 1)) {
	            info[0] = -13;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dgghrd had info[0] = " + info[0]);

	            return;
	        }

	        // Initialize Q and Z if desired
	        if (icompq == 3) {
	            dlaset('F', n, n, 0.0, 1.0, Q, ldq);
	        }

	        if (icompz == 3) {
	            dlaset('F', n, n, 0.0, 1.0, Z, ldz);
	        }

	        // Quick return if possible
	        if (n <= 1) {
	            return;
	        }

	        // Zero out lower triangle of B
	        for (jcol = 0; jcol < (n - 1); jcol++) {

	            for (jrow = jcol + 1; jrow < n; jrow++) {
	                B[jrow][jcol] = 0.0;
	            }
	        }

	        // Reduce A and B
	        for (jcol = ilo; jcol <= (ihi - 2); jcol++) {

	            for (jrow = ihi; jrow >= (jcol + 2); jrow--) {

	                // Step 1: rotate rows jrow-2, jrow-1 to kill A[jrow-1][jcol-1]
	                temp = A[jrow - 2][jcol - 1];
	                dlartg(temp, A[jrow - 1][jcol - 1], c, s, aout);
	                A[jrow - 2][jcol - 1] = aout[0];
	                A[jrow - 1][jcol - 1] = 0.0;
	                dx = new double[n - jcol];
	                dy = new double[n - jcol];

	                for (i = 0; i < (n - jcol); i++) {
	                    dx[i] = A[jrow - 2][jcol + i];
	                    dy[i] = A[jrow - 1][jcol + i];
	                }

	                drot(n - jcol, dx, 1, dy, 1, c[0], s[0]);

	                for (i = 0; i < (n - jcol); i++) {
	                    A[jrow - 2][jcol + i] = dx[i];
	                    A[jrow - 1][jcol + i] = dy[i];
	                }

	                dx = new double[n + 2 - jrow];
	                dy = new double[n + 2 - jrow];

	                for (i = 0; i < (n + 2 - jrow); i++) {
	                    dx[i] = B[jrow - 2][jrow - 2 + i];
	                    dy[i] = B[jrow - 1][jrow - 2 + i];
	                }

	                drot(n + 2 - jrow, dx, 1, dy, 1, c[0], s[0]);

	                for (i = 0; i < (n + 2 - jrow); i++) {
	                    B[jrow - 2][jrow - 2 + i] = dx[i];
	                    B[jrow - 1][jrow - 2 + i] = dy[i];
	                }

	                if (ilq) {
	                    dx = new double[n];
	                    dy = new double[n];

	                    for (i = 0; i < n; i++) {
	                        dx[i] = Q[i][jrow - 2];
	                        dy[i] = Q[i][jrow - 1];
	                    }

	                    drot(n, dx, 1, dy, 1, c[0], s[0]);

	                    for (i = 0; i < n; i++) {
	                        Q[i][jrow - 2] = dx[i];
	                        Q[i][jrow - 1] = dy[i];
	                    }
	                } // if (ilq)

	                // Step 2: Rotate columns jrow-1, jrow-2 to kill B[jrow-1][jrow-2]
	                temp = B[jrow - 1][jrow - 1];
	                dlartg(temp, B[jrow - 1][jrow - 2], c, s, bout);
	                B[jrow - 1][jrow - 1] = bout[0];
	                B[jrow - 1][jrow - 2] = 0.0;
	                dx = new double[ihi];
	                dy = new double[ihi];

	                for (i = 0; i < ihi; i++) {
	                    dx[i] = A[i][jrow - 1];
	                    dy[i] = A[i][jrow - 2];
	                }

	                drot(ihi, dx, 1, dy, 1, c[0], s[0]);

	                for (i = 0; i < ihi; i++) {
	                    A[i][jrow - 1] = dx[i];
	                    A[i][jrow - 2] = dy[i];
	                }

	                dx = new double[jrow - 1];
	                dy = new double[jrow - 1];

	                for (i = 0; i < (jrow - 1); i++) {
	                    dx[i] = B[i][jrow - 1];
	                    dy[i] = B[i][jrow - 2];
	                }

	                drot(jrow - 1, dx, 1, dy, 1, c[0], s[0]);

	                for (i = 0; i < (jrow - 1); i++) {
	                    B[i][jrow - 1] = dx[i];
	                    B[i][jrow - 2] = dy[i];
	                }

	                if (ilz) {
	                    dx = new double[n];
	                    dy = new double[n];

	                    for (i = 0; i < n; i++) {
	                        dx[i] = Z[i][jrow - 1];
	                        dy[i] = Z[i][jrow - 2];
	                    }

	                    drot(n, dx, 1, dy, 1, c[0], s[0]);

	                    for (i = 0; i < n; i++) {
	                        Z[i][jrow - 1] = dx[i];
	                        Z[i][jrow - 2] = dy[i];
	                    }
	                } // if (ilz)
	            } // for (jrow = ihi; jrow >= jcol+2; jrow--)
	        } // for (jcol = ilo; jcol <= ihi-2; jcol++)

	        return;
	    } // dgghrd

	    /**
	     * This is a port of version 3.1 LAPACK routine DHGEQZ Original DHGEQZ created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dhgeqz computes the eigenvalues of a real matrix pair (H,T),
	     * where H is an upper Hessenberg matrix and T is upper triangular, using the double-shift QZ method. Matrix pairs
	     * of this type are produced by the reduction to generalized upper Hessenberg form of a real matrix pair (A, B); A =
	     * Q1*H*Z**T, B = Q1*T*Z1**T, as computed by dgghrd.
	     * 
	     * <p>
	     * If job = 'S', then the Hessenberg-triangular pair (H,T) is also reduced to generalized Schur form, H = Q*S*Z**T,
	     * T = Q*P*Z**T, where Q and Z are orthogonal matrices, P is an upper triangular matrix, and S is a quasi-triangular
	     * matrix with 1-by-1 and 2-by-2 diagonal blocks.
	     * </p>
	     * 
	     * <p>
	     * The 1-by-1 blocks correspond to real eigenvalues of the matrix pair (H, T) and the 2-by-2 blocks correspond to
	     * complex conjugate pairs of eigenvalues.
	     * </p>
	     * 
	     * <p>
	     * Additionally, the 2-by-2 upper triangular diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to
	     * positive diagonal form, i.e., if (S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0, P(j,j) > 0, and P(j+1,j+1)
	     * > 0.
	     * </p>
	     * 
	     * <p>
	     * Optionally, the orthogonal matrix Q from the generalized Schur factorization may be postmultiplied into an input
	     * matrix Q1, and the orthogonal matrix Z may be postmultiplied into an input matrix Z1. If Q1 and Z1 are the
	     * orthogonal matrices from dgghrd that reduced the matrix pair (A,B) to generalized upper Hessenberg form, then the
	     * output matrices Q1*Q and Z1*Z are the orthogonal factors from the generalized Schur factorization of (A,B): A =
	     * (Q1*Q)*S*(Z1*Z)**T, B = (Q1*Q)*P*(Z1*Z)**T.
	     * </p>
	     * 
	     * <p>
	     * To avoid overflow, eignevalues of the matrix pair (H,T) (equivalently, of (A,b)) are computed as a pair of values
	     * (alpha, beta), where alpha is complex and beta real. If beta is nonzero, lambda = alpha / beta is an eigenvalue
	     * of the generalized nonsymmetric eigenvalue problem (GNEP) A*x = lambda*B*x and if alpha is nonzero, mu = beta /
	     * alpha is an eigenvalue fo the alternate form of the GNEP mu*A*y = B*y Real eigenvalues can be read directly from
	     * the generalized Schur form: alpha = S(i,i), beta = P(i,i)
	     * </p>
	     * 
	     * <p>
	     * Ref: C.B. Moler & G.W. Stewart, "An Algorithm for Generalized Matrix Eigenvalue Problems", SIAM J. Numer. Anal.,
	     * 10(1973), pp. 241- 256.
	     * </p>
	     * 
	     * @param job input char = 'E': Compute eigenvalues only = 'S': Compute eigenvalues and the Schur form.
	     * @param compq input char = 'N': Left Schur vectors (Q) are not computed. = 'I': Q is initialized to the unit
	     *            matrix and the matrix Q of left Schur vectors of (H,T) is returned. = 'V': Q must contain an
	     *            orthogonal matrix Q1 on entry and the product Q1*Q is returned.
	     * @param compz input char = 'N': Right Schur vectors (Z) are not computed. = 'I': Z is initialized to the unit
	     *            matrix and the matrix Z of right Schur vectors of (H,T) is returned. = 'V': Z must contain an
	     *            orthogonal matrix Z1 on entry and the product Z1*Z is returned.
	     * @param n input int The order of matrices H, T, Q, and Z. n >= 0.
	     * @param ilo input int
	     * @param ihi input int ilo and ihi mark the rows and columns of H which are in Hessenberg form. It is assumed that
	     *            A is already upper triangular in rows and columns 0:ilo-2 and ihi:n-1. If n > 0, 1 <= ilo <= ihi <= n;
	     *            if n = 0, ilo = 1 and ihi = 0.
	     * @param H (input/output) double[][] of dimension (ldh,n) On entry, the n by n upper Hessenberg matrix H. On exit,
	     *            if job = 'S', H contains the upper quasi-triangluar matrix S from the generalized Schur factorization;
	     *            2-by-2 diagonal blocks (corresponding to complex conjugate pairs of eigenvalues) are returned in
	     *            standard form, with H(i,i) = H(i+1,i+1) and H(i+1,i) * H(i,i+1) < 0. if job = 'E', the diagonal blocks
	     *            of H match those of S, but the rest of H is unspecified
	     * @param ldh input int The leading dimension of the array H. ldh >= max(1, n).
	     * @param T (input/output) double[][] of dimension (ldt,n) On entry, the n by n upper triangular matrix T. On exit,
	     *            if job = 'S', T contains the upper triangular matrix P from the generalized Schur factorization;
	     *            2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S are reduced to postive diagonal form,
	     *            i.e., if H(j+1,j) is non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) > 0, and T(j+1,j+1) > 0. if job =
	     *            'E', the diagonal blocks of T match those of P, but the rest of T is unspecified.
	     * @param ldt input int The leading dimension of the array T. ldt >= max(1,n).
	     * @param alphar output double[] of dimension (n) The real parts of each scalar alpha definfing an eigenvalue of
	     *            GNEP.
	     * @param alphai output double[] of dimension (n) The imaginary parts of each scalar alpha defining an eigenvalue of
	     *            GNEP. If alphai[j] is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st
	     *            eigenvalues are a complex conjugate pair, with alpha(j+1) = -alpha(j).
	     * @param beta output double[] of dimension (n) The scalars beta that define the eigenvalues of GNEP. Together, the
	     *            quantities alpha = (alphar[j], alphai[j]) and beta = beta[j] represent the j-th eigenvalue of the
	     *            matrix pair (A,B), in one of the forms lambda = alpha/beta or mu = beta/alpha. Since either lambda or
	     *            mu may overflow, they should not, in general, be computed.
	     * @param Q (input/output) double[][] of dimension (ldq,n) On entry, if compz = 'V', the orthogonal matrix Q1 is
	     *            used in the reduction of (A,B) to generalized Hessenberg form. On exit, if compz = 'I', the orthogonal
	     *            matrix of left Schur vectors of (H,T), and if compz = 'V', the orthogonal matrix of left Schur vectors
	     *            of (A,B). Not referenced if compz = 'N'.
	     * @param ldq input int The leading dimension of the array Q. ldq >= 1. If compq = 'V' or 'I', then ldq >= n.
	     * @param Z (input/output) double[][] of dimension (ldz,n) On entry, if compz = 'V', the orthogonal matrix Z1 is
	     *            used in the reduction of (A,B) to generalized Hessenberg form. On exit, if compz = 'I', the orthogonal
	     *            matrix of right Schur vectors of (H,T), and if compz = 'V', the orthogonal matrix of right Schur
	     *            vectors of (A,B). Not referenced if compz = 'N'.
	     * @param ldz input int The leading dimension of the array Z. ldz >= 1. If compz = 'V' or 'I', then ldz >= n.
	     * @param work (workspace/output) double[] of dimension max(1,lwork) On exit, if info[0] >= 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= max(1,n). If lwork = -1, then a workspace query
	     *            is assumed; the routine only calculates the optimal size of the work array, returns this value as the
	     *            first entry of the work array, and no error message related to lwork is output.
	     * @param info output int[] = 0: successful exit. < 0: If info[0] = -i, the i-th argument had an illegal value =
	     *            1,...,n: the QZ iteration did not converge. (H,T) is not in Schur form, but alphar[i], alphai[i], and
	     *            beta[i], i = info,...,n-1 should be correct. = n+1,...,2*n: the shift calculation failed. (H,T) is not
	     *            in Schur form, but alphar[i], alphai[i], and beta[i], i = info-n,...,n-1 should be correct
	     */
	    private void dhgeqz(final char job, final char compq, final char compz, final int n, final int ilo, final int ihi,
	            final double[][] H, final int ldh, final double[][] T, final int ldt, final double[] alphar,
	            final double[] alphai, final double[] beta, final double[][] Q, final int ldq, final double[][] Z,
	            final int ldz, final double[] work, final int lwork, final int[] info) {
	        final double safety = 100.0;
	        boolean ilazr2;
	        boolean ilazro;
	        boolean ilpivt;
	        boolean ilq;
	        boolean ilschr;
	        boolean ilz;
	        boolean lquery;
	        int i;
	        int icompq;
	        int icompz;
	        int ifirst;
	        int ifrstm;

	        // Counts iterations run since ilast was last changed. This is therefore
	        // reset only when a 1 by 1 or a 2 by 2 block deflates off the bottom.
	        int iiter;
	        int ilast;
	        int ilastm;
	        int in;
	        int ischur;
	        int istart;
	        int j;
	        int jc;
	        int jch;

	        // Counts iterations
	        int jiter;
	        int jr;
	        int k;
	        int maxit;
	        double a11;
	        double a12;
	        double a1i;
	        double a1r;
	        double a21;
	        double a22;
	        double a2i;
	        double a2r;
	        double ad11;
	        double ad11L;
	        double ad12;
	        double ad12L;
	        double ad21;
	        double ad21L;
	        double ad22;
	        double ad22L;
	        double ad32L;
	        double an;
	        double anorm;
	        final double[] hout = new double[1];
	        double ascale;
	        double atol;
	        final double[] b11 = new double[1];
	        ;

	        double b1a;
	        double b1i;
	        double b1r;
	        final double[] b22 = new double[1];
	        double b2a;
	        double b2i;
	        double b2r;
	        double bn;
	        double bnorm;
	        final double[] tout = new double[1];
	        double bscale;
	        double btol;
	        final double[] c = new double[1];
	        double c11i;
	        double c11r;
	        double c12;
	        double c21;
	        double c22i;
	        double c22r;
	        final double[] cL = new double[1];
	        double cq;
	        final double[] cr = new double[1];
	        double cz;
	        double[] dx;
	        double[] dy;
	        double eshift;
	        final double[] s = new double[1];
	        final double[] s1 = new double[1];
	        double s1inv;
	        final double[] s2 = new double[1];
	        double safmax;
	        double safmin;
	        double scale;
	        final double[] sL = new double[1];
	        double sqi;
	        double sqr;
	        final double[] sr = new double[1];
	        double szi;
	        double szr;
	        double t1;
	        final double[] tau = new double[1];
	        final double[] temp = new double[1];
	        final double[] temp2 = new double[1];
	        double tempi;
	        final double[] tempr = new double[1];
	        double u1;
	        double u12;
	        double u12L;
	        double u2;
	        double ulp;
	        double vs;
	        double w11;
	        double w12;
	        double w21;
	        double w22;
	        double wabs;
	        final double[] wi = new double[1];
	        final double[] wr = new double[1];
	        final double[] wr2 = new double[1];
	        final double[] v = new double[3];
	        double[][] array1;
	        double[][] array2;

	        // Decode job, compq, compz
	        if ( (job == 'E') || (job == 'e')) {
	            ilschr = false;
	            ischur = 1;
	        } else if ( (job == 'S') || (job == 's')) {
	            ilschr = true;
	            ischur = 2;
	        } else {
	            ilschr = false;
	            ischur = 0;
	        }

	        if ( (compq == 'N') || (compq == 'n')) {
	            ilq = false;
	            icompq = 1;
	        } else if ( (compq == 'V') || (compq == 'v')) {
	            ilq = true;
	            icompq = 2;
	        } else if ( (compq == 'I') || (compq == 'i')) {
	            ilq = true;
	            icompq = 3;
	        } else {
	            ilq = false;
	            icompq = 0;
	        }

	        if ( (compz == 'N') || (compz == 'n')) {
	            ilz = false;
	            icompz = 1;
	        } else if ( (compz == 'V') || (compz == 'v')) {
	            ilz = true;
	            icompz = 2;
	        } else if ( (compz == 'I') || (compz == 'i')) {
	            ilz = true;
	            icompz = 3;
	        } else {
	            ilz = false;
	            icompz = 0;
	        }

	        // Check argument values
	        info[0] = 0;
	        work[0] = Math.max(1, n);
	        lquery = (lwork == -1);

	        if (ischur == 0) {
	            info[0] = -1;
	        } else if (icompq == 0) {
	            info[0] = -2;
	        } else if (icompz == 0) {
	            info[0] = -3;
	        } else if (n < 0) {
	            info[0] = -4;
	        } else if (ilo < 1) {
	            info[0] = -5;
	        } else if ( (ihi > n) || (ihi < (ilo - 1))) {
	            info[0] = -6;
	        } else if (ldh < n) {
	            info[0] = -8;
	        } else if (ldt < n) {
	            info[0] = -10;
	        } else if ( (ldq < 1) || (ilq && (ldq < n))) {
	            info[0] = -15;
	        } else if ( (ldz < 1) || (ilz && (ldz < n))) {
	            info[0] = -17;
	        } else if ( (lwork < Math.max(1, n)) && ( !lquery)) {
	            info[0] = -19;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dhgeqz had info[0] = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n <= 0) {
	            work[0] = 1.0;

	            return;
	        }

	        // Initialize Q and Z
	        if (icompq == 3) {
	            dlaset('F', n, n, 0.0, 1.0, Q, ldq);
	        }

	        if (icompz == 3) {
	            dlaset('F', n, n, 0.0, 1.0, Z, ldz);
	        }

	        // Machine constants
	        in = ihi + 1 - ilo;
	        safmin = dlamch('S');
	        safmax = 1.0 / safmin;
	        ulp = dlamch('E') * dlamch('B');
	        array1 = new double[in][in];

	        for (i = 0; i < in; i++) {

	            for (j = 0; j < in; j++) {
	                array1[i][j] = H[ilo - 1 + i][ilo - 1 + j];
	            }
	        }

	        anorm = dlanhs('F', in, array1, in, work);

	        for (i = 0; i < in; i++) {

	            for (j = 0; j < in; j++) {
	                array1[i][j] = T[ilo - 1 + i][ilo - 1 + j];
	            }
	        }

	        bnorm = dlanhs('F', in, array1, in, work);
	        atol = Math.max(safmin, ulp * anorm);
	        btol = Math.max(safmin, ulp * bnorm);
	        ascale = 1.0 / Math.max(safmin, anorm);
	        bscale = 1.0 / Math.max(safmin, bnorm);

	        // Set Eigenvalues ihi+1:n
	        for (j = ihi; j < n; j++) {

	            if (T[j][j] < 0.0) {

	                if (ilschr) {

	                    for (jr = 0; jr <= j; jr++) {
	                        H[jr][j] = -H[jr][j];
	                        T[jr][j] = -T[jr][j];
	                    }
	                } // if (ilschr)
	                else { // !ilschr
	                    H[j][j] = -H[j][j];
	                    T[j][j] = -T[j][j];
	                } // else !ilschr

	                if (ilz) {

	                    for (jr = 0; jr < n; jr++) {
	                        Z[jr][j] = -Z[jr][j];
	                    } // for (jr = 0; jr < n; jr++)
	                } // if (ilz)
	            } // if (B[j][j] < 0.0)

	            alphar[j] = H[j][j];
	            alphai[j] = 0.0;
	            beta[j] = T[j][j];
	        } // for (j = ihi; j < n; j++)

	        // If ihi < ilo, skip QZ steps
	        loop1: {

	            if (ihi < ilo) {
	                break loop1;
	            }
	            // Main QZ iteration loop

	            // Initialize dynamic indices

	            // Eigenvalues ilast+1:n have been found.
	            // Column operations modify rows ifrstm-1:whatever-1.
	            // Row operations operations modify columns whatever-1:ilastm-1.

	            // If only eigenvalues are being computed, then ifrstm-1 is the row
	            // of the last splitting row above row ilast-1; this is always at
	            // least ilo-1.
	            // iiter counts iterations since the last eigenvalue was found, to
	            // tell when to use an extraordinary shift.
	            // maxit is the maximum number of qz sweeps allowed.

	            ilast = ihi;

	            if (ilschr) {
	                ifrstm = 1;
	                ilastm = n;
	            } else {
	                ifrstm = ilo;
	                ilastm = ihi;
	            }

	            iiter = 0;
	            eshift = 0.0;
	            maxit = 300 * (ihi - ilo + 1);

	            for (jiter = 1; jiter <= maxit; jiter++) {
	                // Split the matrix if possible

	                // Two tests:
	                // 1: H[j][j-1] = 0 or j = ilo
	                // 2: T[j][j] = 0
	                loop2: {

	                    loop4: {

	                        loop5: {

	                            loop6: {

	                                if (ilast == ilo) {

	                                    // Special case: j = ilast
	                                    break loop6;
	                                } else if (Math.abs(H[ilast - 1][ilast - 2]) <= atol) {
	                                    H[ilast - 1][ilast - 2] = 0.0;

	                                    break loop6;
	                                } // else if (Math.abs(H[ilast-1][ilast-2]) <= atol)

	                                loop7: {

	                                    if (Math.abs(T[ilast - 1][ilast - 1]) <= btol) {
	                                        T[ilast - 1][ilast - 1] = 0.0;

	                                        break loop7;
	                                    } // if (Math.abs(T[ilast-1][ilast-1]) <= btol)

	                                    // General case: j < ilast
	                                    for (j = ilast - 1; j >= ilo; j--) {

	                                        // Test 1: for H[j-1][j-2] = 0 or j = ilo
	                                        if (j == ilo) {
	                                            ilazro = true;
	                                        } else if (Math.abs(H[j - 1][j - 2]) <= atol) {
	                                            H[j - 1][j - 2] = 0.0;
	                                            ilazro = true;
	                                        } // else if (Math.abs(H[j-1][j-2]) <= atol)
	                                        else {
	                                            ilazro = false;
	                                        } // else

	                                        // Test2: for T[j-1][j-1] = 0
	                                        if (Math.abs(T[j - 1][j - 1]) < btol) {
	                                            T[j - 1][j - 1] = 0.0;

	                                            // Test 1a: Check for 2 consecutive small
	                                            // subdiagonals in H
	                                            ilazr2 = false;

	                                            if ( !ilazro) {
	                                                temp[0] = Math.abs(H[j - 1][j - 2]);
	                                                temp2[0] = Math.abs(H[j - 1][j - 1]);
	                                                tempr[0] = Math.max(temp[0], temp2[0]);

	                                                if ( (tempr[0] < 1.0) && (tempr[0] != 0.0)) {
	                                                    temp[0] = temp[0] / tempr[0];
	                                                    temp2[0] = temp2[0] / tempr[0];
	                                                } // if ((tempr[0] < 1.0) && (tempr[0] != 0.0))

	                                                if ( (temp[0] * (ascale * Math.abs(H[j][j - 1]))) <= (temp2[0] * (ascale * atol))) {
	                                                    ilazr2 = true;
	                                                } // if (temp[0]*(ascale*Math.abs(A[j][j-1])) <=
	                                            } // if (!ilazro)

	                                            // If both tests pass (1 & 2), i.e., the leading
	                                            // diagonal of T in the block is zero, split a 1x1
	                                            // block off at the top. (i.e., at the (j-1)-th
	                                            // row/column) The leading diagonal element of
	                                            // the remainder can also be zero, so this may have
	                                            // to be done repeatedly.

	                                            if (ilazro || ilazr2) {

	                                                for (jch = j; jch <= (ilast - 1); jch++) {
	                                                    temp[0] = H[jch - 1][jch - 1];
	                                                    dlartg(temp[0], H[jch][jch - 1], c, s, hout);
	                                                    H[jch - 1][jch - 1] = hout[0];
	                                                    H[jch][jch - 1] = 0.0;
	                                                    dx = new double[ilastm - jch];
	                                                    dy = new double[ilastm - jch];

	                                                    for (i = 0; i < (ilastm - jch); i++) {
	                                                        dx[i] = H[jch - 1][jch + i];
	                                                        dy[i] = H[jch][jch + i];
	                                                    }

	                                                    drot(ilastm - jch, dx, 1, dy, 1, c[0], s[0]);

	                                                    for (i = 0; i < (ilastm - jch); i++) {
	                                                        H[jch - 1][jch + i] = dx[i];
	                                                        H[jch][jch + i] = dy[i];
	                                                    }

	                                                    for (i = 0; i < (ilastm - jch); i++) {
	                                                        dx[i] = T[jch - 1][jch + i];
	                                                        dy[i] = T[jch][jch + i];
	                                                    }

	                                                    drot(ilastm - jch, dx, 1, dy, 1, c[0], s[0]);

	                                                    for (i = 0; i < (ilastm - jch); i++) {
	                                                        T[jch - 1][jch + i] = dx[i];
	                                                        T[jch][jch + i] = dy[i];
	                                                    }

	                                                    if (ilq) {
	                                                        dx = new double[n];
	                                                        dy = new double[n];

	                                                        for (i = 0; i < n; i++) {
	                                                            dx[i] = Q[i][jch - 1];
	                                                            dy[i] = Q[i][jch];
	                                                        }

	                                                        drot(n, dx, 1, dy, 1, c[0], s[0]);

	                                                        for (i = 0; i < n; i++) {
	                                                            Q[i][jch - 1] = dx[i];
	                                                            Q[i][jch] = dy[i];
	                                                        }
	                                                    } // if (ilq)

	                                                    if (ilazr2) {
	                                                        H[jch - 1][jch - 2] = H[jch - 1][jch - 2] * c[0];
	                                                    } // if (ilazr2)

	                                                    ilazr2 = false;

	                                                    if (Math.abs(T[jch][jch]) >= btol) {

	                                                        if ( (jch + 1) >= ilast) {
	                                                            break loop6;
	                                                        } // if (jch+1 >= ilast)
	                                                        else {
	                                                            ifirst = jch + 1;

	                                                            break loop5;
	                                                        } // else
	                                                    } // if (Math.abs(T[jch][jch]) >= btol)

	                                                    T[jch][jch] = 0.0;
	                                                } // for (jch = j; jch <= ilast-1; jch++)

	                                                break loop7;
	                                            } // if (ilazro || ilazr2)
	                                            else { // !(ilazro || ilazr2)

	                                                // Only test 2 passed -- chase the zero to
	                                                // T[ilast-1][ilast-1]
	                                                // Then process as in the case
	                                                // T[ilast-1][ilast-1] = 0
	                                                for (jch = j; jch <= (ilast - 1); jch++) {
	                                                    temp[0] = T[jch - 1][jch];
	                                                    dlartg(temp[0], T[jch][jch], c, s, tout);
	                                                    T[jch - 1][jch] = tout[0];
	                                                    T[jch][jch] = 0.0;

	                                                    if (jch < (ilastm - 1)) {
	                                                        dx = new double[ilastm - jch - 1];
	                                                        dy = new double[ilastm - jch - 1];

	                                                        for (i = 0; i < (ilastm - jch - 1); i++) {
	                                                            dx[i] = T[jch - 1][jch + 1 + i];
	                                                            dy[i] = T[jch][jch + 1 + i];
	                                                        } // for (i = 0; i < ilastm-jch-1; i++)

	                                                        drot(ilastm - jch - 1, dx, 1, dy, 1, c[0], s[0]);

	                                                        for (i = 0; i < (ilastm - jch - 1); i++) {
	                                                            T[jch - 1][jch + 1 + i] = dx[i];
	                                                            T[jch][jch + 1 + i] = dy[i];
	                                                        } // for (i = 0; i < ilastm-jch-1; i++)
	                                                    } // if (jch < ilastm-1)

	                                                    dx = new double[ilastm - jch + 2];
	                                                    dy = new double[ilastm - jch + 2];

	                                                    for (i = 0; i < (ilastm - jch + 2); i++) {
	                                                        dx[i] = H[jch - 1][jch - 2 + i];
	                                                        dy[i] = H[jch][jch - 2 + i];
	                                                    } // for (i = 0; i < ilastm-jch+2; i++)

	                                                    drot(ilastm - jch + 2, dx, 1, dy, 1, c[0], s[0]);

	                                                    for (i = 0; i < (ilastm - jch + 2); i++) {
	                                                        H[jch - 1][jch - 2 + i] = dx[i];
	                                                        H[jch][jch - 2 + i] = dy[i];
	                                                    } // for (i = 0; i < ilastm-jch+2; i++)

	                                                    if (ilq) {
	                                                        dx = new double[n];
	                                                        dy = new double[n];

	                                                        for (i = 0; i < n; i++) {
	                                                            dx[i] = Q[i][jch - 1];
	                                                            dy[i] = Q[i][jch];
	                                                        }

	                                                        drot(n, dx, 1, dy, 1, c[0], s[0]);

	                                                        for (i = 0; i < n; i++) {
	                                                            Q[i][jch - 1] = dx[i];
	                                                            Q[i][jch] = dy[i];
	                                                        }
	                                                    } // if (ilq)

	                                                    temp[0] = H[jch][jch - 1];
	                                                    dlartg(temp[0], H[jch][jch - 2], c, s, hout);
	                                                    H[jch][jch - 1] = hout[0];
	                                                    H[jch][jch - 2] = 0.0;
	                                                    dx = new double[jch + 1 - ifrstm];
	                                                    dy = new double[jch + 1 - ifrstm];

	                                                    for (i = 0; i < (jch + 1 - ifrstm); i++) {
	                                                        dx[i] = H[ifrstm - 1 + i][jch - 1];
	                                                        dy[i] = H[ifrstm - 1 + i][jch - 2];
	                                                    }

	                                                    drot(jch + 1 - ifrstm, dx, 1, dy, 1, c[0], s[0]);

	                                                    for (i = 0; i < (jch + 1 - ifrstm); i++) {
	                                                        H[ifrstm - 1 + i][jch - 1] = dx[i];
	                                                        H[ifrstm - 1 + i][jch - 2] = dy[i];
	                                                    }

	                                                    dx = new double[jch - ifrstm];
	                                                    dy = new double[jch - ifrstm];

	                                                    for (i = 0; i < (jch - ifrstm); i++) {
	                                                        dx[i] = T[ifrstm - 1 + i][jch - 1];
	                                                        dy[i] = T[ifrstm - 1 + i][jch - 2];
	                                                    }

	                                                    drot(jch - ifrstm, dx, 1, dy, 1, c[0], s[0]);

	                                                    for (i = 0; i < (jch - ifrstm); i++) {
	                                                        T[ifrstm - 1 + i][jch - 1] = dx[i];
	                                                        T[ifrstm - 1 + i][jch - 2] = dy[i];
	                                                    }

	                                                    if (ilz) {
	                                                        dx = new double[n];
	                                                        dy = new double[n];

	                                                        for (i = 0; i < n; i++) {
	                                                            dx[i] = Z[i][jch - 1];
	                                                            dy[i] = Z[i][jch - 2];
	                                                        }

	                                                        drot(n, dx, 1, dy, 1, c[0], s[0]);

	                                                        for (i = 0; i < n; i++) {
	                                                            Z[i][jch - 1] = dx[i];
	                                                            Z[i][jch - 2] = dy[i];
	                                                        }
	                                                    } // if (ilz)
	                                                } // for (jch = j; jch <= ilast-1; jch++)

	                                                break loop7;
	                                            } // else !(ilazro || ilazr2)
	                                        } // if (Math.abs(B[j-1][j-1]) < btol)
	                                        else if (ilazro) {

	                                            // Only 1 test passed -- work on j-1:ilast-1
	                                            ifirst = j;

	                                            break loop5;
	                                        } // else if (ilazro)
	                                        // Neither test passed -- try next j
	                                    } // for (j = ilast-1; j >= ilo; j--)

	                                    // (Drop-through is impossible)
	                                    info[0] = n + 1;
	                                    work[0] = n;

	                                    return;

	                                    // T[ilast-1][ilast-1] = 0 -- Clear H[ilast-1][ilast-2]
	                                    // to split off a 1x1 block.
	                                } // loop7

	                                temp[0] = H[ilast - 1][ilast - 1];
	                                dlartg(temp[0], H[ilast - 1][ilast - 2], c, s, hout);
	                                H[ilast - 1][ilast - 1] = hout[0];
	                                H[ilast - 1][ilast - 2] = 0.0;
	                                dx = new double[ilast - ifrstm];
	                                dy = new double[ilast - ifrstm];

	                                for (i = 0; i < (ilast - ifrstm); i++) {
	                                    dx[i] = H[ifrstm - 1 + i][ilast - 1];
	                                    dy[i] = H[ifrstm - 1 + i][ilast - 2];
	                                }

	                                drot(ilast - ifrstm, dx, 1, dy, 1, c[0], s[0]);

	                                for (i = 0; i < (ilast - ifrstm); i++) {
	                                    H[ifrstm - 1 + i][ilast - 1] = dx[i];
	                                    H[ifrstm - 1 + i][ilast - 2] = dy[i];
	                                }

	                                for (i = 0; i < (ilast - ifrstm); i++) {
	                                    dx[i] = T[ifrstm - 1 + i][ilast - 1];
	                                    dy[i] = T[ifrstm - 1 + i][ilast - 2];
	                                }

	                                drot(ilast - ifrstm, dx, 1, dy, 1, c[0], s[0]);

	                                for (i = 0; i < (ilast - ifrstm); i++) {
	                                    T[ifrstm - 1 + i][ilast - 1] = dx[i];
	                                    T[ifrstm - 1 + i][ilast - 2] = dy[i];
	                                }

	                                if (ilz) {
	                                    dx = new double[n];
	                                    dy = new double[n];

	                                    for (i = 0; i < n; i++) {
	                                        dx[i] = Z[i][ilast - 1];
	                                        dy[i] = Z[i][ilast - 2];
	                                    }

	                                    drot(n, dx, 1, dy, 1, c[0], s[0]);

	                                    for (i = 0; i < n; i++) {
	                                        Z[i][ilast - 1] = dx[i];
	                                        Z[i][ilast - 2] = dy[i];
	                                    }
	                                } // if (ilz)
	                                // H{ilast-1][ilast-2] = 0 -- Standardize T, set alphar,
	                                // alphai, and beta
	                            } // loop6

	                            if (T[ilast - 1][ilast - 1] < 0.0) {

	                                if (ilschr) {

	                                    for (j = ifrstm - 1; j < ilast; j++) {
	                                        H[j][ilast - 1] = -H[j][ilast - 1];
	                                        T[j][ilast - 1] = -T[j][ilast - 1];
	                                    } // for (j = ifrstm-1; j < ilast; j++)
	                                } // if (ilschr)
	                                else { // !ilschr
	                                    H[ilast - 1][ilast - 1] = -H[ilast - 1][ilast - 1];
	                                    T[ilast - 1][ilast - 1] = -T[ilast - 1][ilast - 1];
	                                } // else !ilschr

	                                if (ilz) {

	                                    for (j = 0; j < n; j++) {
	                                        Z[j][ilast - 1] = -Z[j][ilast - 1];
	                                    }
	                                } // if (ilz)
	                            } // if (T[ilast-1][ilast-1] < 0.0)

	                            alphar[ilast - 1] = H[ilast - 1][ilast - 1];
	                            alphai[ilast - 1] = 0.0;
	                            beta[ilast - 1] = T[ilast - 1][ilast - 1];

	                            // Go to next block -- exit if finished.
	                            ilast = ilast - 1;

	                            if (ilast < ilo) {
	                                break loop1;
	                            } // if (ilast < ilo)

	                            // Reset counters
	                            iiter = 0;
	                            eshift = 0.0;

	                            if ( !ilschr) {
	                                ilastm = ilast;

	                                if (ifrstm > ilast) {
	                                    ifrstm = ilo;
	                                } // if (ifrstm > ilast)
	                            } // if (!ilschr)

	                            break loop2;
	                        } // loop5

	                        // QZ step
	                        // This iteration only involves rows/columns ifirst-1:ilast-1.
	                        // We assume ifirst < ilast, and that the diagonal of T is
	                        // nonzero.
	                        iiter = iiter + 1;

	                        if ( !ilschr) {
	                            ifrstm = ifirst;
	                        } // if (!ilschr)

	                        // compute single shifts

	                        // At this point, ifirst < ilast, and the diagonal elements of
	                        // T[(ifirst-1:ilast-1,ifirst-1:ilast-1) are larger than btol
	                        // (in magnitude)
	                        if ( ( (iiter / 10) * 10) == iiter) {

	                            // Exceptional shift. Chosen for no particularly good
	                            // reason (Single shift only.)
	                            if ( ( (maxit * safmin) * Math.abs(H[ilast - 2][ilast - 1])) < Math
	                                    .abs(T[ilast - 2][ilast - 2])) {
	                                eshift = eshift + (H[ilast - 2][ilast - 1] / T[ilast - 2][ilast - 2]);
	                            } // if ((maxit*safmin)*Math.abs(H[ilast-2][ilast-1]) <
	                            else {
	                                eshift = eshift + (1.0 / (safmin * maxit));
	                            } // else

	                            s1[0] = 1.0;
	                            wr[0] = eshift;
	                        } // if ((iiter/10)*10 == iiter)
	                        else { // ((iiter/10)*10 != iiter)

	                            // Shifts based on the generalized eigenvalues of the
	                            // bottom-right 2x2 block of H and T. Ths first eigenvalue
	                            // returned by dlag2 is the Wilkinson shift (AEP p.512).
	                            array1 = new double[2][2];
	                            array2 = new double[2][2];

	                            for (i = 0; i < 2; i++) {

	                                for (k = 0; k < 2; k++) {
	                                    array1[i][k] = H[ilast - 2 + i][ilast - 2 + k];
	                                    array2[i][k] = T[ilast - 2 + i][ilast - 2 + k];
	                                }
	                            }

	                            dlag2(array1, 2, array2, 2, safmin * safety, s1, s2, wr, wr2, wi);
	                            temp[0] = Math.max(1.0, Math.abs(wr[0]));
	                            temp[0] = safmin * Math.max(temp[0], Math.abs(wi[0]));
	                            temp[0] = Math.max(s1[0], temp[0]);

	                            if (wi[0] != 0.0) {
	                                break loop4;
	                            } // if (wi[0] != 0.0)
	                        } // else ((iiter/10)*10 != iiter)

	                        // Fiddle with shift to avoid overflow
	                        temp[0] = Math.min(ascale, 1.0) * (0.5 * safmax);

	                        if (s1[0] > temp[0]) {
	                            scale = temp[0] / s1[0];
	                        } else {
	                            scale = 1.0;
	                        }

	                        temp[0] = Math.min(bscale, 1.0) * (0.5 * safmax);

	                        if (Math.abs(wr[0]) > temp[0]) {
	                            scale = Math.min(scale, temp[0] / Math.abs(wr[0]));
	                        }

	                        s1[0] = scale * s1[0];
	                        wr[0] = scale * wr[0];

	                        // Now check for two consecutive small subdiagonals
	                        loop8: {

	                            for (j = ilast - 1; j >= (ifirst + 1); j--) {
	                                istart = j;
	                                temp[0] = Math.abs(s1[0] * H[j - 1][j - 2]);
	                                temp2[0] = Math.abs( (s1[0] * H[j - 1][j - 1]) - (wr[0] * T[j - 1][j - 1]));
	                                tempr[0] = Math.max(temp[0], temp2[0]);

	                                if ( (tempr[0] < 1.0) && (tempr[0] != 0.0)) {
	                                    temp[0] = temp[0] / tempr[0];
	                                    temp2[0] = temp2[0] / tempr[0];
	                                } // if ((tempr[0] < 1.0) && (tempr[0] != 0.0))

	                                if (Math.abs( (ascale * H[j][j - 1]) * temp[0]) <= ( (ascale * atol) * temp2[0])) {
	                                    break loop8;
	                                } // if (Math.abs((ascale*A[j][j-1])*temp) <=
	                            } // for (j = ilast-1; j >= ifirst+1; j--)

	                            istart = ifirst;
	                        } // loop8

	                        // Do an implicit single-shift QZ sweep.
	                        // Initial Q;
	                        temp[0] = (s1[0] * H[istart - 1][istart - 1]) - (wr[0] * T[istart - 1][istart - 1]);
	                        temp2[0] = s1[0] * H[istart][istart - 1];
	                        dlartg(temp[0], temp2[0], c, s, tempr);

	                        // Sweep
	                        for (j = istart; j <= (ilast - 1); j++) {

	                            if (j > istart) {
	                                temp[0] = H[j - 1][j - 2];
	                                dlartg(temp[0], H[j][j - 2], c, s, hout);
	                                H[j - 1][j - 2] = hout[0];
	                                H[j][j - 2] = 0.0;
	                            } // if (j > istart)

	                            for (jc = j; jc <= ilastm; jc++) {
	                                temp[0] = (c[0] * H[j - 1][jc - 1]) + (s[0] * H[j][jc - 1]);
	                                H[j][jc - 1] = ( -s[0] * H[j - 1][jc - 1]) + (c[0] * H[j][jc - 1]);
	                                H[j - 1][jc - 1] = temp[0];
	                                temp2[0] = (c[0] * T[j - 1][jc - 1]) + (s[0] * T[j][jc - 1]);
	                                T[j][jc - 1] = ( -s[0] * T[j - 1][jc - 1]) + (c[0] * T[j][jc - 1]);
	                                T[j - 1][jc - 1] = temp2[0];
	                            } // for (jc = j; jc <= ilastm; jc++)

	                            if (ilq) {

	                                for (jr = 1; jr <= n; jr++) {
	                                    temp[0] = (c[0] * Q[jr - 1][j - 1]) + (s[0] * Q[jr - 1][j]);
	                                    Q[jr - 1][j] = ( -s[0] * Q[jr - 1][j - 1]) + (c[0] * Q[jr - 1][j]);
	                                    Q[jr - 1][j - 1] = temp[0];
	                                } // for (jr = 1; jr <= n; jr++)
	                            } // if (ilq)

	                            temp[0] = T[j][j];
	                            dlartg(temp[0], T[j][j - 1], c, s, tout);
	                            T[j][j] = tout[0];
	                            T[j][j - 1] = 0.0;

	                            for (jr = ifrstm; jr <= Math.min(j + 2, ilast); jr++) {
	                                temp[0] = (c[0] * H[jr - 1][j]) + (s[0] * H[jr - 1][j - 1]);
	                                H[jr - 1][j - 1] = ( -s[0] * H[jr - 1][j]) + (c[0] * H[jr - 1][j - 1]);
	                                H[jr - 1][j] = temp[0];
	                            } // for (jr = ifrstm; jr <= Math.min(j+2,ilast); jr++)

	                            for (jr = ifrstm; jr <= j; jr++) {
	                                temp[0] = (c[0] * T[jr - 1][j]) + (s[0] * T[jr - 1][j - 1]);
	                                T[jr - 1][j - 1] = ( -s[0] * T[jr - 1][j]) + (c[0] * T[jr - 1][j - 1]);
	                                T[jr - 1][j] = temp[0];
	                            } // for (jr = ifrstm; jr <= j; jr++)

	                            if (ilz) {

	                                for (jr = 1; jr <= n; jr++) {
	                                    temp[0] = (c[0] * Z[jr - 1][j]) + (s[0] * Z[jr - 1][j - 1]);
	                                    Z[jr - 1][j - 1] = ( -s[0] * Z[jr - 1][j]) + (c[0] * Z[jr - 1][j - 1]);
	                                    Z[jr - 1][j] = temp[0];
	                                } // for (jr = 1; jr <= n; jr++)
	                            } // if (ilz)
	                        } // for (j = istart; j <= ilast-1; j++)

	                        break loop2;
	                    } // loop4:

	                    // Use Francis double-shift
	                    // Note: The Francis double-shift should work with real shifts,
	                    // but only if the code is at least 3x3. This code may break
	                    // if this point is reached with a 2x2 block with real
	                    // eigenvalues.
	                    if ( (ifirst + 1) == ilast) {

	                        // Special case -- 2x2 block with complex eigenvalues
	                        // Step 1: Standardize, that is, rotate so that
	                        // ( T11 0 )
	                        // T = ( ) with T11 non-negative.
	                        // ( 0 T22 )
	                        dlasv2(T[ilast - 2][ilast - 2], T[ilast - 2][ilast - 1], T[ilast - 1][ilast - 1], b22, b11, sr,
	                                cr, sL, cL);

	                        if (b11[0] < 0.0) {
	                            cr[0] = -cr[0];
	                            sr[0] = -sr[0];
	                            b11[0] = -b11[0];
	                            b22[0] = -b22[0];
	                        } // if (b11[0] < 0.0)

	                        dx = new double[ilastm + 1 - ifirst];
	                        dy = new double[ilastm + 1 - ifirst];

	                        for (i = 0; i < (ilastm + 1 - ifirst); i++) {
	                            dx[i] = H[ilast - 2][ilast - 2 + i];
	                            dy[i] = H[ilast - 1][ilast - 2 + i];
	                        }

	                        drot(ilastm + 1 - ifirst, dx, 1, dy, 1, cL[0], sL[0]);

	                        for (i = 0; i < (ilastm + 1 - ifirst); i++) {
	                            H[ilast - 2][ilast - 2 + i] = dx[i];
	                            H[ilast - 1][ilast - 2 + i] = dy[i];
	                        }

	                        dx = new double[ilast + 1 - ifrstm];
	                        dy = new double[ilast + 1 - ifrstm];

	                        for (i = 0; i < (ilast + 1 - ifrstm); i++) {
	                            dx[i] = H[ifrstm - 1 + i][ilast - 2];
	                            dy[i] = H[ifrstm - 1 + i][ilast - 1];
	                        }

	                        drot(ilast + 1 - ifrstm, dx, 1, dy, 1, cr[0], sr[0]);

	                        for (i = 0; i < (ilast + 1 - ifrstm); i++) {
	                            H[ifrstm - 1 + i][ilast - 2] = dx[i];
	                            H[ifrstm - 1 + i][ilast - 1] = dy[i];
	                        }

	                        if (ilast < ilastm) {
	                            dx = new double[ilastm - ilast];
	                            dy = new double[ilastm - ilast];

	                            for (i = 0; i < (ilastm - ilast); i++) {
	                                dx[i] = T[ilast - 2][ilast + i];
	                                dy[i] = T[ilast - 1][ilast + i];
	                            }

	                            drot(ilastm - ilast, dx, 1, dy, 1, cL[0], sL[0]);

	                            for (i = 0; i < (ilastm - ilast); i++) {
	                                T[ilast - 2][ilast + i] = dx[i];
	                                T[ilast - 1][ilast + i] = dy[i];
	                            }
	                        } // if (ilast < ilastm)

	                        if (ifrstm < (ilast - 1)) {
	                            dx = new double[ifirst - ifrstm];
	                            dy = new double[ifirst - ifrstm];

	                            for (i = 0; i < (ifirst - ifrstm); i++) {
	                                dx[i] = T[ifrstm - 1 + i][ilast - 2];
	                                dy[i] = T[ifrstm - 1 + i][ilast - 1];
	                            }

	                            drot(ifirst - ifrstm, dx, 1, dy, 1, cr[0], sr[0]);

	                            for (i = 0; i < (ifirst - ifrstm); i++) {
	                                T[ifrstm - 1 + i][ilast - 2] = dx[i];
	                                T[ifrstm - 1 + i][ilast - 1] = dy[i];
	                            }
	                        } // if (ifrstm < ilast-1)

	                        if (ilq) {
	                            dx = new double[n];
	                            dy = new double[n];

	                            for (i = 0; i < n; i++) {
	                                dx[i] = Q[i][ilast - 2];
	                                dy[i] = Q[i][ilast - 1];
	                            }

	                            drot(n, dx, 1, dy, 1, cL[0], sL[0]);

	                            for (i = 0; i < n; i++) {
	                                Q[i][ilast - 2] = dx[i];
	                                Q[i][ilast - 1] = dy[i];
	                            }
	                        } // if (ilq)

	                        if (ilz) {
	                            dx = new double[n];
	                            dy = new double[n];

	                            for (i = 0; i < n; i++) {
	                                dx[i] = Z[i][ilast - 2];
	                                dy[i] = Z[i][ilast - 1];
	                            }

	                            drot(n, dx, 1, dy, 1, cr[0], sr[0]);

	                            for (i = 0; i < n; i++) {
	                                Z[i][ilast - 2] = dx[i];
	                                Z[i][ilast - 1] = dy[i];
	                            }
	                        } // if (ilz)

	                        T[ilast - 2][ilast - 2] = b11[0];
	                        T[ilast - 2][ilast - 1] = 0.0;
	                        T[ilast - 1][ilast - 2] = 0.0;
	                        T[ilast - 1][ilast - 1] = b22[0];

	                        // If b22[0] is negative, negate column ilast-1
	                        if (b22[0] < 0.0) {

	                            for (j = ifrstm; j <= ilast; j++) {
	                                H[j - 1][ilast - 1] = -H[j - 1][ilast - 1];
	                                T[j - 1][ilast - 1] = -T[j - 1][ilast - 1];
	                            } // for (j = ifrstm; j <= ilast; j++)

	                            if (ilz) {

	                                for (j = 0; j < n; j++) {
	                                    Z[j][ilast - 1] = -Z[j][ilast - 1];
	                                }
	                            } // if (ilz)
	                        } // if (b22[0] < 0.0)

	                        // Step2: Compute alphar, alphai, and beta (see refs.)
	                        // Recompute shift
	                        array1 = new double[2][2];
	                        array2 = new double[2][2];

	                        for (i = 0; i < 2; i++) {

	                            for (k = 0; k < 2; k++) {
	                                array1[i][k] = H[ilast - 2 + i][ilast - 2 + k];
	                                array2[i][k] = T[ilast - 2 + i][ilast - 2 + k];
	                            }
	                        }

	                        dlag2(array1, 2, array2, 2, safmin * safety, s1, temp, wr, temp2, wi);

	                        // If standardization has perturbed the shift onto real line,
	                        // do another (real single-shift) QR step.
	                        if (wi[0] == 0.0) {
	                            break loop2;
	                        }

	                        s1inv = 1.0 / s1[0];

	                        // Do EISPACK (QZVAL) computation of alpha and beta
	                        a11 = H[ilast - 2][ilast - 2];
	                        a21 = H[ilast - 1][ilast - 2];
	                        a12 = H[ilast - 2][ilast - 1];
	                        a22 = H[ilast - 1][ilast - 1];

	                        // Compute complex Givens rotation on right
	                        // (Assume come element of C = (sA - wB) > unfl)
	                        // (sA - wB)(CZ comp(-SZ))
	                        // (SZ CZ )
	                        c11r = (s1[0] * a11) - (wr[0] * b11[0]);
	                        c11i = -wi[0] * b11[0];
	                        c12 = s1[0] * a12;
	                        c21 = s1[0] * a21;
	                        c22r = (s1[0] * a22) - (wr[0] * b22[0]);
	                        c22i = -wi[0] * b22[0];

	                        if ( (Math.abs(c11r) + Math.abs(c11i) + Math.abs(c12)) > (Math.abs(c21) + Math.abs(c22r) + Math
	                                .abs(c22i))) {
	                            t1 = dlapy3(c12, c11r, c11i);
	                            cz = c12 / t1;
	                            szr = -c11r / t1;
	                            szi = -c11i / t1;
	                        } // if (Math.abs(c11r)+Math.abs(c11i)+Math.abs(c12) >
	                        else {
	                            cz = dlapy2(c22r, c22i);

	                            if (cz <= safmin) {
	                                cz = 0.0;
	                                szr = 1.0;
	                                szi = 0.0;
	                            } // if (cz <= safmin)
	                            else {
	                                tempr[0] = c22r / cz;
	                                tempi = c22i / cz;
	                                t1 = dlapy2(cz, c21);
	                                cz = cz / t1;
	                                szr = -c21 * tempr[0] / t1;
	                                szi = c21 * tempi / t1;
	                            } // else
	                        } // else

	                        // Compute Givens rotation on left
	                        // ( CQ SQ)
	                        // ( ) H or T
	                        // (comp(-SQ) CQ)
	                        an = Math.abs(a11) + Math.abs(a12) + Math.abs(a21) + Math.abs(a22);
	                        bn = Math.abs(b11[0]) + Math.abs(b22[0]);
	                        wabs = Math.abs(wr[0]) + Math.abs(wi[0]);

	                        if ( (s1[0] * an) > (wabs * bn)) {
	                            cq = cz * b11[0];
	                            sqr = szr * b22[0];
	                            sqi = -szi * b22[0];
	                        } // if (s1[0]*an > wabs*bn)
	                        else {
	                            a1r = (cz * a11) + (szr * a12);
	                            a1i = szi * a12;
	                            a2r = (cz * a21) + (szr * a22);
	                            a2i = szi * a22;
	                            cq = dlapy2(a1r, a1i);

	                            if (cq <= safmin) {
	                                cq = 0.0;
	                                sqr = 1.0;
	                                sqi = 0.0;
	                            } // if (cq <= safmin)
	                            else {
	                                tempr[0] = a1r / cq;
	                                tempi = a1i / cq;
	                                sqr = (tempr[0] * a2r) + (tempi * a2i);
	                                sqi = (tempi * a2r) - (tempr[0] * a2i);
	                            } // else
	                        } // else

	                        t1 = dlapy3(cq, sqr, sqi);
	                        cq = cq / t1;
	                        sqr = sqr / t1;
	                        sqi = sqi / t1;

	                        // Compute diagonal elements of QBZ
	                        tempr[0] = (sqr * szr) - (sqi * szi);
	                        tempi = (sqr * szi) + (sqi * szr);
	                        b1r = (cq * cz * b11[0]) + (tempr[0] * b22[0]);
	                        b1i = tempi * b22[0];
	                        b1a = dlapy2(b1r, b1i);
	                        b2r = (cq * cz * b22[0]) + (tempr[0] * b11[0]);
	                        b2i = -tempi * b11[0];
	                        b2a = dlapy2(b2r, b2i);

	                        // Normalize so beta > 0, and Im(alpha1) > 0
	                        beta[ilast - 2] = b1a;
	                        beta[ilast - 1] = b2a;
	                        alphar[ilast - 2] = (wr[0] * b1a) * s1inv;
	                        alphai[ilast - 2] = (wi[0] * b1a) * s1inv;
	                        alphar[ilast - 1] = (wr[0] * b2a) * s1inv;
	                        alphai[ilast - 1] = - (wi[0] * b2a) * s1inv;

	                        // Step 3: Go to next block -- exit if finished
	                        ilast = ifirst - 1;

	                        if (ilast < ilo) {
	                            break loop1;
	                        } // if (ilast < ilo)

	                        // Reset counters
	                        iiter = 0;
	                        eshift = 0.0;

	                        if ( !ilschr) {
	                            ilastm = ilast;

	                            if (ifrstm > ilast) {
	                                ifrstm = ilo;
	                            } // if (ifrstm > ilast)
	                        } // if (!ilschr)

	                        break loop2;
	                    } // if (ifirst+1 == ilast)
	                    else {
	                        // Usual case: 3x3 or larger block, using Francis implicit
	                        // double-shift

	                        // Eigenvalue equation is w**2 - cw + d = 0,
	                        // so compute 1st column of (HTInverse)**2 - c H TInverse + d
	                        // using the formula in QZIT (from EISPACK)

	                        // We assume the block is at least 3x3
	                        ad11 = (ascale * H[ilast - 2][ilast - 2]) / (bscale * T[ilast - 2][ilast - 2]);
	                        ad21 = (ascale * H[ilast - 1][ilast - 2]) / (bscale * T[ilast - 2][ilast - 2]);
	                        ad12 = (ascale * H[ilast - 2][ilast - 1]) / (bscale * T[ilast - 1][ilast - 1]);
	                        ad22 = (ascale * H[ilast - 1][ilast - 1]) / (bscale * T[ilast - 1][ilast - 1]);
	                        u12 = T[ilast - 2][ilast - 1] / T[ilast - 1][ilast - 1];
	                        ad11L = (ascale * H[ifirst - 1][ifirst - 1]) / (bscale * T[ifirst - 1][ifirst - 1]);
	                        ad21L = (ascale * H[ifirst][ifirst - 1]) / (bscale * T[ifirst - 1][ifirst - 1]);
	                        ad12L = (ascale * H[ifirst - 1][ifirst]) / (bscale * T[ifirst][ifirst]);
	                        ad22L = (ascale * H[ifirst][ifirst]) / (bscale * T[ifirst][ifirst]);
	                        ad32L = (ascale * H[ifirst + 1][ifirst]) / (bscale * T[ifirst][ifirst]);
	                        u12L = T[ifirst - 1][ifirst] / T[ifirst][ifirst];

	                        v[0] = ( (ad11 - ad11L) * (ad22 - ad11L) * ad12 * ad21) + (ad21 * u12 * ad11L)
	                                + ( (ad12L - (ad11L * u12L)) * ad21L);
	                        v[1] = ( (ad22L - ad11L) - (ad21L * u12L) - (ad11 - ad11L) - (ad22 - ad11L) + (ad21 * u12))
	                                * ad21L;
	                        v[2] = ad32L * ad21L;

	                        istart = ifirst;
	                        dx = new double[2];
	                        dx[0] = v[1];
	                        dx[1] = v[2];
	                        dlarfg(3, v, dx, 1, tau);
	                        v[1] = dx[0];
	                        v[2] = dx[1];
	                        v[0] = 1.0;

	                        // Sweep
	                        for (j = istart; j <= (ilast - 2); j++) {

	                            // All but last elements: use 3x3 Householder transforms.
	                            // Zero (j-2)st column of H
	                            if (j > istart) {
	                                v[0] = H[j - 1][j - 2];
	                                v[1] = H[j][j - 2];
	                                v[2] = H[j + 1][j - 2];
	                                dx = new double[1];
	                                dx[0] = H[j - 1][j - 2];
	                                dy = new double[2];
	                                dy[0] = v[1];
	                                dy[1] = v[2];
	                                dlarfg(3, dx, dy, 1, tau);
	                                H[j - 1][j - 2] = dx[0];
	                                v[1] = dy[0];
	                                v[2] = dy[1];
	                                v[0] = 1.0;
	                                H[j][j - 2] = 0.0;
	                                H[j + 1][j - 2] = 0.0;
	                            } // if (j > istart)

	                            for (jc = j; jc <= ilastm; jc++) {
	                                temp[0] = tau[0]
	                                        * (H[j - 1][jc - 1] + (v[1] * H[j][jc - 1]) + (v[2] * H[j + 1][jc - 1]));
	                                H[j - 1][jc - 1] = H[j - 1][jc - 1] - temp[0];
	                                H[j][jc - 1] = H[j][jc - 1] - (temp[0] * v[1]);
	                                H[j + 1][jc - 1] = H[j + 1][jc - 1] - (temp[0] * v[2]);
	                                temp2[0] = tau[0]
	                                        * (T[j - 1][jc - 1] + (v[1] * T[j][jc - 1]) + (v[2] * T[j + 1][jc - 1]));
	                                T[j - 1][jc - 1] = T[j - 1][jc - 1] - temp2[0];
	                                T[j][jc - 1] = T[j][jc - 1] - (temp2[0] * v[1]);
	                                T[j + 1][jc - 1] = T[j + 1][jc - 1] - (temp2[0] * v[2]);
	                            } // for (jc = j; jc <= ilastm; jc++)

	                            if (ilq) {

	                                for (jr = 1; jr <= n; jr++) {
	                                    temp[0] = tau[0]
	                                            * (Q[jr - 1][j - 1] + (v[1] * Q[jr - 1][j]) + (v[2] * Q[jr - 1][j + 1]));
	                                    Q[jr - 1][j - 1] = Q[jr - 1][j - 1] - temp[0];
	                                    Q[jr - 1][j] = Q[jr - 1][j] - (temp[0] * v[1]);
	                                    Q[jr - 1][j + 1] = Q[jr - 1][j + 1] - (temp[0] * v[2]);
	                                } // for (jr = 1; jr <= n; jr++)
	                            } // if (ilq)

	                            // Zero (j-1)-st column of T (see dlagbc for details)
	                            // Swap rows to pivot
	                            ilpivt = false;
	                            temp[0] = Math.max(Math.abs(T[j][j]), Math.abs(T[j][j + 1]));
	                            temp2[0] = Math.max(Math.abs(T[j + 1][j]), Math.abs(T[j + 1][j + 1]));

	                            loop3: {

	                                if (Math.max(temp[0], temp2[0]) < safmin) {
	                                    scale = 0.0;
	                                    u1 = 1.0;
	                                    u2 = 0.0;

	                                    break loop3;
	                                } // if (Math.max(temp[0],temp2[0]) < safmin)
	                                else if (temp[0] >= temp2[0]) {
	                                    w11 = T[j][j];
	                                    w21 = T[j + 1][j];
	                                    w12 = T[j][j + 1];
	                                    w22 = T[j + 1][j + 1];
	                                    u1 = T[j][j - 1];
	                                    u2 = T[j + 1][j - 1];
	                                } // else if (temp[0] >= temp2[0])
	                                else {
	                                    w21 = T[j][j];
	                                    w11 = T[j + 1][j];
	                                    w22 = T[j][j + 1];
	                                    w12 = T[j + 1][j + 1];
	                                    u2 = T[j][j - 1];
	                                    u1 = T[j + 1][j - 1];
	                                } // else

	                                // Sweap columns if necessary
	                                if (Math.abs(w12) > Math.abs(w11)) {
	                                    ilpivt = true;
	                                    temp[0] = w12;
	                                    temp2[0] = w22;
	                                    w12 = w11;
	                                    w22 = w21;
	                                    w11 = temp[0];
	                                    w21 = temp2[0];
	                                } // if (Math.abs(w12) > Math.abs(w11))

	                                // LU-factor
	                                temp[0] = w21 / w11;
	                                u2 = u2 - (temp[0] * u1);
	                                w22 = w22 - (temp[0] * w12);
	                                w21 = 0.0;

	                                // Compute scale
	                                scale = 1.0;

	                                if (Math.abs(w22) < safmin) {
	                                    scale = 0.0;
	                                    u2 = 1.0;
	                                    u1 = -w12 / w11;

	                                    break loop3;
	                                } // if (Math.abs(w22) < safmin)

	                                if (Math.abs(w22) < Math.abs(u2)) {
	                                    scale = Math.abs(w22 / u2);
	                                } // if (Math.abs(w22) < Math.abs(u2))

	                                if (Math.abs(w11) < Math.abs(u1)) {
	                                    scale = Math.min(scale, Math.abs(w11 / u1));
	                                } // if (Math.abs(w11) < Math.abs(u1))

	                                // Solve
	                                u2 = (scale * u2) / w22;
	                                u1 = ( (scale * u1) - (w12 * u2)) / w11;
	                            } // loop3

	                            if (ilpivt) {
	                                temp[0] = u2;
	                                u2 = u1;
	                                u1 = temp[0];
	                            } // if (ilpivt)

	                            // Compute Householder vector
	                            t1 = Math.sqrt( (scale * scale) + (u1 * u1) + (u2 * u2));
	                            tau[0] = 1.0 + (scale / t1);
	                            vs = -1.0 / (scale + t1);
	                            v[0] = 1.0;
	                            v[1] = vs * u1;
	                            v[2] = vs * u2;

	                            // Apply transformations from the right
	                            for (jr = ifrstm; jr <= Math.min(j + 3, ilast); jr++) {
	                                temp[0] = tau[0]
	                                        * (H[jr - 1][j - 1] + (v[1] * H[jr - 1][j]) + (v[2] * H[jr - 1][j + 1]));
	                                H[jr - 1][j - 1] = H[jr - 1][j - 1] - temp[0];
	                                H[jr - 1][j] = H[jr - 1][j] - (temp[0] * v[1]);
	                                H[jr - 1][j + 1] = H[jr - 1][j + 1] - (temp[0] * v[2]);
	                            } // for (jr = ifrstm; jr <= Math.min(j+3,ilast); jr++)

	                            for (jr = ifrstm; jr <= (j + 2); jr++) {
	                                temp[0] = tau[0]
	                                        * (T[jr - 1][j - 1] + (v[1] * T[jr - 1][j]) + (v[2] * T[jr - 1][j + 1]));
	                                T[jr - 1][j - 1] = T[jr - 1][j - 1] - temp[0];
	                                T[jr - 1][j] = T[jr - 1][j] - (temp[0] * v[1]);
	                                T[jr - 1][j + 1] = T[jr - 1][j + 1] - (temp[0] * v[2]);
	                            } // for (jr = ifrstm; jr <= j+2; jr++)

	                            if (ilz) {

	                                for (jr = 1; jr <= n; jr++) {
	                                    temp[0] = tau[0]
	                                            * (Z[jr - 1][j - 1] + (v[1] * Z[jr - 1][j]) + (v[2] * Z[jr - 1][j + 1]));
	                                    Z[jr - 1][j - 1] = Z[jr - 1][j - 1] - temp[0];
	                                    Z[jr - 1][j] = Z[jr - 1][j] - (temp[0] * v[1]);
	                                    Z[jr - 1][j + 1] = Z[jr - 1][j + 1] - (temp[0] * v[2]);
	                                } // for (jr = 1; jr <= n; jr++)
	                            } // if (ilz)

	                            T[j][j - 1] = 0.0;
	                            T[j + 1][j - 1] = 0.0;
	                        } // for (j = istart; j <= ilast-2; j++)

	                        // Last elements: Use Givens rotations
	                        // Rotations from the left
	                        j = ilast - 1;
	                        temp[0] = H[j - 1][j - 2];
	                        dlartg(temp[0], H[j][j - 2], c, s, hout);
	                        H[j - 1][j - 2] = hout[0];
	                        H[j][j - 2] = 0.0;

	                        for (jc = j; jc <= ilastm; jc++) {
	                            temp[0] = (c[0] * H[j - 1][jc - 1]) + (s[0] * H[j][jc - 1]);
	                            H[j][jc - 1] = ( -s[0] * H[j - 1][jc - 1]) + (c[0] * H[j][jc - 1]);
	                            H[j - 1][jc - 1] = temp[0];
	                            temp2[0] = (c[0] * T[j - 1][jc - 1]) + (s[0] * T[j][jc - 1]);
	                            T[j][jc - 1] = ( -s[0] * T[j - 1][jc - 1]) + (c[0] * T[j][jc - 1]);
	                            T[j - 1][jc - 1] = temp2[0];
	                        } // for (jc = j; jc <= ilastm; jc++)

	                        if (ilq) {

	                            for (jr = 1; jr <= n; jr++) {
	                                temp[0] = (c[0] * Q[jr - 1][j - 1]) + (s[0] * Q[jr - 1][j]);
	                                Q[jr - 1][j] = ( -s[0] * Q[jr - 1][j - 1]) + (c[0] * Q[jr - 1][j]);
	                                Q[jr - 1][j - 1] = temp[0];
	                            } // for (jr = 1; jr <= n; jr++)
	                        } // if (ilq)

	                        // Rotations from the right
	                        temp[0] = T[j][j];
	                        dlartg(temp[0], T[j][j - 1], c, s, tout);
	                        T[j][j] = tout[0];
	                        T[j][j - 1] = 0.0;

	                        for (jr = ifrstm; jr <= ilast; jr++) {
	                            temp[0] = (c[0] * H[jr - 1][j]) + (s[0] * H[jr - 1][j - 1]);
	                            H[jr - 1][j - 1] = ( -s[0] * H[jr - 1][j]) + (c[0] * H[jr - 1][j - 1]);
	                            H[jr - 1][j] = temp[0];
	                        } // for (jr = ifrstm; jr <= ilast; jr++)

	                        for (jr = ifrstm; jr <= (ilast - 1); jr++) {
	                            temp[0] = (c[0] * T[jr - 1][j]) + (s[0] * T[jr - 1][j - 1]);
	                            T[jr - 1][j - 1] = ( -s[0] * T[jr - 1][j]) + (c[0] * T[jr - 1][j - 1]);
	                            T[jr - 1][j] = temp[0];
	                        } // for (jr = ifrstm; jr <= ilast-1; jr++)

	                        if (ilz) {

	                            for (jr = 1; jr <= n; jr++) {
	                                temp[0] = (c[0] * Z[jr - 1][j]) + (s[0] * Z[jr - 1][j - 1]);
	                                Z[jr - 1][j - 1] = ( -s[0] * Z[jr - 1][j]) + (c[0] * Z[jr - 1][j - 1]);
	                                Z[jr - 1][j] = temp[0];
	                            } // for (jr = 1; jr <= n; jr++)
	                        } // if (ilz)

	                        // End of Double-Shift code
	                    } // else

	                    // End of iteration loop
	                } // loop2
	            } // for (jiter = 1; jiter <= maxit; jiter++)

	            // Drop-through = non-convergence
	            info[0] = ilast;
	            work[0] = (double) n;

	            return;
	        } // loop1

	        // Successful completion of all QZ steps
	        // Set eigenvalues 0:ilo-2
	        for (j = 0; j < (ilo - 1); j++) {

	            if (T[j][j] < 0.0) {

	                if (ilschr) {

	                    for (jr = 0; jr <= j; jr++) {
	                        H[jr][j] = -H[jr][j];
	                        T[jr][j] = -T[jr][j];
	                    } // for (jr = 0; jr <= j; jr++)
	                } // if (ilschr)
	                else {
	                    H[j][j] = -H[j][j];
	                    T[j][j] = -T[j][j];
	                } // else

	                if (ilz) {

	                    for (jr = 0; jr < n; jr++) {
	                        Z[jr][j] = -Z[jr][j];
	                    } // for (jr = 0; jr < n; jr++)
	                } // if (ilz)
	            } // if (B[j][j] < 0.0)

	            alphar[j] = H[j][j];
	            alphai[j] = 0.0;
	            beta[j] = T[j][j];
	        } // for (j = 0; j < ilo-1; j++)

	        // Normal termination
	        info[0] = 0;

	        // Exit (other than argument error) -- return optimal workspace size
	        work[0] = (double) n;

	        return;
	    } // dhgeqz

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLABAD Original DLABAD created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlabad takes as input the
	     * values computed by dlamch for underflow and overflow, and returns the square root of each of these values if the
	     * log of large is sufficiently big. This routine is intended to identify machines with a large exponent range, such
	     * as the Crays, and redefine the underflow and overflow limits to be the square roots fo the values computed by
	     * dlamch. This subroutine is needed because dlamch does not compensate for poor arithmetic in the upper half of the
	     * exponent range, as is found on a Cray.
	     * 
	     * @param small input/ouptut double[] On entry, the underflow threshold as computed by dlamch. On exit, if
	     *            log10(large) is sufficiently large, the square root of small, otherwise unchanged.
	     * @param large input/output double[] On entry, the overflow threshold as computed by dlamch. On exit, if
	     *            log10(large) is sufficiently large, the square root of large, otherwise unchanged.
	     */
	    private void dlabad(final double[] small, final double[] large) {

	        // If it looks like we're on a Cray, take the square root of small and
	        // large to avoid overflow and underflow problems.
	        if ( (0.4342944819 * Math.log(large[0])) > 2000.0) {
	            small[0] = Math.sqrt(small[0]);
	            large[0] = Math.sqrt(large[0]);
	        }

	        return;
	    } // dlabad

	    /**
	     * This is a port of LAPACK version 3.2 auxiliary routine DLACPY. Original DLACPY created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlacpy copies all or part of
	     * a two-dimensional matrix A to another matrix B.
	     * 
	     * @param uplo input char Specifies the part of the matrix A to be copied to B. = 'U': Upper triangular part = 'L':
	     *            Lower triangular part Otherwise: All of the matrix A
	     * @param m input int The number of rows of the matrix A. m >= 0.
	     * @param n input int The number of columns of the matrix A. n >= 0.
	     * @param A input double[][] of dimension (lda,n). Has m by n matrix A. If uplo = 'U', only the upper triangle or
	     *            trapezoid is accessed; if uplo = 'L', only the lower triangle or trapezoid is accessed.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     * @param B output double[][] of dimension (ldb,n). On exit, B = A in the locations specified by uplo.
	     * @param ldb input int The leading dimension of the array B. ldb >= max(1,m).
	     */
	    private void dlacpy(final char uplo, final int m, final int n, final double[][] A, final int lda,
	            final double[][] B, final int ldb) {
	        int i, j;

	        if ( (uplo == 'U') || (uplo == 'u')) {

	            for (j = 0; j < n; j++) {

	                for (i = 0; i <= Math.min(j, m - 1); i++) {
	                    B[i][j] = A[i][j];
	                }
	            }
	        } // if ((uplo == 'U') || (uplo == 'u'))
	        else if ( (uplo == 'L') || (uplo == 'l')) {

	            for (j = 0; j < n; j++) {

	                for (i = j; i < m; i++) {
	                    B[i][j] = A[i][j];
	                }
	            }
	        } // else if ((uplo == 'L') || (uplo == 'l'))
	        else {

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    B[i][j] = A[i][j];
	                }
	            }
	        } // else
	        return;
	    } // dlacpy

	    /**
	     * This is a port of version 3.7.0 LAPACK auxiliary routine DLADIV Original DLADIV created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., Januaary, 2013 dladiv performs complex division in real arithmetic
	     *  p + i*q = (a + i*b) / (c + i*d) The algorithm is due to Michael Baudin and RObert L. Smith and can be found
	     *  in the paper "A Robust Complex Division in Scilab".
	     * 
	     * @param a input double
	     * @param b input double
	     * @param c input double
	     * @param d input double
	     * @param p output double[]
	     * @param q output double[]
	     */
	    private void dladiv(final double a, final double b, final double c, final double d, final double[] p,
	            final double[] q) {
	    	final double bs = 2.0;
	        double aa, bb, cc, dd, ab, cd, s, ov, un, be, eps;

	        aa = a;
	        bb = b;
	        cc = c;
	        dd = d;
	        ab = Math.max(Math.abs(a), Math.abs(b));
	        cd = Math.max(Math.abs(c), Math.abs(d));
	        s = 1.0;
	        
	        ov = dlamch('O');
	        un = dlamch('S');
	        eps = dlamch('E');
	        be = bs / (eps * eps);
	        
	        if (ab >= 0.5 * ov) {
	        	aa = 0.5 * aa;
	        	bb = 0.5 * bb;
	        	s = 2.0 * s;
	        }
	        if (cd >= 0.5*ov) {
	        	cc = 0.5 * cc;
	        	dd = 0.5 * dd;
	        	s = 0.5 * s;
	        }
	        if (ab <= un*bs/eps) {
	        	aa = aa * be;
	        	bb = bb * be;
	        	s = s / be;
	        }
	        if (cd <= un*bs/eps) {
	        	cc = cc * be;
	        	dd = dd * be;
	        	s = s * be;
	        }
	        if (Math.abs(d) <= Math.abs(c)) {
	        	dladiv1(aa, bb, cc, dd, p, q);
	        }
	        else {
	        	dladiv1(bb, aa, dd, cc, p, q);
	        	q[0] = -q[0];
	        }
	        
	        p[0] = p[0] * s;
	        q[0] = q[0] * s;

	        return;
	    } // dladiv
	    
	    /**
	     * LAPACK auxiliary routine (version 3.7.0)
	     * LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of
	     * Colorado Denver, and NAG Ltd, January, 2013.
	     * @param a
	     * @param b
	     * @param c
	     * @param d
	     * @param p
	     * @param q
	     */
	    private void dladiv1(double a, double b, double c, double d, double p[], double q[]) {
	        double r, t;
	        r = d/c;
	        t = 1.0/(c + d * r);
	        p[0] = dladiv2(a, b, c, d, r, t);
	        a = -a;
	        q[0] = dladiv2(b, a, c, d, r, t);
	        return;
	    }
	    
	    /**
	     * LAPACK auxiliary routine version 3.7.0
	     * LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of
	     * Colorado Denver, and NAG Ltd, January, 2013.
	     * @param a
	     * @param b
	     * @param c
	     * @param d
	     * @param r
	     * @param t
	     * @return
	     */
	    private double dladiv2(double a, double b, double c, double d, double r, double t) {
	        double br;
	        
	        if (r != 0.0) {
	        	br = b * r;
	        	if (br != 0.0) {
	        		return ((a + br) * t);
	        	}
	        	else {
	        	    return (a*t + (b*t) * r);
	        	}
	        }
	        else {
	        	return ((a + d * (b/c)) * t);
	        }
	    }

	    /**
	     * This is a port of the version 3.1 LAPACK auxiliary routine DLAE2 Original DLAE2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlae2 computes the eigenvalues of a 2-by-2 symmetric
	     * matrix [ A B ] [ B C ] On return, rt1[0] is the eigenvalue of the larger absolute value, and rt2[0] is the
	     * eigenvalue of the smaller absolute value.
	     * 
	     * @param a input double The 0,0 element of the 2-by-2 matrix.
	     * @param b input double The 0,1 and 1,0 elements of the 2-by-2 matrix.
	     * @param c input double The 1,1 element of the 2-by-2 matrix.
	     * @param rt1 output double[] The eigenvalue of the larger absolute value.
	     * @param rt2 output double[] The eigenvalue of the smaller absolute value. Further Details: rt1 is accurate to a
	     *            few ulps barring over/underflow. rt2 may be inaccurate if there is massive cancellation in the
	     *            determinant A*C - B*B; higher precision or correctly rounded or correctly truncated arithmetic would
	     *            be needed to compute rt2 accurately in all cases. Overflow is possible only if rt1 is within a factor
	     *            of 5 of overflow. Underflow is harmless if the input data is 0 or exceeds underflow_threshold /
	     *            macheps.
	     */
	    private void dlae2(final double a, final double b, final double c, final double[] rt1, final double[] rt2) {
	        double ab;
	        double acmn;
	        double acmx;
	        double adf;
	        double df;
	        double rt;
	        double sm;
	        double tb;
	        double ratio;

	        // Compute the eigenvalues
	        sm = a + c;
	        df = a - c;
	        adf = Math.abs(df);
	        tb = b + b;
	        ab = Math.abs(tb);

	        if (Math.abs(a) > Math.abs(c)) {
	            acmx = a;
	            acmn = c;
	        } else {
	            acmx = c;
	            acmn = a;
	        }

	        if (adf > ab) {
	            ratio = ab / adf;
	            rt = adf * Math.sqrt(1.0 + (ratio * ratio));
	        } else if (adf < ab) {
	            ratio = adf / ab;
	            rt = ab * Math.sqrt(1.0 + (ratio * ratio));
	        } else {

	            // Includes case ab = adf = 0
	            rt = ab * Math.sqrt(2.0);
	        }

	        if (sm < 0.0) {
	            rt1[0] = 0.5 * (sm - rt);
	            rt2[0] = ( (acmx / rt1[0]) * acmn) - ( (b / rt1[0]) * b);
	        } else if (sm > 0.0) {
	            rt1[0] = 0.5 * (sm + rt);
	            rt2[0] = ( (acmx / rt1[0]) * acmn) - ( (b / rt1[0]) * b);
	        } else {

	            // Includes cases rt1[0] = rt2[0] = 0
	            rt1[0] = 0.5 * rt;
	            rt2[0] = -0.5 * rt;
	        }

	        return;
	    } // dlae2

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine DLAEV2 Original DLAEV2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlaev2 computes the eigendecomposition of a 2-by-2
	     * symmetric matrix [ a b ] [ b c ] On return rt1[0] is the eigenvalue of the larger absolute value, rt2[0] is the
	     * eigenvalue of the smaller absolute value, and (cs1, sn1) is the unit right eigenvector for rt1[0], giving the
	     * decomposition [ cs1 sn1 ] [ a b ] [cs1 -sn1] = [rt1 0 ] [-sn1 cs1 ] [ b c ] [sn1 cs1] [ 0 rt2]
	     * 
	     * @param a input double The (0,0) element of the 2-by-2 matrix
	     * @param b input double The (0,1) element and the conjugate of the (1,0) element of the 2-by-2 matrix.
	     * @param c input double The (1,1) element of the 2-by-2 matrix.
	     * @param rt1 output double[] The eigenvalue of larger absolute value.
	     * @param rt2 output double[] The eigenvalue of smaller absolute value.
	     * @param cs1 output double[]
	     * @param sn1 output double[] The vector (cs1, sn1) is a unit right eigenvector for rt1[0]. Further details: rt1[0]
	     *            is accurate to a few ulps barring over/underflow. rt2[0] may be inaccurate if there is massive
	     *            cancellation in the determinant a*c - b*b; higher precision or correctly rounded or correctly
	     *            truncated arithmetic would be needed to compute rt2[0] accurately in all cases. cs1[0] and sn1[0] are
	     *            accurate to a few ulps barring over/underflow. Overflow if possible only if rt1[0] is within a factor
	     *            of 5 of overflow. Underflow is harmless if the input data is 0 or exceeds underflow_threshold/macheps.
	     */
	    private void dlaev2(final double a, final double b, final double c, final double[] rt1, final double[] rt2,
	            final double[] cs1, final double[] sn1) {
	        int sgn1;
	        int sgn2;
	        double ab;
	        double acmn;
	        double acmx;
	        double acs;
	        double adf;
	        double cs;
	        double ct;
	        double df;
	        double rt;
	        double sm;
	        double tb;
	        double tn;
	        double ratio;

	        // Compute the eigenvalues.
	        sm = a + c;
	        df = a - c;
	        adf = Math.abs(df);
	        tb = b + b;
	        ab = Math.abs(tb);

	        if (Math.abs(a) > Math.abs(c)) {
	            acmx = a;
	            acmn = c;
	        } else {
	            acmx = c;
	            acmn = a;
	        }

	        if (adf > ab) {
	            ratio = ab / adf;
	            rt = adf * Math.sqrt(1.0 + (ratio * ratio));
	        } else if (adf < ab) {
	            ratio = adf / ab;
	            rt = ab * Math.sqrt(1.0 + (ratio * ratio));
	        } else {

	            // Includes case ab = adf = 0
	            rt = ab * Math.sqrt(2.0);
	        }

	        if (sm < 0.0) {
	            rt1[0] = 0.5 * (sm - rt);
	            sgn1 = -1;
	            rt2[0] = ( (acmx / rt1[0]) * acmn) - ( (b / rt1[0]) * b);
	        } else if (sm > 0.0) {
	            rt1[0] = 0.5 * (sm + rt);
	            sgn1 = 1;
	            rt2[0] = ( (acmx / rt1[0]) * acmn) - ( (b / rt1[0]) * b);
	        } else {

	            // Includes case rt1[0] = rt2[0] = 0
	            rt1[0] = 0.5 * rt;
	            rt2[0] = -0.5 * rt;
	            sgn1 = 1;
	        }

	        // Compute the eigenvector
	        if (df >= 0.0) {
	            cs = df + rt;
	            sgn2 = 1;
	        } else {
	            cs = df - rt;
	            sgn2 = -1;
	        }

	        acs = Math.abs(cs);

	        if (acs > ab) {
	            ct = -tb / cs;
	            sn1[0] = 1.0 / Math.sqrt(1.0 + (ct * ct));
	            cs1[0] = ct * sn1[0];
	        } else {

	            if (ab == 0.0) {
	                cs1[0] = 1.0;
	                sn1[0] = 0.0;
	            } else {
	                tn = -cs / tb;
	                cs1[0] = 1.0 / Math.sqrt(1.0 + (tn * tn));
	                sn1[0] = tn * cs1[0];
	            }
	        }

	        if (sgn1 == sgn2) {
	            tn = cs1[0];
	            cs1[0] = -sn1[0];
	            sn1[0] = tn;
	        }

	        return;
	    } // dlaev2

	    /**
	     * This is a port of the version 3.1 LAPACK auxiliary test routine DLAFTS Original DLAFTS created by Univ. of
	     * Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006 dlafts tests the result vector against the
	     * threshold value to see which tests for this matrix type failed to pass the threshold.
	     * 
	     * @param type input String On entry, type specifies the matrix type to be used in the printed messages
	     * @param m input int rows of matrix
	     * @param n input int On entry, n specifies the order the of test matrix. columns of matrix
	     * @param imat input int On entry, imat specifies the type of the test matrix. A listing of the different types is
	     *            printed by dlahd2 if a test fails to pass the threshold.
	     * @param ntests input int On entry, ntests is the number of tests performed on the subroutines in the path given by
	     *            type.
	     * @param result input double[] of dimension ntests On entry, result contains the test ratios from the tests
	     *            performed in the calling program.
	     * @param iseed input int[] of dimension 4. Contains the random seed that generated the matrix used for the tests
	     *            whose ratios are in result.
	     * @param thresh input double On entry, thresh specifies the acceptable threshold of the test ratios. if result[k-1]
	     *            > thresh, then the k-th test did not pass the threshold and a message will be printed.
	     * @param ie input/output int[] On entry, ie contains the number of tests which have failed to pass the threshold so
	     *            far. Updated on exit if any of the ratios in result also fail.
	     */
	    private void dlafts(final String type, final int m, final int n, final int imat, final int ntests,
	            final double[] result, final int[] iseed, final double thresh, final int[] ie) {
	        int k;

	        if (m == n) {

	            // Output for square matrices
	            for (k = 0; k < ntests; k++) {

	                if (result[k] >= thresh) {

	                    // If this is the first test to fail, call dlahd2 to print
	                    // a header to the file
	                    if (ie[0] == 0) {
	                        dlahd2(type);
	                    }

	                    ie[0] = ie[0] + 1;
	                    System.out.println("Matrix of order = " + n + " type = " + imat + "\n");
	                    System.out.println("Test = " + (k + 1) + " ratio = " + result[k] + "\n");
	                    System.out.println("iseed[0] = " + iseed[0] + " iseed[1] = " + iseed[1] + "\n");
	                    System.out.println("iseed[2] = " + iseed[2] + " iseed[3] = " + iseed[3] + "\n");
	                } // if (result[k] >= thresh)
	            } // for (k = 0; k < ntests; k++)
	        } // if (m == n)
	        else { // m != n

	            // Output for rectangular matrices
	            for (k = 0; k < ntests; k++) {

	                if (result[k] >= thresh) {

	                    // If this is the first test to fail, call dlahd2 to print
	                    // a header to the file
	                    if (ie[0] == 0) {
	                        dlahd2(type);
	                    }

	                    ie[0] = ie[0] + 1;
	                    System.out.println("Matrix of size = " + m + " by " + n + " type = " + imat + "\n");
	                    System.out.println("Test = " + (k + 1) + " ratio = " + result[k] + "\n");
	                    System.out.println("iseed[0] = " + iseed[0] + " iseed[1] = " + iseed[1] + "\n");
	                    System.out.println("iseed[2] = " + iseed[2] + " iseed[3] = " + iseed[3] + "\n");
	                } // if (result[k] >= thresh)
	            } // for (k = 0; k < ntests; k++)
	        } // else m!= n
	    } // dlafts

	    /**
	     * This is a port of the version 3.1 LAPACK auxiliary routine DLAG2 Original DLAG2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlag2 computes eigenvalues of a 2 x 2 generalized
	     * eigenvalue problem A - w B, with scaling as necessary to avoid over-/underflow.
	     * 
	     * <p>
	     * The scaling factor "s" results in a modified eigenvalue equation s A - w B where s is a nonnegative scaling
	     * factor chosen so that w, w B, and s A do not overflow and, if possible, do not underflow, either.
	     * </p>
	     * 
	     * @param A input double[][] of dimension (lda,2) On entry, the 2 x 2 matrix A. It is assumed that its 1-norm is
	     *            less than 1/safmin. Entries less than sqrt(safmin)*norm(A) are subject to being treated as zero.
	     * @param lda input int The leading dimension of the array A. lda >= 2.
	     * @param B input double[][] of dimension (ldb,2) On entry, the 2 x 2 upper triangular matrix B. It is assumed that
	     *            the one-norm of B is less than 1/safmin. The diagonals should be at least sqrt(safmin) times the
	     *            largest element of B (in absolute value); if a diagonal is smaller than that, then +/- sqrt(safmin)
	     *            will be used instead of that diagonal.
	     * @param ldb input int The leading dimension of the array B. ldb >= 2.
	     * @param safmin input double The smallest positive number such that 1/safmin does not overflow. (This should always
	     *            be dlamch('S') -- it is an argument in order to avoid having to call dlamch frequently.)
	     * @param scale1 output double[] A scaling factor used to avoid over-/ underflow in the eigenvalue equation which
	     *            defines the first eigenvalue. If the eigenvalues are complex, then the eigenvalues are (wr1 +/-
	     *            wi*i)/scale1 (which may lie outside the exponent range of the machine), scale1 = scale2, and scale1
	     *            will always be positive. If the eigenvalues are real, then the first (real) eigenvalue is wr1/scale1,
	     *            but this may overflow or underflow, and in fact, scale1 may be zero or less than the underflow
	     *            threshold if the exact eigenvalue is sufficiently large.
	     * @param scale2 output double[] A scaling factor used to avoid over-/ underflow in th eigenvalue equation which
	     *            defines the second eigenvalue. If the eigenvalues are complex, then scale2 = scale1. If the
	     *            eigenvalues are real, then the second (real) eigenvalue is wr2 / scale2, but this may overflow or
	     *            underflow, and in fact, scale2 may be zero or less than the underflow threshold if the exact
	     *            eigenvalue is sufficiently large.
	     * @param wr1 output double[] If the eigenvalue is real, then wr1 is scale1 times the eigenvalue closest to the
	     *            (1,1) element of A B**(-1). If the eigenvalue is complex, then wr1 = wr2 is scale1 times the real part
	     *            of the eigenvalues.
	     * @param wr2 output double[] If the eigenvalue is real, then wr2 is scale2 times the other eigenvalue. If the
	     *            eigenvalue is complex, then wr1 = wr2 is scale1 times the real part of the eigenvalues.
	     * @param wi output double[] If the eigenvalue is real, then wi is 0.0. If the eigenvalue is complex, then wi is
	     *            scale1 times the imaginary part of the eigenvalues. wi will always be nonnegative.
	     */
	    private void dlag2(final double[][] A, final int lda, final double[][] B, final int ldb, final double safmin,
	            final double[] scale1, final double[] scale2, final double[] wr1, final double[] wr2, final double[] wi) {
	        final double fuzzy1 = 1.0E-5;
	        double a11;
	        double a12;
	        double a21;
	        double a22;
	        double abi22;
	        double anorm;
	        double as11;
	        double as12;
	        double as22;
	        double ascale;
	        double b11;
	        double b12;
	        double b22;
	        double binv11;
	        double binv22;
	        double bmin;
	        double bnorm;
	        double bscale;
	        double bsize;
	        double c1;
	        double c2;
	        double c3;
	        double c4;
	        double c5;
	        double diff;
	        double discr;
	        double pp;
	        double qq;
	        double r;
	        double rtmax;
	        double rtmin;
	        double s1;
	        double s2;
	        double safmax;
	        double shift;
	        double ss;
	        double sum;
	        double wabs;
	        double wbig;
	        double wdet;
	        double wscale;
	        double wsize;
	        double wsmall;

	        rtmin = Math.sqrt(safmin);
	        rtmax = 1.0 / rtmin;
	        safmax = 1.0 / safmin;

	        // Scale A
	        anorm = Math.max(Math.abs(A[0][0]) + Math.abs(A[1][0]), Math.abs(A[0][1]) + Math.abs(A[1][1]));
	        anorm = Math.max(anorm, safmin);
	        ascale = 1.0 / anorm;
	        a11 = ascale * A[0][0];
	        a21 = ascale * A[1][0];
	        a12 = ascale * A[0][1];
	        a22 = ascale * A[1][1];

	        // Perturb B if necessary to insure non-singularity
	        b11 = B[0][0];
	        b12 = B[0][1];
	        b22 = B[1][1];
	        bmin = Math.max(Math.abs(b11), Math.abs(b12));
	        bmin = Math.max(bmin, Math.abs(b22));
	        bmin = Math.max(bmin, rtmin);
	        bmin = rtmin * bmin;

	        if (Math.abs(b11) < bmin) {

	            if (b11 >= 0.0) {
	                b11 = Math.abs(bmin);
	            } else {
	                b11 = -Math.abs(bmin);
	            }
	        } // if (Math.abs(b11) < bmin)

	        if (Math.abs(b22) < bmin) {

	            if (b22 >= 0.0) {
	                b22 = Math.abs(bmin);
	            } else {
	                b22 = -Math.abs(bmin);
	            }
	        } // if (Math.abs(b22) < bmin)

	        // Scale B
	        bnorm = Math.max(Math.abs(b11), Math.abs(b12) + Math.abs(b22));
	        bnorm = Math.max(bnorm, safmin);
	        bsize = Math.max(Math.abs(b11), Math.abs(b22));
	        bscale = 1.0 / bsize;
	        b11 = b11 * bscale;
	        b12 = b12 * bscale;
	        b22 = b22 * bscale;

	        // Compute the larger eigenvalue by method described by C. van Loan
	        // (as is A shifted by -shift*B)
	        binv11 = 1.0 / b11;
	        binv22 = 1.0 / b22;
	        s1 = a11 * binv11;
	        s2 = a22 * binv22;

	        if (Math.abs(s1) <= Math.abs(s2)) {
	            as12 = a12 - (s1 * b12);
	            as22 = a22 - (s1 * b22);
	            ss = a21 * (binv11 * binv22);
	            abi22 = (as22 * binv22) - (ss * b12);
	            pp = 0.5 * abi22;
	            shift = s1;
	        } // if (Math.abs(s1) <= Math.abs(s2))
	        else {
	            as12 = a12 - (s2 * b12);
	            as11 = a11 - (s2 * b11);
	            ss = a21 * (binv11 * binv22);
	            abi22 = -ss * b12;
	            pp = 0.5 * ( (as11 * binv11) + abi22);
	            shift = s2;
	        } // else

	        qq = ss * as12;

	        if (Math.abs(pp * rtmin) >= 1.0) {
	            discr = ( (rtmin * pp) * (rtmin * pp)) + (qq * safmin);
	            r = Math.sqrt(Math.abs(discr)) * rtmax;
	        } else if ( ( (pp * pp) + Math.abs(qq)) <= safmin) {
	            discr = ( (rtmax * pp) * (rtmax * pp)) + (qq * safmax);
	            r = Math.sqrt(Math.abs(discr)) * rtmin;
	        } else {
	            discr = (pp * pp) + qq;
	            r = Math.sqrt(Math.abs(discr));
	        }

	        // Note: the test of R in the following if is to cover the case when
	        // discr is small and negative and is flushed to zero during the
	        // calculation of R. On machines which have a consistent flush-to-zero
	        // threshold and handle numbers above that threshold correctly, it would
	        // not be necessary
	        if ( (discr >= 0.0) || (r == 0.0)) {

	            if (pp >= 0.0) {
	                sum = pp + Math.abs(r);
	                diff = pp - Math.abs(r);
	            } // if (pp >= 0.0)
	            else {
	                sum = pp - Math.abs(r);
	                diff = pp + Math.abs(r);
	            }

	            wbig = shift + sum;

	            // Compute smaller eigenvalue
	            wsmall = shift + diff;

	            if ( (0.5 * Math.abs(wbig)) > Math.max(Math.abs(wsmall), safmin)) {
	                wdet = ( (a11 * a22) - (a12 * a21)) * (binv11 * binv22);
	                wsmall = wdet / wbig;
	            }

	            // Choose (real) eigenvalue closest to 1,1 element of A*B**(-1) for
	            // wr1.
	            if (pp > abi22) {
	                wr1[0] = Math.min(wbig, wsmall);
	                wr2[0] = Math.max(wbig, wsmall);
	            } else {
	                wr1[0] = Math.max(wbig, wsmall);
	                wr2[0] = Math.min(wbig, wsmall);
	            }

	            wi[0] = 0.0;
	        } // if ((discr >= 0.0) || (r == 0.0))
	        else {

	            // Complex eigenvalues
	            wr1[0] = shift + pp;
	            wr2[0] = wr1[0];
	            wi[0] = r;
	        }

	        // Further scaling to avoid underflow and overflow in computing scale1
	        // and overflow in computing w*B.
	        // This scale factor (wscale) is bounded from above using c1 and c2, and
	        // from below using c3 and c4.
	        // c1 implements the condition s A must never overflow.
	        // c2 implements the condition w B must never overflow.
	        // c3, with c2, implement the condition that s A - w B must never
	        // overflow.
	        // c4 implements the condition s should not underflow.
	        // c5 implements the condition max(s,|w|) should be at least 2.
	        c1 = bsize * (safmin * Math.max(1.0, ascale));
	        c2 = safmin * Math.max(1.0, bnorm);
	        c3 = bsize * safmin;

	        if ( (ascale <= 1.0) && (bsize <= 1.0)) {
	            c4 = Math.min(1.0, (ascale / safmin) * bsize);
	        } else {
	            c4 = 1.0;
	        }

	        if ( (ascale <= 1.0) || (bsize <= 1.0)) {
	            c5 = Math.min(1.0, ascale * bsize);
	        } else {
	            c5 = 1.0;
	        }

	        // Scale first eigenvalue
	        wabs = Math.abs(wr1[0]) + Math.abs(wi[0]);
	        wsize = Math.max(safmin, c1);
	        wsize = Math.max(wsize, fuzzy1 * ( (wabs * c2) + c3));
	        wsize = Math.max(wsize, Math.min(c4, 0.5 * Math.max(wabs, c5)));

	        if (wsize != 1.0) {
	            wscale = 1.0 / wsize;

	            if (wsize > 1.0) {
	                scale1[0] = (Math.max(ascale, bsize) * wscale) * Math.min(ascale, bsize);
	            } else {
	                scale1[0] = (Math.min(ascale, bsize) * wscale) * Math.max(ascale, bsize);
	            }

	            wr1[0] = wr1[0] * wscale;

	            if (wi[0] != 0.0) {
	                wi[0] = wi[0] * wscale;
	                wr2[0] = wr1[0];
	                scale2[0] = scale1[0];
	            }
	        } // if (wsize != 1.0)
	        else {
	            scale1[0] = ascale * bsize;
	            scale2[0] = scale1[0];
	        }

	        // Scale second eigenvalue (if real)
	        if (wi[0] == 0.0) {
	            wsize = Math.max(safmin, c1);
	            wsize = Math.max(wsize, fuzzy1 * ( (Math.abs(wr2[0]) * c2) + c3));
	            wsize = Math.max(wsize, Math.min(c4, 0.5 * Math.max(Math.abs(wr2[0]), c5)));

	            if (wsize != 1.0) {
	                wscale = 1.0 / wsize;

	                if (wsize > 1.0) {
	                    scale2[0] = (Math.max(ascale, bsize) * wscale) * Math.min(ascale, bsize);
	                } else {
	                    scale2[0] = (Math.min(ascale, bsize) * wscale) * Math.max(ascale, bsize);
	                }

	                wr2[0] = wr2[0] * wscale;
	            } // if (wsize > 1.0)
	            else {
	                scale2[0] = ascale * bsize;
	            }
	        } // if (wi[0] == 0.0)

	        return;
	    } // dlag2

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine DLAGGE Original DLAGGE created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlagge generates a real general m by n matrix A, by
	     * pre- and post- multiplying a real diagonal matrix D with random orthogonal matrices: A = U*D*V. The lower and
	     * upper bandwidths may then be reduced to kl and ku by additional orthogonal transformations.
	     * 
	     * @param m input int The number of rows of the matrix A. m >= 0.
	     * @param n input int The number of columns of the matrix A. n >= 0.
	     * @param kl input int The number of nonzero subdiagonals within the band of A. 0 <= kl <= m-1.
	     * @param ku input int The number of nonzero superdiagonals within the band of A. 0 <= ku <= n-1.
	     * @param D input double[] of dimension (min(m,n)) The diagonal elements of the diagonal matrix D
	     * @param A output double[][] of dimension (lda,n) The generated m by n matrix A.
	     * @param lda input int The leading dimension of the array A. lda >= m.
	     * @param iseed input/output int[] of dimension 4 On entry, the seed of the random number generator; the array
	     *            elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
	     * @param work workspace double[] of dimension (m+n)
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     */
	    private void dlagge(final int m, final int n, final int kl, final int ku, final double[] D, final double[][] A,
	            final int lda, final int[] iseed, final double[] work, final int[] info) {
	        int i;
	        int j;
	        int k;
	        double tau;
	        double wa;
	        double wb;
	        double wn;
	        double[][] B;
	        double[] work2;
	        double[] x;

	        // Test the input arguments
	        info[0] = 0;

	        if (m < 0) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if ( (kl < 0) || (kl > (m - 1))) {
	            info[0] = -3;
	        } else if ( (ku < 0) || (ku > (n - 1))) {
	            info[0] = -4;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -7;
	        }

	        if (info[0] < 0) {
	            System.err.println("Error dlagge had info[0] = " + info[0]);

	            return;
	        }

	        // Initialize A to diagonal matrix
	        for (j = 0; j < n; j++) {

	            for (i = 0; i < m; i++) {
	                A[i][j] = 0.0;
	            }
	        }

	        for (i = 0; i < Math.min(m, n); i++) {
	            A[i][i] = D[i];
	        }

	        // pre- and post- multiply by random orthogonal matrices
	        for (i = Math.min(m, n); i >= 1; i--) {

	            if (i < m) {

	                // generate random reflection
	                dlarnv(3, iseed, m - i + 1, work);
	                wn = dnrm2(m - i + 1, work, 1);

	                if (work[0] >= 0) {
	                    wa = Math.abs(wn);
	                } else {
	                    wa = -Math.abs(wn);
	                }

	                if (wn == 0.0) {
	                    tau = 0.0;
	                } else {
	                    wb = work[0] + wa;

	                    for (j = 0; j < (m - i); j++) {
	                        work[j + 1] = (1.0 / wb) * work[j + 1];
	                    }

	                    work[0] = 1.0;
	                    tau = wb / wa;
	                }

	                // multiply A(i-1:m-1,i-1:n-1) by random reflection from the left
	                B = new double[m - i + 1][n - i + 1];

	                for (j = 0; j < (m - i + 1); j++) {

	                    for (k = 0; k < (n - i + 1); k++) {
	                        B[j][k] = A[j + i - 1][k + i - 1];
	                    }
	                }

	                work2 = new double[work.length - m];

	                for (j = 0; j < (work.length - m); j++) {
	                    work2[j] = work[m + j];
	                }

	                dgemv('T', m - i + 1, n - i + 1, 1.0, B, m - i + 1, work, 1, 0.0, work2, 1);
	                dger(m - i + 1, n - i + 1, -tau, work, 1, work2, 1, B, m - i + 1);

	                for (j = 0; j < (m - i + 1); j++) {

	                    for (k = 0; k < (n - i + 1); k++) {
	                        A[j + i - 1][k + i - 1] = B[j][k];
	                    }
	                }

	                for (j = 0; j < (work.length - m); j++) {
	                    work[m + j] = work2[j];
	                }
	            } // if (i < m)

	            if (i < n) {

	                // generate random reflection
	                dlarnv(3, iseed, n - i + 1, work);
	                wn = dnrm2(n - i + 1, work, 1);

	                if (work[0] >= 0) {
	                    wa = Math.abs(wn);
	                } else {
	                    wa = -Math.abs(wn);
	                }

	                if (wn == 0.0) {
	                    tau = 0.0;
	                } else {
	                    wb = work[0] + wa;

	                    for (j = 0; j < (n - i); j++) {
	                        work[j + 1] = (1.0 / wb) * work[j + 1];
	                    }

	                    work[0] = 1.0;
	                    tau = wb / wa;
	                }

	                // multiply A(i-1:m-1,i-1:n-1) by random reflection from right
	                B = new double[m - i + 1][n - i + 1];

	                for (j = 0; j < (m - i + 1); j++) {

	                    for (k = 0; k < (n - i + 1); k++) {
	                        B[j][k] = A[j + i - 1][k + i - 1];
	                    }
	                }

	                work2 = new double[work.length - n];

	                for (j = 0; j < (work.length - n); j++) {
	                    work2[j] = work[n + j];
	                }

	                dgemv('N', m - i + 1, n - i + 1, 1.0, B, m - i + 1, work, 1, 0.0, work2, 1);
	                dger(m - i + 1, n - i + 1, -tau, work2, 1, work, 1, B, m - i + 1);

	                for (j = 0; j < (m - i + 1); j++) {

	                    for (k = 0; k < (n - i + 1); k++) {
	                        A[j + i - 1][k + i - 1] = B[j][k];
	                    }
	                }

	                for (j = 0; j < (work.length - n); j++) {
	                    work[n + j] = work2[j];
	                }
	            } // if (i < n)
	        } // for (i = Math.min(m,n); i >= 1; i--)

	        // Reduce number of subdiagonals to kl and number of superdiagonals to
	        // ku
	        for (i = 1; i <= Math.max(m - 1 - kl, n - 1 - ku); i++) {

	            if (kl <= ku) {

	                // annihilate subdiagonal elements first (necessary if kl = 0)
	                if (i <= Math.min(m - 1 - kl, n)) {

	                    // generate reflection to annihilate A(kl+i:m-1,i-1)
	                    x = new double[m - kl - i + 1];

	                    for (j = 0; j < (m - kl - i + 1); j++) {
	                        x[j] = A[kl + i - 1 + j][i - 1];
	                    }

	                    wn = dnrm2(m - kl - i + 1, x, 1);

	                    if (A[kl + i - 1][i - 1] >= 0) {
	                        wa = Math.abs(wn);
	                    } else {
	                        wa = -Math.abs(wn);
	                    }

	                    if (wn == 0.0) {
	                        tau = 0.0;
	                    } else {
	                        wb = A[kl + i - 1][i - 1] + wa;

	                        for (j = 0; j < (m - kl - i); j++) {
	                            A[kl + i + j][i - 1] = (1.0 / wb) * A[kl + i + j][i - 1];
	                        }

	                        A[kl + i - 1][i - 1] = 1.0;
	                        tau = wb / wa;
	                    }

	                    // apply reflection to A(kl+i-1:m-1,i:n-1) from the left
	                    B = new double[m - kl - i + 1][n - i];

	                    for (j = 0; j < (m - kl - i + 1); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            B[j][k] = A[kl + i - 1 + j][i + k];
	                        }
	                    }

	                    x = new double[m - kl - i + 1];

	                    for (j = 0; j < (m - kl - i + 1); j++) {
	                        x[j] = A[kl + i - 1 + j][i - 1];
	                    }

	                    dgemv('T', m - kl - i + 1, n - i, 1.0, B, m - kl - i + 1, x, 1, 0.0, work, 1);
	                    dger(m - kl - i + 1, n - i, -tau, x, 1, work, 1, B, m - kl - i + 1);

	                    for (j = 0; j < (m - kl - i + 1); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            A[kl + i - 1 + j][i + k] = B[j][k];
	                        }
	                    }

	                    A[kl + i - 1][i - 1] = -wa;
	                } // if (i <= Math.min(m-1-kl, n))

	                if (i <= Math.min(n - 1 - ku, m)) {

	                    // generate reflection to annihilate A(i-1,ku+i:n-1)
	                    x = new double[n - ku - i + 1];

	                    for (j = 0; j < (n - ku - i + 1); j++) {
	                        x[j] = A[i - 1][ku + i - 1 + j];
	                    }

	                    wn = dnrm2(n - ku - i + 1, x, 1);

	                    if (A[i - 1][ku + i - 1] >= 0) {
	                        wa = Math.abs(wn);
	                    } else {
	                        wa = -Math.abs(wn);
	                    }

	                    if (wn == 0.0) {
	                        tau = 0.0;
	                    } else {
	                        wb = A[i - 1][ku + i - 1] + wa;

	                        for (j = 0; j < (n - ku - i); j++) {
	                            A[i - 1][ku + i + j] = (1.0 / wb) * A[i - 1][ku + i + j];
	                        }

	                        A[i - 1][ku + i - 1] = 1.0;
	                        tau = wb / wa;
	                    }

	                    // Apply reflection to A(i:m-1,ku+i-1:n-1) from the right
	                    B = new double[m - i][n - ku - i + 1];

	                    for (j = 0; j < (m - i); j++) {

	                        for (k = 0; k < (n - ku - i + 1); k++) {
	                            B[j][k] = A[i + j][ku + i - 1 + k];
	                        }
	                    }

	                    x = new double[n - ku - i + 1];

	                    for (j = 0; j < (n - ku - i + 1); j++) {
	                        x[j] = A[i - 1][ku + i - 1 + j];
	                    }

	                    dgemv('N', m - i, n - ku - i + 1, 1.0, B, m - i, x, 1, 0.0, work, 1);
	                    dger(m - i, n - ku - i + 1, -tau, work, 1, x, 1, B, m - i);

	                    for (j = 0; j < (m - i); j++) {

	                        for (k = 0; k < (n - ku - i + 1); k++) {
	                            A[i + j][ku + i - 1 + k] = B[j][k];
	                        }
	                    }

	                    A[i - 1][ku + i - 1] = -wa;
	                } // if (i <= Math.min(n-1-ku, m))
	            } // if (kl <= ku)
	            else { // kl > ku

	                // annihilate superdiagonal elements first (necessary if ku = 0)
	                if (i <= Math.min(n - 1 - ku, m)) {

	                    // generate reflection to annihilate A(i-1,ku+i:n-1)
	                    x = new double[n - ku - i + 1];

	                    for (j = 0; j < (n - ku - i + 1); j++) {
	                        x[j] = A[i - 1][ku + i - 1 + j];
	                    }

	                    wn = dnrm2(n - ku - i + 1, x, 1);

	                    if (A[i - 1][ku + i - 1] >= 0) {
	                        wa = Math.abs(wn);
	                    } else {
	                        wa = -Math.abs(wn);
	                    }

	                    if (wn == 0.0) {
	                        tau = 0.0;
	                    } else {
	                        wb = A[i - 1][ku + i - 1] + wa;

	                        for (j = 0; j < (n - ku - i); j++) {
	                            A[i - 1][ku + i + j] = (1.0 / wb) * A[i - 1][ku + i + j];
	                        }

	                        A[i - 1][ku + i - 1] = 1.0;
	                        tau = wb / wa;
	                    }

	                    // apply reflection to A(i:m-1,ku+i-1:n-1) from the right
	                    B = new double[m - i][n - ku - i + 1];

	                    for (j = 0; j < (m - i); j++) {

	                        for (k = 0; k < (n - ku - i + 1); k++) {
	                            B[j][k] = A[i + j][ku + i - 1 + k];
	                        }
	                    }

	                    x = new double[n - ku - i + 1];

	                    for (j = 0; j < (n - ku - i + 1); j++) {
	                        x[j] = A[i - 1][ku + i - 1 + j];
	                    }

	                    dgemv('N', m - i, n - ku - i + 1, 1.0, B, m - i, x, 1, 0.0, work, 1);
	                    dger(m - i, n - ku - i + 1, -tau, work, 1, x, 1, B, m - i);

	                    for (j = 0; j < (m - i); j++) {

	                        for (k = 0; k < (n - ku - i + 1); k++) {
	                            A[i + j][ku + i - 1 + k] = B[j][k];
	                        }
	                    }

	                    A[i - 1][ku + i - 1] = -wa;
	                } // if (i <= Math.min(n-1-ku,m))

	                if (i <= Math.min(m - 1 - kl, n)) {

	                    // generate reflection to annihilate A(kl+i:m-1,i-1)
	                    x = new double[m - kl - i + 1];

	                    for (j = 0; j < (m - kl - i + 1); j++) {
	                        x[j] = A[kl + i - 1 + j][i - 1];
	                    }

	                    wn = dnrm2(m - kl - i + 1, x, 1);

	                    if (A[kl + i - 1][i - 1] >= 0.0) {
	                        wa = Math.abs(wn);
	                    } else {
	                        wa = -Math.abs(wn);
	                    }

	                    if (wn == 0.0) {
	                        tau = 0.0;
	                    } else {
	                        wb = A[kl + i - 1][i - 1] + wa;

	                        for (j = 0; j < (m - kl - i); j++) {
	                            A[kl + i + j][i - 1] = (1.0 / wb) * A[kl + i + j][i - 1];
	                        }

	                        A[kl + i - 1][i - 1] = 1.0;
	                        tau = wb / wa;
	                    }

	                    // apply reflection to A(kl+i-1:m-1,i:n-1) from the left
	                    B = new double[m - kl - i + 1][n - i];

	                    for (j = 0; j < (m - kl - i + 1); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            B[j][k] = A[kl + i - 1 + j][i + k];
	                        }
	                    }

	                    x = new double[m - kl - i + 1];

	                    for (j = 0; j < (m - kl - i + 1); j++) {
	                        x[j] = A[kl + i - 1 + j][i - 1];
	                    }

	                    dgemv('T', m - kl - i + 1, n - i, 1.0, B, m - kl - i + 1, x, 1, 0.0, work, 1);
	                    dger(m - kl - i + 1, n - i, -tau, x, 1, work, 1, B, m - kl - i + 1);

	                    for (j = 0; j < (m - kl - i + 1); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            A[kl + i - 1 + j][i + k] = B[j][k];
	                        }
	                    }

	                    A[kl + i - 1][i - 1] = -wa;
	                } // if (i <= Math.min(m-1-kl, n))
	            } // else kl > ku

	            for (j = kl + i + 1; j <= m; j++) {
	                A[j - 1][i - 1] = 0.0;
	            }

	            for (j = ku + i + 1; j <= n; j++) {
	                A[i - 1][j - 1] = 0.0;
	            }
	        } // for (i = 1; i <= Math.max(m-1-kl, n-1-ku); i++)

	        return;
	    } // dlagge

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine dlagsy Original DLAGSY created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlagsy generates a real symmetric matrix A, by pre-
	     * and post- multiplying a real diagonal matrix D with a random orthogonal matrix: A = U*D*U'. The semi-bandwidth
	     * may then be reduced to k by additional orthogonal transformations.
	     * 
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param k input int The number of nonzero subdiagonals within the band of A. 0 <= k <= n-1.
	     * @param D input double[] of dimension n. The diagonal elements of the diagonal matrix D.
	     * @param A output double[][] of dimension (lda,n) The generated n by n symmetric matrix A (the full matrix is
	     *            stored).
	     * @param lda input int The leading dimension of the array A. lda >= n.
	     * @param iseed input/output int[] of dimension 4 On entry, the seed of the random number generator; the array
	     *            elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
	     * @param work workspace double[] of dimension (2*n)
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value
	     */
	    private void dlagsy(final int n, final int k, final double[] D, final double[][] A, final int lda,
	            final int[] iseed, final double[] work, final int[] info) {
	        int i;
	        int j;
	        int m;
	        double alpha;
	        double tau;
	        double wa;
	        double wb = 0.0;
	        double wn;
	        double[][] B;
	        final double[] work2 = new double[n];
	        double[] x;

	        // Test the input arguments
	        info[0] = 0;

	        if (n < 0) {
	            info[0] = -1;
	        } else if ( (k < 0) || (k > (n - 1))) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -5;
	        }

	        if (info[0] < 0) {
	            System.err.println("Error dlagsy had info[0] = " + info[0]);

	            return;
	        }

	        // initialize lower triangle of A to diagonal matrix
	        for (j = 0; j < n; j++) {

	            for (i = j + 1; i < n; i++) {
	                A[i][j] = 0.0;
	            }
	        }

	        for (i = 0; i < n; i++) {
	            A[i][i] = D[i];
	        }

	        // Generate lower triangle of symmetric matrix
	        for (i = n - 1; i >= 1; i--) {

	            // generate random reflection
	            dlarnv(3, iseed, n - i + 1, work);
	            wn = dnrm2(n - i + 1, work, 1);

	            if (work[0] >= 0.0) {
	                wa = Math.abs(wn);
	            } else {
	                wa = -Math.abs(wn);
	            }

	            if (wn == 0.0) {
	                tau = 0.0;
	            } else {
	                wb = work[0] + wa;

	                for (j = 0; j < (n - i); j++) {
	                    work[j + 1] = (1.0 / wb) * work[j + 1];
	                }

	                work[0] = 1.0;
	                tau = wb / wa;
	            }

	            // apply random reflection to A(i-1:n-1,i-1:n-1) from the left and
	            // the right
	            // compute y = tau * A * u
	            B = new double[n - i + 1][n - i + 1];

	            for (j = 0; j < (n - i + 1); j++) {

	                for (m = 0; m < (n - i + 1); m++) {
	                    B[j][m] = A[i - 1 + j][i - 1 + m];
	                }
	            }

	            dsymv('L', n - i + 1, tau, B, n - i + 1, work, 1, 0.0, work2, 1);

	            // compute v = y - 1/2 * tau * (y, u) * u
	            alpha = -0.5 * tau * ddot(n - i + 1, work2, 1, work, 1);
	            daxpy(n - i + 1, alpha, work, 1, work2, 1);

	            // apply the transformation as a rank-2 update to A(i-1:n-1,i-1:n-1)
	            dsyr2('L', n - i + 1, -1.0, work, 1, work2, 1, B, n - i + 1);

	            for (j = 0; j < (n - i + 1); j++) {

	                for (m = 0; m < (n - i + 1); m++) {
	                    A[i - 1 + j][i - 1 + m] = B[j][m];
	                }
	            }
	        } // for (i = n-1; i >= 1; i--)

	        // Reduce number of subdiagonals to k
	        for (i = 1; i <= (n - 1 - k); i++) {

	            // generate reflection to annihilate A(k+i:n-1,i-1)
	            x = new double[n - k - i + 1];

	            for (j = 0; j < (n - k - i + 1); j++) {
	                x[j] = A[k + i - 1 + j][i - 1];
	            }

	            wn = dnrm2(n - k - i + 1, x, 1);

	            if (A[k + i - 1][i - 1] >= 0.0) {
	                wa = Math.abs(wn);
	            } else {
	                wa = -Math.abs(wn);
	            }

	            if (wn == 0.0) {
	                tau = 0.0;
	            } else {
	                wb = A[k + i - 1][i - 1] + wa;

	                for (j = 0; j < (n - k - i); j++) {
	                    A[k + i + j][i - 1] = (1.0 / wb) * A[k + i + j][i - 1];
	                }

	                A[k + i - 1][i - 1] = 1.0;
	                tau = wb / wa;
	            }

	            // apply reflection to A(k+i-1:n-1,i:k+i-2) from the left
	            B = new double[n - k - i + 1][k - 1];

	            for (j = 0; j < (n - k - i + 1); j++) {

	                for (m = 0; m < (k - 1); m++) {
	                    B[j][m] = A[k + i - 1 + j][i + m];
	                }
	            }

	            x = new double[n - k - i + 1];

	            for (j = 0; j < (n - k - i + 1); j++) {
	                x[j] = A[k + i - 1 + j][i - 1];
	            }

	            dgemv('T', n - k - i + 1, k - 1, 1.0, B, n - k - i + 1, x, 1, 0.0, work, 1);
	            dger(n - k - i + 1, k - 1, -tau, x, 1, work, 1, B, n - k - i + 1);

	            for (j = 0; j < (n - k - i + 1); j++) {

	                for (m = 0; m < (k - 1); m++) {
	                    A[k + i - 1 + j][i + m] = B[j][m];
	                }
	            }

	            // apply reflection to A(k+i-1:n-1,k+i-1:n-1) from the left and
	            // the right
	            // compute y = tau * A * u
	            B = new double[n - k - i + 1][n - k - i + 1];

	            for (j = 0; j < (n - k - i + 1); j++) {

	                for (m = 0; m < (n - k - i + 1); m++) {
	                    B[j][m] = A[k + i - 1 + j][k + i - 1 + m];
	                }
	            }

	            x = new double[n - k - i + 1];

	            for (j = 0; j < (n - k - i + 1); j++) {
	                x[j] = A[k + i - 1 + j][i - 1];
	            }

	            dsymv('L', n - k - i + 1, tau, B, n - k - i + 1, x, 1, 0.0, work, 1);

	            // compute v = y - 1/2 * tau * (y, u) * u
	            alpha = -0.5 * tau * ddot(n - k - i + 1, work, 1, x, 1);
	            daxpy(n - k - i + 1, alpha, x, 1, work, 1);

	            // apply symmetric rank-2 update to A(k+i-1:n-1,k+i-1:n-1)
	            dsyr2('L', n - k - i + 1, -1.0, x, 1, work, 1, B, n - k - i + 1);

	            for (j = 0; j < (n - k - i + 1); j++) {

	                for (m = 0; m < (n - k - i + 1); m++) {
	                    A[k + i - 1 + j][k + i - 1 + m] = B[j][m];
	                }
	            }

	            A[k + i - 1][i - 1] = -wa;

	            for (j = k + i + 1; j <= n; j++) {
	                A[j - 1][i - 1] = 0.0;
	            }
	        } // for (i = 1; i <= n - 1 - k; i++)

	        // Store full symmetric matrix
	        for (j = 0; j < n; j++) {

	            for (i = j + 1; i < n; i++) {
	                A[j][i] = A[i][j];
	            }
	        }

	        return;
	    } // dlagsy

	    /**
	     * Port of some code contained in the version 2.0 LAPACK auxiliary test routine DLAHD2 Original DLAHD2 created by
	     * Univ. of Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006 dlahd2 prints header information
	     * for the different test paths
	     * 
	     * @param path String Name of the path for which the header information is to be printed. DSG real symmetric
	     *            generalized eigenvalue problem
	     */
	    private void dlahd2(final String path) {

	        if (path.equalsIgnoreCase("DSG")) {
	            System.out.println("Real symmetric generalized eigenvalue problem\n");
	            System.out.println("Matrix types\n");
	            System.out.println("Special matrices\n");
	            System.out.println("1 = zero matrix\n");
	            System.out.println("2 = Identity matrix\n");
	            System.out.println("3 = Diagonal: evenly spaced entries\n");
	            System.out.println("4 = Diagonal: geometrically spaced entries\n");
	            System.out.println("5 = Diagonal: clustered entries\n");
	            System.out.println("6 = Diagonal: large evenly spaced\n");
	            System.out.println("7 = Diagonal: small, evenly spaced\n\n");
	            System.out.println("Dense or banded symmetric matrices\n");
	            System.out.println("8 = Evenly spaced eigenvalues\n");
	            System.out.println("9 = Geometrically spaced eigenvalues\n");
	            System.out.println("10 = Clustered eigenvalues\n");
	            System.out.println("11 = Large, evenly spaced eigenvalues\n");
	            System.out.println("12 = Small, evenly spaced eigenvalues\n");
	            System.out.println("13 = Matrix with random O(1) entries\n");
	            System.out.println("14 = Matrix with large random entries\n");
	            System.out.println("15 = Matrix with small random entries\n");
	            System.out.println("16 = Evenly spaced eigenvalues, ka = 1, kb = 1\n");
	            System.out.println("17 = Evenly spaced eigenvalues, ka = 2, kb = 1\n");
	            System.out.println("18 = Evenly spaced eigenvalues, ka = 2, kb = 2\n");
	            System.out.println("19 = Evenly spaced eigenvalues, ka = 3, kb = 1\n");
	            System.out.println("20 = Evenly spaced eigenvalues, ka = 3, kb = 2\n");
	            System.out.println("21 = Evenly spaced eigenvalues, ka = 3, kb = 3\n\n");
	            System.out.println("Tests performed\n");
	            System.out.println("For each pair (A,B), where A is of the given type\n");
	            System.out.println("and B is a random well-conditioned matrix.  D is\n");
	            System.out.println("diagonal, and Z is orthogonal.\n");
	            System.out.println("1 = dsygv, with itype = 1 and uplo = 'U'\n");
	            System.out.println("|A Z - B Z D| / (|A| |Z| n ulp)\n");
	            System.out.println("2 = dsygv, with itype = 1 and uplo = 'L'\n");
	            System.out.println("|A Z - B Z D| / (|A| |Z| n ulp)\n");
	            System.out.println("3 = dsygv, with itype = 2 and uplo = 'U'\n");
	            System.out.println("|A B Z - Z D| / (|A| |Z| n ulp)\n");
	            System.out.println("4 = dsygv, with itype = 2 and uplo = 'L'\n");
	            System.out.println("|A B Z - Z D| / (|A| |Z| n ulp)\n");
	            System.out.println("5 = dsygv, with itype = 3 and uplo = 'U'\n");
	            System.out.println("|B A Z - Z D| / (|A| |Z| n ulp)\n");
	            System.out.println("6 = dsygv, with itype = 3 and uplo = 'L'\n");
	            System.out.println("|B A Z - Z D| / (|A| |Z| n ulp)\n");
	        }
	    } // dlahd2

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine DLALN2 Original DLALN2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlaln2 solves a system of the form (ca A - w D) X = s
	     * B or (ca A' - w D) X = s B with possible scaling ("s") and perturbation of A. (A' means A-transpose.)
	     * 
	     * <p>
	     * A is an na by na real matrix, ca is a real scalar, D is an na by na real diagonal matrix, w is a real or complex
	     * value, and X and B are na by 1 matrices -- real if w is real, complex if w is complex. na may be 1 or 2.
	     * </p>
	     * 
	     * <p>
	     * If w is complex, X and B are represented as na by 2 matrices, the first column of each being the real part and
	     * the second being the imaginary part.
	     * </p>
	     * 
	     * <p>
	     * "s" is a scaling factor (<= 1), computed by dlaln2, which is so chosen that X can be computed without overflow. X
	     * is further scaled if necessary to assure that norm(ca A - w D)*norm(X) is less than overflow.
	     * </p>
	     * 
	     * <p>
	     * If both singular values of (ca A - w D) are less than smin, smin*identity will be used instead of (ca A - w D).
	     * If only one singular value is less than smin, one element of (ca A - w D) will be perturbed enough to make the
	     * smallest singular value roughly smin. If both singular values are at least smin, (ca A - w D) will not be
	     * perturbed. In any case, perturbation will be at most some small multiple of max(smin, ulp*norm(ca A - w D) ). The
	     * singular values are computed by infinity-norm approximations, and thus will only be correct to a factor of 2 or
	     * so.
	     * </p>
	     * 
	     * <p>
	     * Note: All input quantities are assumed to be smaller than overflow by a reasonable factor. (See bignum.)
	     * </p>
	     * 
	     * @param ltrans input boolean = true: A-transpose will be used. = false: A will be used (not transposed.)
	     * @param na input int The size of the matrix A. It may (only) be 1 or 2.
	     * @param nw input int 1 if "w" is real, 2 if "w" is complex. It may only be 1 or 2.
	     * @param smin input double The desired lower bound on the singular values of A. This should be a safe distance away
	     *            from underflow or overflow, say, between (underflow/machine precision) and (machine precision *
	     *            overflow ). (See bignum and ulp.)
	     * @param ca input double The coefficient c, which A is multiplied by.
	     * @param A input double[][] of dimension (lda,na) The na by na matrix A.
	     * @param lda input int The leading dimension of A. It must be at least na.
	     * @param d1 input double The 0,0 element in diagonal matrix D.
	     * @param d2 input double The 1,1 element in the diagonal matrix D. Not used if nw = 1.
	     * @param B input double[][] of dimension (ldb,nw) The na by nw matrix B (right-hand side). If nw = 2 ("w" is
	     *            complex), column 0 contains the real part of B and column 1 contains the imaginary part.
	     * @param ldb input int The leading dimension of B. It must be at least na.
	     * @param wr input double The real part of the scalar "w".
	     * @param wi input double The imaginary part of the scalar "w". Not used if nw = 1.
	     * @param X output double[][] of dimension (ldx,nw). The na by nw matrix X (unknowns), as computed by dlaln2. If nw
	     *            = 2 ("w" is complex), on exit, column 0 will contain the real part of X and column 1 will contain the
	     *            imaginary part.
	     * @param ldx input int The leading dimension of X. It must be at least na.
	     * @param scale output double[] The scale factor that B must be multiplied by to insure that overflow does not occur
	     *            when computing X. Thus, (ca A - w D) X will be scale*B, not B(ignoring perturbations of A.) It will be
	     *            at most 1.
	     * @param xnorm output double[] The infinity-norm of X, when X is regarded as an na by nw real matrix.
	     * @param info output int[] An error flag. It will be set to zero if no error occurs, a negative number if an
	     *            argument is in error, or a positive number if ca A - w D had to be perturbed. The possible values are:
	     *            = 0: No error occurred, and (ca A - w D) did not have to be perturbed. = 1: (ca A - w D) had to be
	     *            perturbed to make its smallest (or only) singular value greater than smin. Note: In the interests of
	     *            speed, this routine does not check the inputs for errors.
	     */
	    private void dlaln2(final boolean ltrans, final int na, final int nw, final double smin, final double ca,
	            final double[][] A, final int lda, final double d1, final double d2, final double[][] B, final int ldb,
	            final double wr, final double wi, final double[][] X, final int ldx, final double[] scale,
	            final double[] xnorm, final int[] info) {
	        int icmax;
	        int j;
	        double bbnd;
	        double bi1;
	        double bi2;
	        double bignum;
	        double bnorm;
	        double br1;
	        double br2;
	        double ci21;
	        double ci22;
	        double cmax;
	        double cnorm;
	        double cr21;
	        double cr22;
	        double csi;
	        double csr;
	        double li21;
	        double lr21;
	        double smini;
	        double smlnum;
	        double temp;
	        double u22abs;
	        double ui11;
	        double ui11r;
	        double ui12;
	        double ui12s;
	        double ui22;
	        double ur11;
	        double ur11r;
	        double ur12;
	        double ur12s;
	        double ur22;
	        double xi1;
	        final double[] xi2 = new double[1];
	        double xr1;
	        final double[] xr2 = new double[1];
	        final boolean[] rswap = new boolean[] {false, true, false, true};
	        final boolean[] zswap = new boolean[] {false, false, true, true};
	        final int[][] ipivot = new int[4][4];
	        ipivot[0][0] = 1;
	        ipivot[1][0] = 2;
	        ipivot[2][0] = 3;
	        ipivot[3][0] = 4;
	        ipivot[0][1] = 2;
	        ipivot[1][1] = 1;
	        ipivot[2][1] = 4;
	        ipivot[3][1] = 3;
	        ipivot[0][2] = 3;
	        ipivot[1][2] = 4;
	        ipivot[2][2] = 1;
	        ipivot[3][2] = 2;
	        ipivot[0][3] = 4;
	        ipivot[1][3] = 3;
	        ipivot[2][3] = 2;
	        ipivot[3][3] = 1;

	        final double[] civ = new double[4];
	        final double[] crv = new double[4];
	        final double[] pout = new double[1];
	        final double[] qout = new double[1];

	        // Compute bignum
	        smlnum = 2.0 * dlamch('S');
	        bignum = 1.0 / smlnum;
	        smini = Math.max(smin, smlnum);

	        // Don't check for input errors
	        info[0] = 0;

	        // Standard initializations
	        scale[0] = 1.0;

	        if (na == 1) {

	            // 1 by 1 (i.e., scalar) system C X = B
	            if (nw == 1) {

	                // Real 1 by 1 system
	                // C = ca A - w D
	                csr = (ca * A[0][0]) - (wr * d1);
	                cnorm = Math.abs(csr);

	                // If |C| < smini, use C = smini
	                if (cnorm < smini) {
	                    csr = smini;
	                    cnorm = smini;
	                    info[0] = 1;
	                } // if (cnorm < smini)

	                // Check scaling for X = B / C
	                bnorm = Math.abs(B[0][0]);

	                if ( (cnorm < 1.0) && (bnorm > 1.0)) {

	                    if (bnorm > (bignum * cnorm)) {
	                        scale[0] = 1.0 / bnorm;
	                    }
	                } // if ((cnorm < 1.0) && (bnorm > 1.0))

	                // Compute X
	                X[0][0] = (B[0][0] * scale[0]) / csr;
	                xnorm[0] = Math.abs(X[0][0]);
	            } // if (nw == 1)
	            else { // nw == 2

	                // Complex 1 by 1 system (w is complex)
	                // C = ca A - w D
	                csr = (ca * A[0][0]) - (wr * d1);
	                csi = -wi * d1;
	                cnorm = Math.abs(csr) + Math.abs(csi);

	                // If |C| < smini, use C = smini
	                if (cnorm < smini) {
	                    csr = smini;
	                    csi = 0.0;
	                    cnorm = smini;
	                    info[0] = 1;
	                } // if (cnorm < smini)

	                // Check scaling for X = B / C
	                bnorm = Math.abs(B[0][0]) + Math.abs(B[0][1]);

	                if ( (cnorm < 1.0) && (bnorm > 1.0)) {

	                    if (bnorm > (bignum * cnorm)) {
	                        scale[0] = 1.0 / bnorm;
	                    }
	                } // if ((cnorm < 1.0) && (bnorm > 1.0))

	                // Compute X
	                dladiv(scale[0] * B[0][0], scale[0] * B[0][1], csr, csi, pout, qout);
	                X[0][0] = pout[0];
	                X[0][1] = qout[0];
	                xnorm[0] = Math.abs(X[0][0]) + Math.abs(X[0][1]);
	            } // else nw == 2
	        } // if (na == 1)
	        else { // na == 2

	            // 2 by 2 System
	            // Compute the real part of C = ca A - w D (or ca A' - w D)
	            crv[0] = (ca * A[0][0]) - (wr * d1);
	            crv[3] = (ca * A[1][1]) - (wr * d2);

	            if (ltrans) {
	                crv[2] = ca * A[1][0];
	                crv[1] = ca * A[0][1];
	            } else {
	                crv[1] = ca * A[1][0];
	                crv[2] = ca * A[0][1];
	            }

	            if (nw == 1) {

	                // Real 2 by 2 system (w is real)
	                // Find the largest element in C
	                cmax = 0.0;
	                icmax = -1;

	                for (j = 0; j < 4; j++) {

	                    if (Math.abs(crv[j]) > cmax) {
	                        cmax = Math.abs(crv[j]);
	                        icmax = j;
	                    }
	                } // for (j = 0; j < 4; j++)

	                // If norm(C) < smini, use smini*identity
	                if (cmax < smini) {
	                    bnorm = Math.max(Math.abs(B[0][0]), Math.abs(B[1][0]));

	                    if ( (smini < 1.0) && (bnorm > 1.0)) {

	                        if (bnorm > (bignum * smini)) {
	                            scale[0] = 1.0 / bnorm;
	                        }
	                    } // if ((smini < 1.0) && (bnorm > 1.0))

	                    temp = scale[0] / smini;
	                    X[0][0] = temp * B[0][0];
	                    X[1][0] = temp * B[1][0];
	                    xnorm[0] = temp * bnorm;
	                    info[0] = 1;

	                    return;
	                } // if (cmax < smini)

	                // Gaussian elimination with complete pivoting
	                ur11 = crv[icmax];
	                cr21 = crv[ipivot[1][icmax] - 1];
	                ur12 = crv[ipivot[2][icmax] - 1];
	                cr22 = crv[ipivot[3][icmax] - 1];
	                ur11r = 1.0 / ur11;
	                lr21 = ur11r * cr21;
	                ur22 = cr22 - (ur12 * lr21);

	                // If smaller pivot < smini, use smini
	                if (Math.abs(ur22) < smini) {
	                    ur22 = smini;
	                    info[0] = 1;
	                }

	                if (rswap[icmax]) {
	                    br1 = B[1][0];
	                    br2 = B[0][0];
	                } else {
	                    br1 = B[0][0];
	                    br2 = B[1][0];
	                }

	                br2 = br2 - (lr21 * br1);
	                bbnd = Math.max(Math.abs(br1 * (ur22 * ur11r)), Math.abs(br2));

	                if ( (bbnd > 1.0) && (Math.abs(ur22) < 1.0)) {

	                    if (bbnd >= (bignum * Math.abs(ur22))) {
	                        scale[0] = 1.0 / bbnd;
	                    }
	                } // if ((bbnd > 1.0) && (Math.abs(ur22) < 1.0))

	                xr2[0] = (br2 * scale[0]) / ur22;
	                xr1 = ( (scale[0] * br1) * ur11r) - (xr2[0] * (ur11r * ur12));

	                if (zswap[icmax]) {
	                    X[0][0] = xr2[0];
	                    X[1][0] = xr1;
	                } else {
	                    X[0][0] = xr1;
	                    X[1][0] = xr2[0];
	                }

	                xnorm[0] = Math.max(Math.abs(xr1), Math.abs(xr2[0]));

	                // Further scaling if norm(A) norm(X) > overflow
	                if ( (xnorm[0] > 1.0) && (cmax > 1.0)) {

	                    if (xnorm[0] > (bignum / cmax)) {
	                        temp = cmax / bignum;
	                        X[0][0] = temp * X[0][0];
	                        X[1][0] = temp * X[1][0];
	                        xnorm[0] = temp * xnorm[0];
	                        scale[0] = temp * scale[0];
	                    } // if (xnorm[0] > bignum / cmax)
	                } // if ((xnorm[0] > 1.0) && (cmax > 1.0))
	            } // if (nw == 1)
	            else { // nw == 2

	                // Complex 2 by 2 system ( w is complex)
	                // Find the largest element in C
	                civ[0] = -wi * d1;
	                civ[1] = 0.0;
	                civ[2] = 0.0;
	                civ[3] = -wi * d2;
	                cmax = 0.0;
	                icmax = -1;

	                for (j = 0; j < 4; j++) {

	                    if ( (Math.abs(crv[j]) + Math.abs(civ[j])) > cmax) {
	                        cmax = Math.abs(crv[j]) + Math.abs(civ[j]);
	                        icmax = j;
	                    }
	                } // for (j = 0; j < 4; j++)

	                // If norm(C) < smini, use smini * identity
	                if (cmax < smini) {
	                    bnorm = Math.max(Math.abs(B[0][0]) + Math.abs(B[0][1]), Math.abs(B[1][0]) + Math.abs(B[1][1]));

	                    if ( (smini < 1.0) && (bnorm > 1.0)) {

	                        if (bnorm > (bignum * smini)) {
	                            scale[0] = 1.0 / bnorm;
	                        }
	                    } // if ((smini < 1.0) && (bnorm > 1.0))

	                    temp = scale[0] / smini;
	                    X[0][0] = temp * B[0][0];
	                    X[1][0] = temp * B[1][0];
	                    X[0][1] = temp * B[0][1];
	                    X[1][1] = temp * B[1][1];
	                    xnorm[0] = temp * bnorm;
	                    info[0] = 1;

	                    return;
	                } // if (cmax < smini)

	                // Gaussian elimination with complete pivoting
	                ur11 = crv[icmax];
	                ui11 = civ[icmax];
	                cr21 = crv[ipivot[1][icmax] - 1];
	                ci21 = civ[ipivot[1][icmax] - 1];
	                ur12 = crv[ipivot[2][icmax] - 1];
	                ui12 = civ[ipivot[2][icmax] - 1];
	                cr22 = crv[ipivot[3][icmax] - 1];
	                ci22 = civ[ipivot[3][icmax] - 1];

	                if ( (icmax == 0) || (icmax == 3)) {

	                    // Code when off-diagonals of pivoted C are real
	                    if (Math.abs(ur11) > Math.abs(ui11)) {
	                        temp = ui11 / ur11;
	                        ur11r = 1.0 / (ur11 * (1.0 + (temp * temp)));
	                        ui11r = -temp * ur11r;
	                    } // if (Math.abs(ur11) > Math.abs(ui11))
	                    else {
	                        temp = ur11 / ui11;
	                        ui11r = -1.0 / (ui11 * (1.0 + (temp * temp)));
	                        ur11r = -temp * ui11r;
	                    }

	                    lr21 = cr21 * ur11r;
	                    li21 = cr21 * ui11r;
	                    ur12s = ur12 * ur11r;
	                    ui12s = ur12 * ui11r;
	                    ur22 = cr22 - (ur12 * lr21);
	                    ui22 = ci22 - (ur12 * li21);
	                } // if ((icmax == 0) || (icmax == 3))
	                else {

	                    // Code when diagonals of pivoted C are real
	                    ur11r = 1.0 / ur11;
	                    ui11r = 0.0;
	                    lr21 = cr21 * ur11r;
	                    li21 = ci21 * ur11r;
	                    ur12s = ur12 * ur11r;
	                    ui12s = ui12 * ur11r;
	                    ur22 = cr22 - (ur12 * lr21) + (ui12 * li21);
	                    ui22 = ( -ur12 * li21) - (ui12 * lr21);
	                } // else

	                u22abs = Math.abs(ur22) + Math.abs(ui22);

	                // If smaller pivot < smini, use smini
	                if (u22abs < smini) {
	                    ur22 = smini;
	                    ui22 = 0.0;
	                    info[0] = 1;
	                } // if (u22abs < smini)

	                if (rswap[icmax]) {
	                    br2 = B[0][0];
	                    br1 = B[1][0];
	                    bi2 = B[0][1];
	                    bi1 = B[1][1];
	                } // if (rswap[icmax])
	                else {
	                    br1 = B[0][0];
	                    br2 = B[1][0];
	                    bi1 = B[0][1];
	                    bi2 = B[1][1];
	                } // else

	                br2 = br2 - (lr21 * br1) + (li21 * bi1);
	                bi2 = bi2 - (li21 * br1) - (lr21 * bi1);
	                bbnd = Math.max( (Math.abs(br1) + Math.abs(bi1)) * (u22abs * (Math.abs(ur11r) + Math.abs(ui11r))), Math
	                        .abs(br2)
	                        + Math.abs(bi2));

	                if ( (bbnd > 1.0) && (u22abs < 1.0)) {

	                    if (bbnd >= (bignum * u22abs)) {
	                        scale[0] = 1.0 / bbnd;
	                        br1 = scale[0] * br1;
	                        bi1 = scale[0] * bi1;
	                        br2 = scale[0] * br2;
	                        bi2 = scale[0] * bi2;
	                    } // if (bbnd >= bignum * u22abs)
	                } // if ((bbnd > 1.0) && (u22abs < 1.0))

	                dladiv(br2, bi2, ur22, ui22, xr2, xi2);
	                xr1 = (ur11r * br1) - (ui11r * bi1) - (ur12s * xr2[0]) + (ui12s * xi2[0]);
	                xi1 = (ui11r * br1) + (ur11r * bi1) - (ui12s * xr2[0]) - (ur12s * xi2[0]);

	                if (zswap[icmax]) {
	                    X[0][0] = xr2[0];
	                    X[1][0] = xr1;
	                    X[0][1] = xi2[0];
	                    X[1][1] = xi1;
	                } else {
	                    X[0][0] = xr1;
	                    X[1][0] = xr2[0];
	                    X[0][1] = xi1;
	                    X[1][1] = xi2[0];
	                }

	                xnorm[0] = Math.max(Math.abs(xr1) + Math.abs(xi1), Math.abs(xr2[0]) + Math.abs(xi2[0]));

	                // Further scaling if norm(A) norm(X) > overflow
	                if ( (xnorm[0] > 1.0) && (cmax > 1.0)) {

	                    if (xnorm[0] > (bignum / cmax)) {
	                        temp = cmax / bignum;
	                        X[0][0] = temp * X[0][0];
	                        X[1][0] = temp * X[1][0];
	                        X[0][1] = temp * X[0][1];
	                        X[1][1] = temp * X[1][1];
	                        xnorm[0] = temp * xnorm[0];
	                        scale[0] = temp * scale[0];
	                    } // if (xnorm[0] > bignum / cmax)
	                } // if ((xnorm[0] > 1.0) && (cmax > 1.0))
	            } // else nw == 2
	        } // else na == 2

	        return;
	    } // dlaln2

	    /**
	     * Port of version 3.2 LAPACK auxiliary routine DLAMC1 Original DLAMC1 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dlamc1 determines the machine parameters given by beta, t, rnd,
	     * and ieee1.
	     * 
	     * @param beta output int[] The base of the machine.
	     * @param t output int[] The number of (beta) digits in the mantissa
	     * @param rnd output boolean[] Specifies whether proper rounding (rnd = true) or chopping (rnd = false) occurs in
	     *            addition. This may not be a reliable guide to the way in which the machine performs its arithmetic.
	     * @param ieee1 output boolean[] Specifies whether rounding appears to be done in the IEEE 'round to nearest' style.
	     *            This routine is based on the routine ENVRON by Malcolm and incorporates suggestions by Gentleman and
	     *            Marovich. See Malcolm, M. A. (1972) Algorithms to reveal properties of floating-point arithmetic.
	     *            Comms. of the ACM, 15, pp. 949-951. Gentleman, W. M. and Marovich S. B. (1974) More on algorithms that
	     *            reveal properties of floating point arithmetic units. Comms. of the ACM, 17, pp. 276-277.
	     */
	    private void dlamc1(final int[] beta, final int[] t, final boolean[] rnd, final boolean[] ieee1) {
	        boolean lieee1;
	        boolean lrnd;
	        int lbeta;
	        int lt;
	        double a;
	        double b;
	        double c;
	        double f;
	        double one;
	        double qtr;
	        double savec;
	        double t1;
	        double t2;

	        one = 1;

	        // lbeta, lieee1, lt, and lrnd are the local values of beta, ieee1, t, and
	        // rnd.

	        // Throughout this routine we use the function dlamc3 to ensure that
	        // relevant values are stored and not held in registers, or are not
	        // affected by optimizers.

	        // Compute a = 2.0**m with the smallest positive integer m such that
	        // computed value(a + 1.0) = a.
	        a = 1;
	        c = 1;

	        while (c == one) {
	            a = 2 * a;
	            c = dlamc3(a, one);
	            c = dlamc3(c, -a);
	        } // while (c == one)

	        // Now compute b = 2.0**m with the smallest positive integer m such that
	        // computed value(a + b) > a
	        b = 1;
	        c = dlamc3(a, b);

	        while (c == a) {
	            b = 2 * b;
	            c = dlamc3(a, b);
	        } // while (c == a)

	        // Now compute the base. a and c are neighboring floating point numbers
	        // in the interval (beta**t, beta**(t+1)) and so their difference is beta.
	        // Adding 0.25 to c is to ensure that it is truncated to beta and not
	        // (beta - 1).

	        qtr = one / 4;
	        savec = c;
	        c = dlamc3(c, -a);
	        lbeta = (int) (c + qtr);

	        // Now determine whether rounding or chopping occurs, by adding a
	        // bit less than beta/2 and a bit more than beta/2 to a.

	        b = lbeta;
	        f = dlamc3(b / 2, -b / 100);
	        c = dlamc3(f, a);

	        if (c == a) {
	            lrnd = true;
	        } else {
	            lrnd = false;
	        }

	        f = dlamc3(b / 2, b / 100);
	        c = dlamc3(f, a);

	        if ( (lrnd) && (c == a)) {
	            lrnd = false;
	        }

	        // Try and decide whether rounding is done in the IEEE 'round to nearest'
	        // style. b/2 is half a unit in the last place of the two numbers a and
	        // savec. Furthermore, a is even, i.e. has last bit zero, and savec is
	        // odd. Thus adding b/2 to a should not change a, but adding b/2 to savec
	        // should change savec.

	        t1 = dlamc3(b / 2, a);
	        t2 = dlamc3(b / 2, savec);
	        lieee1 = (t1 == a) && (t2 > savec) && lrnd;

	        // Now find the mantissa, t. It should be the integer part of log to the
	        // base beta of a, however it is safer to determine t by powering. So we
	        // find t as the smallest positive integer for which
	        // computed value(beta**t + 1.0) = 1.0.

	        lt = 0;
	        a = 1;
	        c = 1;

	        while (c == one) {
	            lt = lt + 1;
	            a = a * lbeta;
	            c = dlamc3(a, one);
	            c = dlamc3(c, -a);
	        } // while (c == one)

	        beta[0] = lbeta;
	        t[0] = lt;
	        rnd[0] = lrnd;
	        ieee1[0] = lieee1;

	        return;
	    } // dlamc1

	    /**
	     * Port of LAPACK version 3.2 auxiliary routine DLAMC2 Original DLAMC2 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, nad NAG Ltd., November, 2006 Determines machine parameters 3 globals are determined: 1.) eps
	     * double The smallest positive number such that computed value(1.0 - eps) < 1.0 2.) rmin double The smallest
	     * normalized number for the machine, given by base**(emin - 1), where base is the floating point value of beta. 3.)
	     * rmax double The largest positive number for the machine, given by base**emax*(1-eps), where base is the floating
	     * point value of beta.
	     * 
	     * @param beta output int[] The base of the machine.
	     * @param t output int[] The number of (beta) digits in the mantissa.
	     * @param rnd ouptut boolean Specifies whether proper rounding (rnd == true) or chopping (rnd == false) occurs in
	     *            addition. This may not be a reliable guide to the way in which the machine performs its arithmetic
	     * @param emin output int[] The minimum exponent before (gradual) underflow occurs
	     * @param emax output int[] The maximum exponent before overflow occurs The computation of EPS is based on a routine
	     *            PARANOIA by W. Kahan of the University of California at Berkeley.
	     */
	    private void dlamc2(final int[] beta, final int[] t, final boolean[] rnd, final int[] emin, final int[] emax) {
	        boolean ieee;
	        boolean iwarn = false;
	        final boolean[] lieee1 = new boolean[1];
	        final boolean[] lrnd = new boolean[1];
	        final int[] gnmin = new int[1];
	        final int[] gpmin = new int[1];
	        int i;
	        final int[] lbeta = new int[1];
	        final int[] lemax = new int[1];
	        int lemin;
	        final int[] lt = new int[1];
	        final int[] ngnmin = new int[1];
	        final int[] ngpmin = new int[1];
	        double a;
	        double b;
	        double c;
	        double half;
	        double leps;
	        final double[] lrmax = new double[1];
	        double lrmin;
	        double one;
	        double rbase;
	        double sixth;
	        double small;
	        double third;
	        double two;
	        double zero;

	        zero = 0;
	        one = 1;
	        two = 2;

	        // lbeta, lt, lrnd, leps, lemin, and lrmin are the local values of beta, t,
	        // rnd, eps, emin, and rmin.

	        // Throughout this routine we use the function dlamc3 to ensure that
	        // relevant values are stored and not held in registers, or are not
	        // affected by optimizers.

	        // dlamc1 returns the parameters lbeta, lt, lrnd, and lieee1.
	        dlamc1(lbeta, lt, lrnd, lieee1);

	        // Start to find eps

	        b = lbeta[0];
	        a = Math.pow(b, -lt[0]);
	        leps = a;

	        // Try some tricks to see whether or not this is the correct eps.
	        b = two / 3;
	        half = one / 2;
	        sixth = dlamc3(b, -half);
	        third = dlamc3(sixth, sixth);
	        b = dlamc3(third, -half);
	        b = dlamc3(b, sixth);
	        b = Math.abs(b);

	        if (b < leps) {
	            b = leps;
	        }

	        leps = 1;

	        while ( (leps > b) && (b > zero)) {
	            leps = b;
	            c = dlamc3(half * leps, Math.pow(two, 5.0) * (leps * leps));
	            c = dlamc3(half, -c);
	            b = dlamc3(half, c);
	            c = dlamc3(half, -b);
	            b = dlamc3(half, c);
	        } // while ((leps > b) && (b > zero))

	        if (a < leps) {
	            leps = a;
	        }

	        // Computation of eps complete.

	        // Now find emin. let a = + or - 1, and + or - (1 + base**(-3)).
	        // Keep dividing a by beta until (gradual) underflow occurs. This
	        // is detected when we cannot recover the previous a.

	        rbase = one / lbeta[0];
	        small = one;

	        for (i = 1; i <= 3; i++) {
	            small = dlamc3(small * rbase, zero);
	        }

	        a = dlamc3(one, small);
	        dlamc4(ngpmin, one, lbeta[0]);
	        dlamc4(ngnmin, -one, lbeta[0]);
	        dlamc4(gpmin, a, lbeta[0]);
	        dlamc4(gnmin, -a, lbeta[0]);
	        ieee = false;

	        if ( (ngpmin[0] == ngnmin[0]) && (gpmin[0] == gnmin[0])) {

	            if (ngpmin[0] == gpmin[0]) {
	                lemin = ngpmin[0];
	                // Non twos-complement machnines, no gradual underflow; e.g., VAX
	            } else if ( (gpmin[0] - ngpmin[0]) == 3) {
	                lemin = ngpmin[0] - 1 + lt[0];
	                ieee = true;
	                // Non twos-complement machines, with gradual underflow; e.g, IEEE
	                // standard followers
	            } else {
	                lemin = Math.min(ngpmin[0], gpmin[0]);

	                // A guess; no known machine
	                iwarn = true;
	            }
	        } // if ((ngpmin[0] == ngnmin[0]) && (gpmin[0] == gnmin[0]))
	        else if ( (ngpmin[0] == gpmin[0]) && (ngnmin[0] == gnmin[0])) {

	            if (Math.abs(ngpmin[0] - ngnmin[0]) == 1) {
	                lemin = Math.max(ngpmin[0], ngnmin[0]);
	                // Twos-complement machines, no gradual underflow, e.g., CYBER 205
	            } else {
	                lemin = Math.min(ngpmin[0], ngnmin[0]);

	                // A guess; no known machine
	                iwarn = true;
	            }
	        } // else if ((ngpmin[0] == gpmin[0]) && (ngnmin[0] == gnmin[0]))
	        else if ( (Math.abs(ngpmin[0] - ngnmin[0]) == 1) && (gpmin[0] == gnmin[0])) {

	            if ( (gpmin[0] - Math.min(ngpmin[0], ngnmin[0])) == 3) {
	                lemin = Math.max(ngpmin[0], ngnmin[0]) - 1 + lt[0];
	                // Twos-complement machines with gradual underflow; no known machine
	            } else {
	                lemin = Math.min(ngpmin[0], ngnmin[0]);

	                // A guess; no known machine
	                iwarn = true;
	            }
	        } // else if ((Math.abs(ngpmin[0] - ngnmin[0]) == 1) && (gpmin[0] == gnmin[0]))
	        else {
	            lemin = Math.min(ngpmin[0], Math.min(ngnmin[0], Math.min(gpmin[0], gnmin[0])));

	            // A guess; no known machine
	            iwarn = true;
	        }

	        if (iwarn) {
	            System.err.print("iwarn is true in dlamc2 emin = " + lemin + "\n");
	            System.err.print("The emin value may be incorrect\n");
	        }

	        // Assume IEEE arithmetic if we found denormalized numbers above, or if
	        // arithmetic seems to round in the IEEE style, determined in routine
	        // dlamc1. A true IEEE machine should have both things true; however,
	        // faulty macines may have one or the other.
	        ieee = ieee || lieee1[0];

	        // Compute rmin by successive division by beta. We could compute rmin as
	        // base**(emin-1), but some machines underflow during this computation.

	        lrmin = 1;

	        for (i = 1; i <= (1 - lemin); i++) {
	            lrmin = dlamc3(lrmin * rbase, zero);
	        }

	        // Finally, call dlamc5 to compute emax and rmax
	        dlamc5(lbeta[0], lt[0], lemin, ieee, lemax, lrmax);

	        beta[0] = lbeta[0];
	        t[0] = lt[0];
	        rnd[0] = lrnd[0];
	        eps = leps;
	        emin[0] = lemin;
	        rmin = lrmin;
	        emax[0] = lemax[0];
	        rmax = lrmax[0];

	        return;
	    } // dlamc2

	    /**
	     * This is a port of the LAPACK version 3.2 auxiliary routine DLAMC3 Original DLAMC3 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlamc3 is intended to force a and b to be stored prior
	     * to doing the addition of a and b, for use in situations where optimizers might hold one of these in a register
	     * 
	     * @param a double
	     * @param b double
	     * 
	     * @return double
	     */
	    private double dlamc3(final double a, final double b) {
	        final double answer = a + b;

	        return answer;
	    }

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLAMC4 Original DLAMC4 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlamc4 is a service routine for dlamc2
	     * 
	     * @param emin output int[] The minimum exponent before (gradual) underflow, computed by setting a = start and
	     *            dividing by base until the previous a cannot be recovered
	     * @param start input double The starting point for determining emin.
	     * @param base input int The base of the machine.
	     */
	    private void dlamc4(final int[] emin, final double start, final int base) {
	        int i;
	        double a;
	        double b1;
	        double b2;
	        double c1;
	        double c2;
	        double d1;
	        double d2;
	        double one;
	        double rbase;
	        double zero;

	        a = start;
	        one = 1;
	        rbase = one / base;
	        zero = 0;
	        emin[0] = 1;
	        b1 = dlamc3(a * rbase, zero);
	        c1 = a;
	        c2 = a;
	        d1 = a;
	        d2 = a;

	        while ( (c1 == a) && (c2 == a) && (d1 == a) && (d2 == a)) {
	            emin[0] = emin[0] - 1;
	            a = b1;
	            b1 = dlamc3(a / base, zero);
	            c1 = dlamc3(b1 * base, zero);
	            d1 = zero;

	            for (i = 1; i <= base; i++) {
	                d1 = d1 + b1;
	            }

	            b2 = dlamc3(a * rbase, zero);
	            c2 = dlamc3(b2 / rbase, zero);
	            d2 = zero;

	            for (i = 1; i <= base; i++) {
	                d2 = d2 + b2;
	            }
	        } // while ((c1 == a) && (c2 == a) && (d1 == a) && (d2 == a))

	        return;
	    } // dlamc4

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLAMC5 Original DLAMC5 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlamc5 attempts to compute rmax, the largest machine
	     * floating-point number, without overflow. It assumes that emax + abs(emin) sum approximately to a power of 2. It
	     * will fail on machines where this assumption does not hold, for example, the Cyber 205 (emin = -28625, emax =
	     * 28718). It will also fail if the value supplied for emin is too large (i.e. too close to zero), probably with
	     * overflow
	     * 
	     * @param beta input int The base of floating-point arithmetic.
	     * @param p input int The number of base beta digits in the mantissa of a floating-point value.
	     * @param emin input int The minimum exponent before (gradual) underflow.
	     * @param ieee input boolean A logical flag specifying whether or not the arithmetic system is thought to comply
	     *            with the IEEE standard.
	     * @param emax output int[] The largest exponent before overflow.
	     * @param rmax output double[] The largest machine floating-point number.
	     */
	    private void dlamc5(final int beta, final int p, final int emin, final boolean ieee, final int[] emax,
	            final double[] rmax) {
	        int exbits;
	        int expsum;
	        int i;
	        int lexp;
	        int nbits;
	        int trya;
	        int uexp;
	        double oldy = 0.0;
	        double recbas;
	        double y;
	        double z;

	        // First compute lexp and uexp, two powers of 2 that bound abs(emin). We
	        // then assume that emax + abs(emin) will sum approximately to the bound
	        // that is closest to abs(emin). (emax is the exponent of the required
	        // number rmax).

	        lexp = 1;
	        exbits = 1;
	        trya = lexp * 2;

	        while (trya <= ( -emin)) {
	            lexp = trya;
	            exbits = exbits + 1;
	            trya = lexp * 2;
	        } // while (trya <= (-emin))

	        if (lexp == -emin) {
	            uexp = lexp;
	        } else {
	            uexp = trya;
	            exbits = exbits + 1;
	        }

	        // Now -lexp is less than or equal to emin, and -uexp is greater than or
	        // equal to emin. exbits is the number of bits needed to store the
	        // exponent.

	        if ( (uexp + emin) > ( -lexp - emin)) {
	            expsum = 2 * lexp;
	        } else {
	            expsum = 2 * uexp;
	        }

	        // expsum is the exponent range, approximately equal to emax - emin + 1
	        emax[0] = expsum + emin - 1;
	        nbits = 1 + exbits + p;

	        // nbits is the total number of bits needed to store a floating-point
	        // number.

	        if ( ( (nbits % 2) == 1) && (beta == 2)) {

	            // Either there are an odd number of bits used to store a floating-point
	            // number, which is unlikely, or some bits are not used in the
	            // representation of numbers, which is possible, (e.g Cray machines) or
	            // the mantissa has an implicit bit, (e.g. IEEE machines, Dec VAX
	            // machines), which is perhaps the most likely. We have to assume the
	            // last alternative. If this is true, then we need to reduce emax by
	            // one because there must be some way of representing zero in an
	            // implicit-bit system. On machines like the Cray, we are reducing
	            // emax by one unnecessarily.
	            emax[0] = emax[0] - 1;
	        }

	        if (ieee) {

	            // Assume we are on an IEEE machine which reserves one exponent for
	            // infinity and NaN
	            emax[0] = emax[0] - 1;
	        }

	        // Now create rmax, the largest machine number, which should be equal to
	        // (1.0 - beta**(-p))* beta**emax.

	        // First compute 1.0 - beta**(-p), being careful that the result is less
	        // than 1.0.

	        recbas = 1.0 / beta;
	        z = beta - 1.0;
	        y = 0.0;

	        for (i = 1; i <= p; i++) {
	            z = z * recbas;

	            if (y < 1.0) {
	                oldy = y;
	            }

	            y = dlamc3(y, z);
	        } // for (i = 1; i <= p; i++)

	        if (y >= 1.0) {
	            y = oldy;
	        }

	        // Now multiply by beta**emax to get rmax

	        for (i = 1; i <= emax[0]; i++) {
	            y = dlamc3(y * beta, 0.0);
	        }

	        rmax[0] = y;

	        return;
	    } // dlamc5

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLAMCH Original DLAMCH created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlamch determines double precision machine parameters.
	     * 
	     * @param cmach input char Specifies the value to be returned by dlamch = 'E' or 'e', returns eps, relative machine
	     *            precision = 'S' or 's', returns sfmin, safe minimum, such that 1/sfmin does not overflow = 'B' or 'b',
	     *            returns base, base of the machine = 'P' or 'p', returns prec = eps*base = 'N' or 'n', returns t,
	     *            number of (base) digits in the mantissa = 'R' or 'r', returns rnd = 1.0 when rounding occurs in
	     *            addition, 0.0 otherwise = 'M' or 'm', returns emin, minimum exponent before (gradual) underflow = 'U'
	     *            or 'u', returns rmin, underflow threshold = base**(emin-1) = 'L' or 'l', emax, largest exponent before
	     *            overflow = 'O' or 'o', rmax, overflow threshold = (base**emax)*(1-eps)
	     * 
	     * @return double
	     */
	    private double dlamch(final char cmach) {

	        final boolean[] lrnd = new boolean[1];
	        final int[] beta = new int[1];
	        final int[] imax = new int[1];
	        final int[] imin = new int[1];
	        final int[] it = new int[1];
	        double rmach = 0.0;
	        double small;

	        if (first) {
	            first = false;
	            dlamc2(beta, it, lrnd, imin, imax);
	            base = beta[0];
	            t = it[0];

	            if (lrnd[0]) {
	                rnd = 1.0;
	                eps = Math.pow(base, (1 - it[0])) / 2.0;
	            } else {
	                rnd = 0.0;
	                eps = Math.pow(base, (1 - it[0]));
	            }

	            prec = eps * base;
	            emin = imin[0];
	            emax = imax[0];
	            sfmin = rmin;
	            small = 1.0 / rmax;

	            if (small >= sfmin) {

	                // Use small plus a bit, to avoid the possibility of rounding causing
	                // overflow when computing 1/sfmin.
	                sfmin = small * (1.0 + eps);
	            }
	        } // if (first)

	        if ( (cmach == 'E') || (cmach == 'e')) {
	            rmach = eps;
	        } else if ( (cmach == 'S') || (cmach == 's')) {
	            rmach = sfmin;
	        } else if ( (cmach == 'B') || (cmach == 'b')) {
	            rmach = base;
	        } else if ( (cmach == 'P') || (cmach == 'p')) {
	            rmach = prec;
	        } else if ( (cmach == 'N') || (cmach == 'N')) {
	            rmach = t;
	        } else if ( (cmach == 'R') || (cmach == 'r')) {
	            rmach = rnd;
	        } else if ( (cmach == 'M') || (cmach == 'm')) {
	            rmach = emin;
	        } else if ( (cmach == 'U') || (cmach == 'u')) {
	            rmach = rmin;
	        } else if ( (cmach == 'L') || (cmach == 'l')) {
	            rmach = emax;
	        } else if ( (cmach == 'O') || (cmach == 'o')) {
	            rmach = rmax;
	        }

	        return rmach;
	    } // dlamch

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLANGB Original DLANGB created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlangb returns the value of
	     * the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n
	     * band matrix A, with kl sub-diagonals and ku super-diagonals.
	     * 
	     * @param norm input char Specifies the value to be returned as: = 'M' or 'm', returns max(abs(A[i][j])), which is
	     *            not a matrix norm. = '1', 'O', or 'o', returns norm1(A), where norm1 denotes the one norm of a matrix
	     *            (maximum column sum) = 'I' or 'i', returns normI(A), the infinity norm of a matrix (maximum row sum) =
	     *            'F', 'f', 'E', or 'e', returns normF(A), the Frobenius norm of a matrix (square root of sum of
	     *            squares)
	     * @param n input int The order of the matrix A. n >= 0. When n = 0, dlangb returns zero.
	     * @param kl input int The number of sub-diagonals of the matrix A. kl >= 0.
	     * @param ku input int The number of super-diagonals of the matrix A. ku >= 0.
	     * @param ab input double[][] of dimension (ldab,n) The band matrix A, stored in rows 0 to kl + ku. The j-th column
	     *            of A is stored in the j-th column of the array ab as follows: ab[ku+1+i-j][j] = A[i][j] for
	     *            max(0,j-ku) <= i <= min(n-1,j+kl)
	     * @param ldab input int The leading dimension of the array ab. ldab >= kl + ku + 1
	     * @param work workspace double[] of dimension max(1, lwork), where lwork >= n when norm = 'I'; otherwise work is
	     *            notreferenced.
	     * 
	     * @return double
	     */
	    private double dlangb(final char norm, final int n, final int kl, final int ku, final double[][] ab,
	            final int ldab, final double[] work) {
	        int i;
	        int j;
	        int k;
	        int L;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];
	        double value = 0.0;
	        double[] x;

	        if (n == 0) {
	            value = 0.0;
	        } else if ( (norm == 'M') || (norm == 'm')) {

	            // Find max(abs(A[i][j]))
	            value = 0.0;

	            for (j = 1; j <= n; j++) {

	                for (i = Math.max(ku + 2 - j, 1); i <= Math.min(n + ku + 1 - j, kl + ku + 1); i++) {
	                    value = Math.max(value, Math.abs(ab[i - 1][j - 1]));
	                }
	            }
	        } // else if ((norm == 'M') || (norm == 'm'))
	        else if ( (norm == 'O') || (norm == 'o') || (norm == '1')) {

	            // Find norm1(A)
	            value = 0.0;

	            for (j = 1; j <= n; j++) {
	                sum[0] = 0.0;

	                for (i = Math.max(ku + 2 - j, 1); i <= Math.min(n + ku + 1 - j, kl + ku + 1); i++) {
	                    sum[0] = sum[0] + Math.abs(ab[i - 1][j - 1]);
	                }

	                value = Math.max(value, sum[0]);
	            }
	        } // else if ((norm == 'O') || (norm == 'o') || (norm == '1'))
	        else if ( (norm == 'I') || (norm == 'i')) {

	            // Find normI(A)
	            for (i = 0; i < n; i++) {
	                work[i] = 0.0;
	            }

	            for (j = 1; j <= n; j++) {
	                k = ku + 1 - j;

	                for (i = Math.max(1, j - ku); i <= Math.min(n, j + kl); i++) {
	                    work[i - 1] = work[i - 1] + Math.abs(ab[k + i - 1][j - 1]);
	                }
	            }

	            value = 0.0;

	            for (i = 0; i < n; i++) {
	                value = Math.max(value, work[i]);
	            }
	        } // else if ((norm == 'I') || (norm == 'i'))
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

	            // Find normF(A)
	            scale[0] = 0.0;
	            sum[0] = 1.0;

	            for (j = 1; j <= n; j++) {
	                L = Math.max(1, j - ku);
	                k = ku + 1 - j + L;
	                x = new double[Math.min(n, j + kl) - L + 1];

	                for (i = 0; i < (Math.min(n, j + kl) - L + 1); i++) {
	                    x[i] = ab[k + i - 1][j - 1];
	                }

	                dlassq(Math.min(n, j + kl) - L + 1, x, 1, scale, sum);
	            }

	            value = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E')

	        return value;
	    }

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLANGE Original DLANGE created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlange returns the value of
	     * the one norm, or the Frobenius norm, or the infinity norm, or the element of the largest absolute value of a real
	     * matrix A.
	     * 
	     * @param norm input char Specifies the value to be returned from dlange as: = 'M' or 'm' returns max(abs(A[i][j])).
	     *            Note that this is not a matrix norm. = '1', 'O' or 'o' returns norm1(A), where norm1 denotes the one
	     *            norm of a matrix (maximum column sum) = 'I' or 'i' returns normI(A), where normI denotes the infinity
	     *            norm of a matrix (maximum row sum) = 'F', 'f', 'E', or 'e' returns normF(A), where normF denotes the
	     *            Frobenius norm of a matrix (square root of sum of squares).
	     * @param m input int The number of rows of the matrix A. m >= 0. When m = 0, dlange returns zero.
	     * @param n input int The number of columns of the matrix A. n >= 0. When n = 0, dlange returns zero.
	     * @param A input double[][] array of dimension (lda,n). Contains the m by n matrix A.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     * @param work workspace double[] of dimension max(1, lwork), where lwork >= m when norm = 'I'; otherwise, work is
	     *            not referenced.
	     * 
	     * @return double
	     */
	    private double dlange(final char norm, final int m, final int n, final double[][] A, final int lda,
	            final double[] work) {
	        int i;
	        int j;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];
	        double value = 0.0;
	        double[] x;

	        if (Math.min(m, n) == 0) {
	            value = 0.0;
	        } else if ( (norm == 'M') || (norm == 'm')) {
	            // Find max(abs(A[i][j]))

	            value = 0.0;

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    value = Math.max(value, Math.abs(A[i][j]));
	                }
	            }
	        } // else if ((norm == 'M') || (norm == 'm'))
	        else if ( (norm == 'O') || (norm == 'o') || (norm == '1')) {

	            // Find norm1(A)
	            value = 0.0;

	            for (j = 0; j < n; j++) {
	                sum[0] = 0.0;

	                for (i = 0; i < m; i++) {
	                    sum[0] = sum[0] + Math.abs(A[i][j]);
	                }

	                value = Math.max(value, sum[0]);
	            } // for (j = 0; j < n; j++)
	        } // else if ((norm == 'O') || (norm == 'o') || (norm == '1'))
	        else if ( (norm == 'I') || (norm == 'i')) {

	            // Find normI(A)
	            for (i = 0; i < m; i++) {
	                work[i] = 0.0;
	            }

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    work[i] = work[i] + Math.abs(A[i][j]);
	                }
	            } // for (j = 0; j < n; j++)

	            value = 0.0;

	            for (i = 0; i < m; i++) {
	                value = Math.max(value, work[i]);
	            }
	        } // else if ((norm == 'I') || (norm == 'i'))
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

	            // Find normF(A)
	            scale[0] = 0.0;
	            sum[0] = 1.0;
	            x = new double[m];

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    x[i] = A[i][j];
	                }

	                dlassq(m, x, 1, scale, sum);
	            } // for (j = 0; j < n; j++)

	            value = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

	        return value;
	    } // dlange

	    /**
	     * This is a port the the version 3.1 LAPACK auxiliary routine DLANHS Original DLANHS created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlanhs returns the value of the one norm, or the
	     * Frobenius norm, or the infinity norm, or the element of largest absolute value of a Hessenberg matrix A.
	     * 
	     * @param norm norm char Specifies the value to be returned in dlanhs as: = 'M' or 'm', max(abs(A[i][j])), which is
	     *            not a matrix norm = '1', 'O', or 'o', norm1(A), the one norm of a matrix (maximum column sum) = 'I' or
	     *            'i', normI(A), the infinity norm of a matrix (maximum row sum) = 'F', 'f', 'E', or 'e', normF(A), the
	     *            Frobenius norm of a matrix (square root of sum of squares)
	     * @param n input int The order of the matrix A. n >= 0. When n = 0, dlanhs returns 0.0.
	     * @param A input double[][] of dimension (lda,n) The n by n upper Hessenberg matrix A; the part of A below the
	     *            first subdiagonal is not referenced.
	     * @param lda input int The leading dimension of the array A. lda >= max(n,1).
	     * @param work workspace double[] of dimension max(1, lwork) where lwork >= n when norm = 'I'; otherwise, work is
	     *            not referenced.
	     * 
	     * @return double
	     */
	    private double dlanhs(final char norm, final int n, final double[][] A, final int lda, final double[] work) {
	        int i;
	        int j;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];
	        double value = 0.0;
	        double[] x;

	        if (n == 0) {
	            value = 0.0;
	        } else if ( (norm == 'M') || (norm == 'm')) {

	            // Find max(abs(A[i][j]))
	            value = 0.0;

	            for (j = 0; j < n; j++) {

	                for (i = 0; i <= Math.min(n - 1, j + 1); i++) {
	                    value = Math.max(value, Math.abs(A[i][j]));
	                }
	            }
	        } // else if ((norm == 'M') || (norm == 'm'))
	        else if ( (norm == 'O') || (norm == 'o') || (norm == '1')) {

	            // Find norm1(A)
	            value = 0.0;

	            for (j = 0; j < n; j++) {
	                sum[0] = 0.0;

	                for (i = 0; i <= Math.min(n - 1, j + 1); i++) {
	                    sum[0] = sum[0] + Math.abs(A[i][j]);
	                }

	                value = Math.max(value, sum[0]);
	            }
	        } // else if ((norm == 'O') || (norm == 'o') || (norm == '1'))
	        else if ( (norm == 'I') || (norm == 'i')) {

	            // Find normI(A)
	            for (i = 0; i < n; i++) {
	                work[i] = 0.0;
	            }

	            for (j = 0; j < n; j++) {

	                for (i = 0; i <= Math.min(n - 1, j + 1); i++) {
	                    work[i] = work[i] + Math.abs(A[i][j]);
	                }
	            }

	            value = 0.0;

	            for (i = 0; i < n; i++) {
	                value = Math.max(value, work[i]);
	            }
	        } // else if ((norm == 'I') || (norm == 'i'))
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

	            // Find normF(A)
	            scale[0] = 0.0;
	            sum[0] = 1.0;

	            for (j = 1; j <= n; j++) {
	                x = new double[Math.min(n, j + 1)];

	                for (i = 0; i < Math.min(n, j + 1); i++) {
	                    x[i] = A[i][j - 1];
	                }

	                dlassq(Math.min(n, j + 1), x, 1, scale, sum);
	            } // for (j = 1; j <= n; j++)

	            value = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

	        return value;
	    } // dlanhs

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLANSB Original DLANSB created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlansb retruns the value of
	     * the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of an n by n
	     * symmetric band matrix A, with k super-diagonals.
	     * 
	     * @param norm input char Specifies the value to be returned as: = 'M' or 'm', returns max(abs(A[i][j])), which is
	     *            not a matrix norm = '1', 'O', or 'o', returns norm1(A), the one norm of a matrix (maximum column sum)
	     *            = 'I' or 'i', returns normI(A), the inifinity norm of a matrix (maximum row sum) = 'F', 'f', 'E', or
	     *            'e', returns normF(A), the Frobenius norm of a matrix (square root of sum of squares)
	     * @param uplo input char Specifies whether the upper or lower triangular part of the band matrix A is supplied =
	     *            'U': Upper triangular part is supplied. = 'L': Lower triangular part is supplied.
	     * @param n input int The order of the matrix A. n >= 0. When n = 0, dlansb returns zero.
	     * @param k input int The number of super-diagonals or sub-diagonals of the band matrix A. k >= 0.
	     * @param ab input double[][] of dimension (ldab,n) The upper or lower triangle of the symmetric band matrix A,
	     *            stored in the first k+1 rows of ab. The j-th column of A is stored in the j-th column of the array ab
	     *            as follows: If uplo = 'U', ab[k+1+i-j][j] = A[i][j] for max(0,j-k) <= i <= j If uplo = 'L',
	     *            ab[1+i-j][j] = A[i][j] for j <= i <= min(n-1,j+k)
	     * @param ldab input int The leading dimension of array ab. ldab >= k + 1.
	     * @param work workspace double[] of dimension max(1, lwork), where lwork >= n when norm = 'I' or '1' or 'O';
	     *            otherwise, work is not referenced.
	     * 
	     * @return DOCUMENT ME!
	     */
	    private double dlansb(final char norm, final char uplo, final int n, final int k, final double[][] ab,
	            final int ldab, final double[] work) {
	        int i;
	        int j;
	        int L;
	        double absa;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];
	        double value = 0.0;
	        double[] x;

	        if (n == 0) {
	            value = 0.0;
	        } else if ( (norm == 'M') || (norm == 'm')) {

	            // Find max(abs(A[i][j]))
	            value = 0.0;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 1; j <= n; j++) {

	                    for (i = Math.max(k + 2 - j, 1); i <= (k + 1); i++) {
	                        value = Math.max(value, Math.abs(ab[i - 1][j - 1]));
	                    }
	                }
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= Math.min(n + 1 - j, k + 1); i++) {
	                        value = Math.max(value, Math.abs(ab[i - 1][j - 1]));
	                    }
	                }
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else if ((norm == 'M') || (norm == 'm'))
	        else if ( (norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o') || (norm == '1')) {

	            // Find normI(A) = norm1(A), since A is symmetric
	            value = 0.0;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 1; j <= n; j++) {
	                    sum[0] = 0.0;
	                    L = k + 1 - j;

	                    for (i = Math.max(1, j - k); i <= (j - 1); i++) {
	                        absa = Math.abs(ab[L + i - 1][j - 1]);
	                        sum[0] = sum[0] + absa;
	                        work[i - 1] = work[i - 1] + absa;
	                    }

	                    work[j - 1] = sum[0] + Math.abs(ab[k][j - 1]);
	                } // for (j = 1; j <= n; j++)

	                for (i = 0; i < n; i++) {
	                    value = Math.max(value, work[i]);
	                }
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (i = 0; i < n; i++) {
	                    work[i] = 0.0;
	                }

	                for (j = 1; j <= n; j++) {
	                    sum[0] = work[j - 1] + Math.abs(ab[0][j - 1]);
	                    L = 1 - j;

	                    for (i = j + 1; i <= Math.min(n, j + k); i++) {
	                        absa = Math.abs(ab[L + i - 1][j - 1]);
	                        sum[0] = sum[0] + absa;
	                        work[i - 1] = work[i - 1] + absa;
	                    }

	                    value = Math.max(value, sum[0]);
	                } // for (j = 1; j <= n; j++)
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else if ((norm == 'I') || (norm == 'i') || (norm == 'O') ||
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

	            // Find normF(A)
	            scale[0] = 0.0;
	            sum[0] = 1.0;

	            if (k > 0) {

	                if ( (uplo == 'U') || (uplo == 'u')) {

	                    for (j = 2; j <= n; j++) {
	                        x = new double[Math.min(j - 1, k)];

	                        for (i = 0; i < Math.min(j - 1, k); i++) {
	                            x[i] = ab[Math.max(k + 1 - j, 0) + i][j - 1];
	                        }

	                        dlassq(Math.min(j - 1, k), x, 1, scale, sum);
	                    }

	                    L = k + 1;
	                } // if ((uplo == 'U') || (uplo == 'u'))
	                else { // ((uplo == 'L') || (uplo == 'l'))

	                    for (j = 1; j <= (n - 1); j++) {
	                        x = new double[Math.min(n - j, k)];

	                        for (i = 0; i <= Math.min(n - j, k); i++) {
	                            x[i] = ab[i + 1][j - 1];
	                        }

	                        dlassq(Math.min(n - j, k), x, 1, scale, sum);
	                    }

	                    L = 1;
	                } // else ((uplo == 'L') || (uplo == 'l'))

	                sum[0] = 2.0 * sum[0];
	            } // if (k > 0)
	            else { // k == 0
	                L = 1;
	            } // else k == 0

	            x = new double[n];

	            for (i = 0; i < n; i++) {
	                x[i] = ab[L - 1][i];
	            }

	            dlassq(n, x, 1, scale, sum);
	            value = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

	        return value;
	    } // dlansb

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLANSP Original DLANSP created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlansp returns the value of
	     * the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real
	     * symmetric matrix A, supplied in packed form.
	     * 
	     * @param norm input char Specifies the value to be returned as: = 'M' or 'm' , max(abs(A[i,j])) Note that this is
	     *            not a matrix norm. = '1', 'O', or 'o', norm1(A) where norm1 denotes the one norm of a matrix (maximum
	     *            column sum) = 'I' or 'i', normI(A) where normI denotes the infinity norm of a matrix (maximum row sum)
	     *            = 'F', 'f', 'E', or 'e', normF(A) where normF denotes the Frobenius norm of a matrix (square root of
	     *            sum of squares)
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrix A is
	     *            supplied. = 'U': Upper triangular part of A is supplied = 'L': Lower triangular part of A is supplied
	     * @param n input int The order of the matrix A. n >= 0. When n = 0, dlansp is set to zero.
	     * @param ap input double[] of dimension (n*(n+1)/2) The upper or lower triangle of the symmetric matrix A, packed
	     *            columnwise in a linear array. The j-th column of A is stored in the array AP as follows: If uplo =
	     *            'U', ap[i + (j-1)*j/2] = A[i][j] for 0 <= i <= j If uplo = 'L', ap[i + (j-1)*(2n-j)/2] = A[i][j] for j
	     *            <= i <= n-1.
	     * @param work workspace double[] of dimension max(1, lwork), where lwork >= n when norm = 'I' or '1' or 'O';
	     *            otherwise work is not referenced.
	     * 
	     * @return double
	     */
	    private double dlansp(final char norm, final char uplo, final int n, final double[] ap, final double[] work) {
	        int i;
	        int j;
	        int k;
	        double absa;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];
	        double[] x;
	        double value = 0.0;
	        double ratio;

	        if (n == 0) {
	            value = 0.0;
	        } else if ( (norm == 'M') || (norm == 'm')) {

	            // Find max(abs(A[i][j]))
	            value = 0.0;

	            if ( (uplo == 'U') || (uplo == 'u')) {
	                k = 1;

	                for (j = 1; j <= n; j++) {

	                    for (i = k; i <= (k + j - 1); i++) {
	                        value = Math.max(value, Math.abs(ap[i - 1]));
	                    }

	                    k = k + j;
	                }
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))
	                k = 1;

	                for (j = 1; j <= n; j++) {

	                    for (i = k; i <= (k + n - j); i++) {
	                        value = Math.max(value, Math.abs(ap[i - 1]));
	                    }

	                    k = k + n - j + 1;
	                }
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else if ((norm == 'M') || (norm == 'm'))
	        else if ( (norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o') || (norm == '1')) {

	            // Find normI(A) == norm1(A), since A is symmetric
	            value = 0.0;
	            k = 1;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 1; j <= n; j++) {
	                    sum[0] = 0.0;

	                    for (i = 1; i <= (j - 1); i++) {
	                        absa = Math.abs(ap[k - 1]);
	                        sum[0] = sum[0] + absa;
	                        work[i - 1] = work[i - 1] + absa;
	                        k = k + 1;
	                    }

	                    work[j - 1] = sum[0] + Math.abs(ap[k - 1]);
	                    k = k + 1;
	                } // for (j = 1; j <= n; j++)

	                for (i = 0; i < n; i++) {
	                    value = Math.max(value, work[i]);
	                }
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (i = 0; i < n; i++) {
	                    work[i] = 0.0;
	                }

	                for (j = 1; j <= n; j++) {
	                    sum[0] = work[j - 1] + Math.abs(ap[k - 1]);
	                    k = k + 1;

	                    for (i = j + 1; i <= n; i++) {
	                        absa = Math.abs(ap[k - 1]);
	                        sum[0] = sum[0] + absa;
	                        work[i - 1] = work[i - 1] + absa;
	                        k = k + 1;
	                    } // for (i = j+1; i <= n; i++)

	                    value = Math.max(value, sum[0]);
	                } // for (j = 1; j <= n; j++)
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else if ((norm == 'I') || (norm == 'i') || (norm == 'O') ||
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {

	            // Find normF(A)
	            scale[0] = 0.0;
	            sum[0] = 1.0;
	            k = 2;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 2; j <= n; j++) {
	                    x = new double[j - 1];

	                    for (i = 0; i < (j - 1); i++) {
	                        x[i] = ap[k - 1 + i];
	                    }

	                    dlassq(j - 1, x, 1, scale, sum);
	                    k = k + j;
	                }
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (j = 1; j <= (n - 1); j++) {
	                    x = new double[n - j];

	                    for (i = 0; i < (n - j); i++) {
	                        x[i] = ap[k - 1 + i];
	                    }

	                    dlassq(n - j, x, 1, scale, sum);
	                    k = k + n - j + 1;
	                }
	            } // else ((uplo == 'L') || (uplo == 'l'))

	            sum[0] = 2.0 * sum[0];
	            k = 1;

	            for (i = 1; i <= n; i++) {

	                if (ap[k - 1] != 0.0) {
	                    absa = Math.abs(ap[k - 1]);

	                    if (scale[0] < absa) {
	                        ratio = scale[0] / absa;
	                        sum[0] = 1.0 + (sum[0] * ratio * ratio);
	                        scale[0] = absa;
	                    } else {
	                        ratio = absa / scale[0];
	                        sum[0] = sum[0] + (ratio * ratio);
	                    }
	                } // if (ap[k-1] != 0.0)

	                if ( (uplo == 'U') || (uplo == 'u')) {
	                    k = k + i + 1;
	                } else {
	                    k = k + n - i + 1;
	                }
	            } // for (i = 1; i <= n; i++)

	            value = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') ||

	        return value;
	    } // dlansp

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine DLANST Original DLANST created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlanst returns the value of the one norm, or the
	     * Frobenius norm, or the infinity norm, or the element of the largest absolute value of a real symmetric
	     * tridiagonal matrix A
	     * 
	     * @param norm input char Specifies the value to be returned as: = 'M' or 'm', max(abs(A[i][j])). This is not a
	     *            matrix norm. = '1', 'O', or 'o', norm1(A), the one norm of a matrix (maximum column sum). = 'I' or
	     *            'i', normI(A), the infinity norm of a matrix (maximum row sum). = 'F', 'f', 'E', or 'e', normF(A), the
	     *            Frobenius norm of a matrix (square root of sum of squares).
	     * @param n input int The order of the matrix A. n >= 0. When n = 0, zero is returned.
	     * @param d input double[] of dimension n. The diagonal elements of A.
	     * @param e input double[] of dimension n-1. The (n-1) sub-diagonal or super-diagonal elements of A.
	     * 
	     * @return double
	     */
	    private double dlanst(final char norm, final int n, final double[] d, final double[] e) {
	        int i;
	        double anorm = 0.0;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];

	        if (n <= 0) {
	            anorm = 0.0;
	        } // if (n <= 0)
	        else if ( (norm == 'M') || (norm == 'm')) {
	            // Find max(abs(A[i][j]))

	            anorm = Math.abs(d[n - 1]);

	            for (i = 0; i < (n - 1); i++) {
	                anorm = Math.max(anorm, Math.abs(d[i]));
	                anorm = Math.max(anorm, Math.abs(e[i]));
	            } // for (i = 0; i < n-1; i++)
	        } // else if ((norm == 'M') == (norm == 'm'))
	        else if ( (norm == 'O') || (norm == 'o') || (norm == '1') || (norm == 'I') || (norm == 'i')) {

	            // Find norm1(A).
	            if (n == 1) {
	                anorm = Math.abs(d[0]);
	            } // if (n == 1)
	            else { // n != 1
	                anorm = Math.max(Math.abs(d[0]) + Math.abs(e[0]), Math.abs(e[n - 2]) + Math.abs(d[n - 1]));

	                for (i = 1; i <= (n - 2); i++) {
	                    anorm = Math.max(anorm, Math.abs(d[i]) + Math.abs(e[i]) + Math.abs(e[i - 1]));
	                } // for (i = 1; i <= n-2; i++)
	            } // else n != 1
	        } // else if ((norm == '0') ||
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {
	            // find normF(A).

	            scale[0] = 0.0;
	            sum[0] = 1.0;

	            if (n > 1) {
	                dlassq(n - 1, e, 1, scale, sum);
	                sum[0] = 2 * sum[0];
	            } // if (n > 1)

	            dlassq(n, d, 1, scale, sum);
	            anorm = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') ||

	        return anorm;
	    } // dlanst

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLANSY. Original DLANSY created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlansy returns the value of
	     * the one norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real
	     * symmetric matrix A.
	     * 
	     * @param norm input char Specifies the value to be returned by dlansy as follows: = 'M' or 'm', max(abs(A[i][j]));
	     *            this is not a matrix norm. = '1', 'O', or 'o', norm1(A), where norm1 denotes the one norm of a matrix
	     *            (maximum column sum) = 'I' or 'i', normI(A), where normI denotes the infinity norm of a matrix
	     *            (maximum row sum) = 'F', 'f', 'E', or 'e', normF(A) , where normF denotes the Frobenius norm of a
	     *            matrix (square root of sum of squares)
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrix A is to be
	     *            referenced. = 'U': Upper triangular part of A is referenced = 'L': Lower triangular part of A is
	     *            referenced
	     * @param n input int The order of the matrix A. n >= 0. When n = 0, the answer returned by dlansy is zero.
	     * @param A input double[][] of dimension lda by n. The symmetric matrix A. If uplo = 'U', the leading n by n upper
	     *            triangular part of A contains the upper triangular part of the matrix A, and the strictly lower
	     *            triangular part of A is not referenced. If uplo = 'L', the leading n by n lower triangular part of A
	     *            contains the lower triangular part of the matrix A, and the strictly upper triangular part of A is not
	     *            referenced.
	     * @param lda input int The leading dimension of the array A. lda >= max(n,1).
	     * @param work workspace double[] of dimension max(1, lwork), where lwork >= n when used with one norm or infinity
	     *            norm; otherwise work is not referenced.
	     * 
	     * @return double
	     */
	    private double dlansy(final char norm, final char uplo, final int n, final double[][] A, final int lda,
	            final double[] work) {
	        int i;
	        int j;
	        double absa;
	        final double[] scale = new double[1];
	        final double[] sum = new double[1];
	        double value = 0.0;
	        double[] vector1;

	        if (n == 0) {
	            value = 0.0;
	        } else if ( (norm == 'M') || (norm == 'm')) {

	            // Find max(abs(A[i][j]))
	            value = 0.0;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i <= j; i++) {
	                        value = Math.max(value, Math.abs(A[i][j]));
	                    }
	                }
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (j = 0; j < n; j++) {

	                    for (i = j; i < n; i++) {
	                        value = Math.max(value, Math.abs(A[i][j]));
	                    }
	                }
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else if ((norm == 'M') || (norm == 'm'))
	        else if ( (norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o') || (norm == '1')) {

	            // Find normI(A) (== norm1(A), since A is symmetric).
	            value = 0.0;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 0; j < n; j++) {
	                    sum[0] = 0.0;

	                    for (i = 0; i <= (j - 1); i++) {
	                        absa = Math.abs(A[i][j]);
	                        sum[0] = sum[0] + absa;
	                        work[i] = work[i] + absa;
	                    } // for (i = 0; i <= j-1; i++)

	                    work[j] = sum[0] + Math.abs(A[j][j]);
	                } // for (j = 0; j < n; j++)

	                for (i = 0; i < n; i++) {
	                    value = Math.max(value, work[i]);
	                } // for (i = 0; i < n; i++)
	            } // if (uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (i = 0; i < n; i++) {
	                    work[i] = 0.0;
	                } // for (i = 0; i < n; i++)

	                for (j = 0; j < n; j++) {
	                    sum[0] = work[j] + Math.abs(A[j][j]);

	                    for (i = j + 1; i < n; i++) {
	                        absa = Math.abs(A[i][j]);
	                        sum[0] = sum[0] + absa;
	                        work[i] = work[i] + absa;
	                    } // for (i = j+1; i < n; i++)

	                    value = Math.max(value, sum[0]);
	                } // for (j = 0; j < n; j++)
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else if ((norm == 'I') || (norm == 'i') || (norm == 'O') || (norm == 'o')
	        else if ( (norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e')) {
	            // Find normF(A)

	            scale[0] = 0.0;
	            sum[0] = 1.0;

	            if ( (uplo == 'U') || (uplo == 'u')) {

	                for (j = 2; j <= n; j++) {
	                    vector1 = new double[j - 1];

	                    for (i = 0; i < (j - 1); i++) {
	                        vector1[i] = A[i][j - 1];
	                    }

	                    dlassq(j - 1, vector1, 1, scale, sum);
	                } // for (j = 2; j <= n; j++)
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                for (j = 1; j <= (n - 1); j++) {
	                    vector1 = new double[n - j];

	                    for (i = 0; i < (n - j); i++) {
	                        vector1[i] = A[j + i][j - 1];
	                    }

	                    dlassq(n - j, vector1, 1, scale, sum);
	                } // for (j = 1; j <= n-1; j++)
	            } // else ((uplo == 'L') || (uplo == 'l'))

	            sum[0] = 2 * sum[0];
	            vector1 = new double[n];

	            for (i = 0; i < n; i++) {
	                vector1[i] = A[i][i];
	            }

	            dlassq(n, vector1, 1, scale, sum);
	            value = scale[0] * Math.sqrt(sum[0]);
	        } // else if ((norm == 'F') || (norm == 'f') || (norm == 'E') || (norm == 'e'))

	        return value;
	    } // dlansy

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLAPY2 Original DLAPY2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlapy2 returns sqrt(x**2 +
	     * y**2), taking care not to cause unnecessary overflow.
	     * 
	     * @param x input double
	     * @param y input double
	     * 
	     * @return double
	     */
	    private double dlapy2(final double x, final double y) {
	        double w;
	        double xabs;
	        double yabs;
	        double z;
	        double ratio;

	        xabs = Math.abs(x);
	        yabs = Math.abs(y);
	        w = Math.max(xabs, yabs);
	        z = Math.min(xabs, yabs);

	        if (z == 0.0) {
	            return w;
	        } else {
	            ratio = z / w;

	            return (w * Math.sqrt(1.0 + (ratio * ratio)));
	        }
	    } // dlapy2

	    /**
	     * dlapy3 is a port of hte version 3.1 LAPLACK auxiliary routine DLAPY3 Original DLAPY3 created by Univ. of
	     * Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006 dlapy3 returns sqrt(x**2+y**2+z**2), taking
	     * care not to cause unnecessary overflow.
	     * 
	     * @param x input double
	     * @param y input double
	     * @param z input double
	     * 
	     * @return double
	     */
	    private double dlapy3(final double x, final double y, final double z) {
	        double w;
	        double xabs;
	        double yabs;
	        double zabs;
	        double result;

	        xabs = Math.abs(x);
	        yabs = Math.abs(y);
	        zabs = Math.abs(z);
	        w = Math.max(xabs, yabs);
	        w = Math.max(w, zabs);

	        if (w == 0.0) {
	            // w can be zero for max(0, NaN, 0)
	            // Adding all three entries together will make sure NaN will not disappear
	            result = xabs + yabs + zabs;
	        } else {
	            xabs = xabs / w;
	            yabs = yabs / w;
	            zabs = zabs / w;
	            result = w * Math.sqrt( (xabs * xabs) + (yabs * yabs) + (zabs * zabs));
	        }

	        return result;
	    } // dlapy3

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine DLARAN Original DLAAN created by Univ. of Tennessee, Univ.
	     * of California Berkeley, and NAG Ltd., November, 2006 dlaran returns a random real number from a uniform (0,1)
	     * distribution This routine uses a multiplicative congruential method with modulus 2**48 and multiplier
	     * 33952834046453 (see G. S. Fishman, "Multiplicative congruential random number generators with modulus 2**b: an
	     * exhaustive analysis for b = 32 and a partial analysis for b = 48", Math. Comp. 189, pp. 331-344, 1990).
	     * 
	     * <p>
	     * 48-bit integers are stored in 4 integer array elements with 12 bits per element. Hence the routine is portable
	     * across machines with integers of 32 bits or more.
	     * </p>
	     * 
	     * @param iseed (input/output) int[] of dimension 4. On entry, the seed of the random number generator; the array
	     *            elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
	     * 
	     * @return double
	     */
	    private double dlaran(final int[] iseed) {
	        final int m1 = 494;
	        final int m2 = 322;
	        final int m3 = 2508;
	        final int m4 = 2549;
	        final int ipw2 = 4096;
	        final double r = 1.0 / ipw2;
	        int it1;
	        int it2;
	        int it3;
	        int it4;
	        double rndout = 1.0;

	        while (rndout == 1.0) {
	            // Multiply the seed by the multiplier module 2**48
	            it4 = iseed[3] * m4;
	            it3 = it4 / ipw2;
	            it4 = it4 - (ipw2 * it3);
	            it3 = it3 + (iseed[2] * m4) + (iseed[3] * m3);
	            it2 = it3 / ipw2;
	            it3 = it3 - (ipw2 * it2);
	            it2 = it2 + (iseed[1] * m4) + (iseed[2] * m3) + (iseed[3] * m2);
	            it1 = it2 / ipw2;
	            it2 = it2 - (ipw2 * it1);
	            it1 = it1 + (iseed[0] * m4) + (iseed[1] * m3) + (iseed[2] * m2) + (iseed[3] * m1);
	            it1 = it1 % ipw2;

	            // Return updated seed
	            iseed[0] = it1;
	            iseed[1] = it2;
	            iseed[2] = it3;
	            iseed[3] = it4;

	            // Convert 48-bit integer to a real number in the interval (0,1)
	            rndout = r * (it1 + (r * (it2 + (r * (it3 + (r * it4))))));
	            // If a real number has n bits of precision, and the first n bits of the 48-bit integer above happen
	            // to be all 1 (which will occur about once every 2**n calls), then rndout will be rounded to exactly 1.0
	            // Since dlaran is not supposed to return exactly 0.0 or 1.0, the statistically correct thing to do in
	            // this situation is simply to iterate again.
	            // N.B. The case rndout = 0.0 should not be possible.
	        } // while (rndout == 1.0)
	        return rndout;
	    } // dlaran

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLARF Original DLARF created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlarf applies a real
	     * elementary reflector H to a real m by n matrix C, from either the left or right. H is represented in the form H =
	     * I - tau * v * v' where tau is a real scalar and v is a real vector. If tau = 0, then H is taken to be the unit
	     * matrix.
	     * 
	     * @param side input char = 'L': form H * C, = 'R': form C * H
	     * @param m input int The number of rows of the matrix C
	     * @param n input int The number of columns of the matrix C.
	     * @param v input double[] If side = 'L' dimension = (1 + (m-1)*abs(incv)) If side = 'R' dimension = (1 +
	     *            (n-1)*abs(incv)) The vector v in the representation of H. v is not used if tau = 0.
	     * @param incv input int The increment between elements of v. incv <> 0.
	     * @param tau input double The value of tau in the representation of H.
	     * @param C input/output double[][] of dimension ldc by n. On entry, the m by n matrix C. On exit, C is overwritten
	     *            by the matrix H * C if side = 'L', or C * H if side = 'R'.
	     * @param ldc input int The leading dimension of array C. ldc >= max(1,m).
	     * @param work workspace double[] If side = 'L', dimension = n. If side = 'R', dimension = m.
	     */
	    private void dlarf(final char side, final int m, final int n, final double[] v, final int incv, final double tau,
	            final double[][] C, final int ldc, final double[] work) {
	        boolean applyLeft;
	        int i;
	        int lastV;
	        int lastC;

	        applyLeft = ( (side == 'L') || (side == 'l'));
	        lastV = 0;
	        lastC = 0;
	        if (tau != 0.0) {
	            // Set up variables for scanning V. lastV begins pointing to the end of v.
	            if (applyLeft) {
	                lastV = m;
	            } else {
	                lastV = n;
	            }
	            if (incv > 0) {
	                i = 1 + (lastV - 1) * incv;
	            } else {
	                i = 1;
	            }
	            // Look for the last non-zero row in v.
	            while ( (lastV > 0) && (v[i - 1] == 0.0)) {
	                lastV = lastV - 1;
	                i = i - incv;
	            }
	            if (applyLeft) {
	                // Scan for the last non-zero column in C(0:lastv-1,:)
	                lastC = iladlc(lastV, n, C, ldc);
	            } else {
	                // Scan for the last non-zero row in C(:,0:lastV-1)
	                lastC = iladlr(m, lastV, C, ldc);
	            }
	        } // if (tau != 0.0)
	        // Note that lastC == 0 renders BLAS operations null; no special case is needed at this level.

	        if (applyLeft) {

	            // Form H * C
	            if (lastV > 0) {

	                // w(0:lastC-1,0) = C(0:lastV-1,0:lastC-1)' * v(0:lastV-1,0)
	                dgemv('T', lastV, lastC, 1.0, C, ldc, v, incv, 0.0, work, 1);

	                // C(0:lastV-1,0:lastC-1) = C(...) - v(0:lastV-1,0) * w(0:lastC-1,0)'
	                dger(lastV, lastC, -tau, v, incv, work, 1, C, ldc);
	            } // if (lastV > 0)
	        } // if (applyLeft)
	        else { // !applyLeft)

	            // Form C * H
	            if (lastV > 0) {

	                // w():lastC-1,0) = C(0:lastC-1,0:lastV-1) * v(0:lastV-1,0)
	                dgemv('N', lastC, lastV, 1.0, C, ldc, v, incv, 0.0, work, 1);

	                // C(0:lastC-1,0:lastV-1) = C(...) - w(0:lastC-1,0) * v(0:lastV-1,0)'
	                dger(lastC, lastV, -tau, work, 1, v, incv, C, ldc);
	            } // if (lastV > 0)
	        } // else !applyLeft

	        return;
	    } // dlarf

	    /**
	     * This is a port of LAPACK auxiliary routine (version 3.2.1) ILADLC, April 2009 Original ILADLC created by Univ. of
	     * Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd.
	     * 
	     * iladlc scans A for its last non-zero column
	     * 
	     * @param m input int The number of rows in matrix A.
	     * @param n input int The number of columns in matrix A.
	     * @param A input double[][] of dimension lda by n. The m by n matrix A.
	     * @param lda input int The leading dimension of the array A. lda >= max(1, m)
	     */
	    private int iladlc(final int m, final int n, final double A[][], final int lda) {
	        int i;
	        int j;

	        // Quick test for the common case where one corner is non-zero.
	        if (n == 0) {
	            return n;
	        } else if ( (A[0][n - 1] != 0.0) || (A[m - 1][n - 1] != 0.0)) {
	            return n;
	        } else {
	            // Now scan each column form the end, returning with the first non-zero.
	            for (j = n; j >= 1; j--) {
	                for (i = 1; i <= m; i++) {
	                    if (A[i - 1][j - 1] != 0.0) {
	                        return j;
	                    }
	                }
	            }
	            return 0;
	        }
	    } // iladlc

	    /**
	     * This is a port of LAPACK auxiliary routine (version 3.2.1) ILADLR, April 2009 Original ILADLR created by Univ. of
	     * Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd.
	     * 
	     * iladlc scans A for its last non-zero column
	     * 
	     * @param m input int The number of rows in matrix A.
	     * @param n input int The number of columns in matrix A.
	     * @param A input double[][] of dimension lda by n. The m by n matrix A.
	     * @param lda input int The leading dimension of the array A. lda >= max(1, m)
	     */
	    private int iladlr(final int m, final int n, final double A[][], final int lda) {
	        int i;
	        int j;
	        int r;

	        // Quick test for the common case where one corner is non-zero.
	        if (m == 0) {
	            return m;
	        } else if ( (A[m - 1][0] != 0.0) || (A[m - 1][n - 1] != 0.0)) {
	            return m;
	        } else {
	            // Scan up each column tracking the last zero row seen.
	            r = 0;
	            for (j = 1; j <= n; j++) {
	                for (i = m; i >= 1; i--) {
	                    if (A[i - 1][j - 1] != 0.0) {
	                        break;
	                    }
	                }
	                r = Math.max(r, i);
	            }
	            return r;
	        }
	    } // iladlc

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLARFB Original DLARFB created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlarfb applies a real block
	     * reflector H or its transpose H' to a real m by n matrix C, from either the left or the right.
	     * 
	     * @param side input char = 'L': apply H or H' from the left = 'R': apply H or H' from the right
	     * @param trans input char = 'N': Apply H (No transpose) = 'T': Apply H' (Transpose)
	     * @param direct input char Indicates how H is formed from a product of elementary reflectors = 'F': H = H[0] H[1]
	     *            ... H[k-1] (Forward) = 'B': H = H[k-1] ... H[1] H[0] (Backward)
	     * @param storev input char Indicates how the vectors which define the elementary reflectors are stored: = 'C':
	     *            Columnwise = 'R': Rowwise
	     * @param m input int The number of rows of the matrix C.
	     * @param n input int The number of columns of the matrix C.
	     * @param k input int The order of the matrix T (= the number of elementary reflectors whose product defines the
	     *            block reflector).
	     * @param V input double[][] If storev = 'C', dimensions are ldv by k. If storev = 'R' and side = 'L', dimensions
	     *            are ldv by m. If storev = 'R' and side = 'R', dimensions are ldv by n.
	     * @param ldv input int The leading dimension of the array V. If storev = 'C' and side = 'L', ldv >= max(1,m). If
	     *            storev = 'C' and side = 'R', ldv >= max(1,n). If storev = 'R', ldv >= k.
	     * @param T input double[][] of dimensions ldt by k The triangular k by k matrix T in the representation of the
	     *            block reflector.
	     * @param ldt input int The leading dimension of the array T. ldt >= k.
	     * @param C input/output double[][] of dimensions ldc by n. On entry, the m by n matrix C. On exit, C is overwritten
	     *            by H*C or H'*C or C*H or C*H'.
	     * @param ldc input int The leading dimension of the array C. ldc >= max(1,m).
	     * @param work workspace double[][] of dimensions ldwork by k
	     * @param ldwork input int The leading dimension of the array work. If side = 'L', ldwork >= max(1,n). If side =
	     *            'R', ldwork >= max(1,m).
	     */
	    private void dlarfb(final char side, final char trans, final char direct, final char storev, final int m,
	            final int n, final int k, final double[][] V, final int ldv, final double[][] T, final int ldt,
	            final double[][] C, final int ldc, final double[][] work, final int ldwork) {
	        char transt;
	        int i;
	        int j;
	        int p;
	        int q;
	        int lastV;
	        int lastC;
	        int row1;
	        int row2;
	        double[][] array1;
	        double[][] array2;

	        // Quick return if possible
	        if ( (m <= 0) || (n <= 0)) {
	            return;
	        }

	        if ( (trans == 'N') || (trans == 'n')) {
	            transt = 'T';
	        } else {
	            transt = 'N';
	        }

	        if ( (storev == 'C') || (storev == 'c')) {

	            if ( (direct == 'F') || (direct == 'f')) {

	                // Let V = (V1) (first k rows)
	                // (V2)
	                // where V1 is unit lower triangular
	                if ( (side == 'L') || (side == 'l')) {

	                    // Form H * C or H' * C where C = ( C1 )
	                    // ( C2 )
	                    lastV = Math.max(k, iladlr(m, k, V, ldv));
	                    lastC = iladlc(lastV, n, C, ldc);
	                    // W = C' * V = (C1'*V1 + C2'*V2) (stored in work)
	                    // W = C1'
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[j][p];
	                        }
	                    } // for (j = 0; j < k; j++)

	                    // W = W * V1
	                    dtrmm('R', 'L', 'N', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C2'* V2
	                        row1 = Math.max(1, lastV - k);
	                        array1 = new double[row1][lastC];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < lastC; q++) {
	                                array1[p][q] = C[p + k][q];
	                            }
	                        }

	                        array2 = new double[row1][k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < k; q++) {
	                                array2[p][q] = V[p + k][q];
	                            }
	                        }

	                        dgemm('T', 'N', lastC, k, lastV - k, 1.0, array1, row1, array2, row1, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T' or W * T
	                    dtrmm('R', 'U', transt, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - V * W'
	                    if (lastV > k) {

	                        // C2 = C2 - V2 * W'
	                        row1 = Math.max(1, lastV - k);
	                        array1 = new double[row1][k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < k; q++) {
	                                array1[p][q] = V[p + k][q];
	                            }
	                        }

	                        array2 = new double[row1][lastC];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < lastC; q++) {
	                                array2[p][q] = C[p + k][q];
	                            }
	                        }

	                        dgemm('N', 'T', lastV - k, lastC, k, -1.0, array1, row1, work, ldwork, 1.0, array2, row1);

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < lastC; q++) {
	                                C[p + k][q] = array2[p][q];
	                            }
	                        }
	                    } // if (lastV > k)

	                    // W = W * V1'
	                    dtrmm('R', 'L', 'T', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    // C1 = C1 - W'
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[j][i] = C[j][i] - work[i][j];
	                        }
	                    }
	                } // if ((side == 'L') || (side == 'l'))
	                else if ( (side == 'R') || (side == 'r')) {

	                    // Form C * H or C * H' where C = ( C1 C2 )
	                    lastV = Math.max(k, iladlr(n, k, V, ldv));
	                    lastC = iladlr(m, lastV, C, ldc);
	                    // W = C * V = (C1*V1 + C2*V2) (stored in work)
	                    // W = C1
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[p][j];
	                        }
	                    } // for (j = 0; j < k; j++)

	                    // W = W * V1
	                    dtrmm('R', 'L', 'N', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C2 * V2
	                        row1 = Math.max(1, lastC);
	                        array1 = new double[row1][lastV - k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array1[p][q] = C[p][q + k];
	                            }
	                        }

	                        row2 = Math.max(1, lastV - k);
	                        array2 = new double[row2][k];

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < k; q++) {
	                                array2[p][q] = V[p + k][q];
	                            }
	                        }

	                        dgemm('N', 'N', lastC, k, lastV - k, 1.0, array1, row1, array2, row2, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T or W * T'
	                    dtrmm('R', 'U', trans, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - W * V'
	                    if (lastV > k) {

	                        // C2 = C2 - W * V2'
	                        row1 = Math.max(1, lastV - k);
	                        array1 = new double[row1][k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < k; q++) {
	                                array1[p][q] = V[p + k][q];
	                            }
	                        }

	                        row2 = Math.max(1, lastC);
	                        array2 = new double[row2][lastV - k];

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array2[p][q] = C[p][q + k];
	                            }
	                        }

	                        dgemm('N', 'T', lastC, lastV - k, k, -1.0, work, ldwork, array1, row1, 1.0, array2, row2);

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                C[p][q + k] = array2[p][q];
	                            }
	                        }
	                    } // if (lastV > k)

	                    // W = W * V1'
	                    dtrmm('R', 'L', 'T', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    // C1 = C1 - W
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[i][j] = C[i][j] - work[i][j];
	                        }
	                    }
	                } // else if ((side == 'R') || (side == 'r'))
	            } // if ((direct == 'F') || (direct == 'f'))
	            else { // ((direct == 'B') || (direct == 'b'))

	                // Let V = ( V1 )
	                // ( V2 ) (last k rows)
	                // where V2 is unit upper triangular.
	                if ( (side == 'L') || (side == 'l')) {

	                    // Form H * C or H' * C where C = ( C1 )
	                    // ( C2 )
	                    lastV = Math.max(k, iladlr(m, k, V, ldv));
	                    lastC = iladlc(lastV, n, C, ldc);
	                    // W = C' * V = (C1'*V1 + C2'*V2) (stored in work)
	                    // W = C2'
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[lastV - k + j][p];
	                        }
	                    } // for (j = 0; j < k; j++)

	                    // W = W * V2
	                    row1 = Math.max(1, k);
	                    array1 = new double[row1][k];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p + lastV - k][q];
	                        }
	                    }

	                    dtrmm('R', 'U', 'N', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C1' * V1
	                        dgemm('T', 'N', lastC, k, lastV - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T' or W * T
	                    dtrmm('R', 'L', transt, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - V * W'
	                    if (lastV > k) {

	                        // C1 = C1 - V1 * W'
	                        dgemm('N', 'T', lastV - k, lastC, k, -1.0, V, ldv, work, ldwork, 1.0, C, ldc);
	                    } // if (lastV > k)

	                    // W = W * V2'
	                    row1 = Math.max(1, k);
	                    array1 = new double[row1][k];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p + lastV - k][q];
	                        }
	                    }

	                    dtrmm('R', 'U', 'T', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    // C2 = C2 - W'
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[lastV - k + j][i] = C[lastV - k + j][i] - work[i][j];
	                        }
	                    }
	                } // if ((side == 'L') || (side == 'l'))
	                else if ( (side == 'R') || (side == 'r')) {

	                    // Form C * H or C * H' where C = ( C1 C2 )
	                    lastV = Math.max(k, iladlr(n, k, V, ldv));
	                    lastC = iladlr(m, lastV, C, ldc);
	                    // W = C * V = (C1*V1 + C2*V2) (stored in work)
	                    // W = C2
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[p][n - k + j];
	                        }
	                    }

	                    // W = W * V2
	                    row1 = Math.max(1, k);
	                    array1 = new double[row1][k];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p + lastV - k][q];
	                        }
	                    }

	                    dtrmm('R', 'U', 'N', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C1 * V1
	                        dgemm('N', 'N', lastC, k, lastV - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T or W * T'
	                    dtrmm('R', 'L', trans, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - W * V'
	                    if (lastV > k) {

	                        // C1 = C1 - W * V1'
	                        dgemm('N', 'T', lastC, lastV - k, k, -1.0, work, ldwork, V, ldv, 1.0, C, ldc);
	                    } // if (lastV > k)

	                    // W = W * V2'
	                    row1 = Math.max(1, k);
	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p + lastV - k][q];
	                        }
	                    }

	                    dtrmm('R', 'U', 'T', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    // C2 = C2 - W
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[i][lastV - k + j] = C[i][lastV - k + j] - work[i][j];
	                        }
	                    }
	                } // else if ((side == 'R') || (side == 'r'))
	            } // else ((direct == 'B') || (direct == 'b'))
	        } // if ((storev == 'C') || (storev == 'c'))
	        else if ( (storev == 'R') || (storev == 'r')) {

	            if ( (direct == 'F') || (direct == 'f')) {

	                // Let V = ( V1 V2 ) (V1: first k columns)
	                // where V1 is unit upper triangular
	                if ( (side == 'L') || (side == 'l')) {

	                    // Form H * C or H' * C where C = ( C1 )
	                    // ( C2 )
	                    lastV = Math.max(k, iladlc(k, m, V, ldv));
	                    lastC = iladlc(lastV, n, C, ldc);
	                    // W = C' * V' = (C1'*V1' + C2'V2') (stored in work)
	                    // W = C1'
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[j][p];
	                        }
	                    }

	                    // W = W * V1'
	                    dtrmm('R', 'U', 'T', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C2'*V2'
	                        row1 = Math.max(1, lastV - k);
	                        array1 = new double[row1][lastC];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < lastC; q++) {
	                                array1[p][q] = C[p + k][q];
	                            }
	                        }

	                        row2 = Math.max(1, k);
	                        array2 = new double[row2][lastV - k];

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array2[p][q] = V[p][q + k];
	                            }
	                        }

	                        dgemm('T', 'T', lastC, k, lastV - k, 1.0, array1, row1, array2, row2, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T' or W * T
	                    dtrmm('R', 'U', transt, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - V' * W'
	                    if (lastV > k) {

	                        // C2 = C2 - V2' * W'
	                        row1 = Math.max(1, k);
	                        array1 = new double[row1][lastV - k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array1[p][q] = V[p][q + k];
	                            }
	                        }

	                        array2 = new double[row1][lastC];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < lastC; q++) {
	                                array2[p][q] = C[p + k][q];
	                            }
	                        }

	                        dgemm('T', 'T', lastV - k, lastC, k, -1.0, array1, row1, work, ldwork, 1.0, array2, row1);

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < lastC; q++) {
	                                C[p + k][q] = array2[p][q];
	                            }
	                        }
	                    } // if (lastV > k)

	                    // W = W * V1
	                    dtrmm('R', 'U', 'N', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    // C1 = C1 - W'
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[j][i] = C[j][i] - work[i][j];
	                        }
	                    }
	                } // if ((side == 'L') || (side == 'l'))
	                else if ( (side == 'R') || (side == 'r')) {

	                    // Form C * H or C * H' where C = ( C1 C2 )
	                    lastV = Math.max(k, iladlc(k, n, V, ldv));
	                    lastC = iladlr(m, lastV, C, ldc);
	                    // W = C * V' = (C1*V1' + C2*V2') (stored in work)
	                    // W = C1
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[p][j];
	                        }
	                    }

	                    // W = W * V1'
	                    dtrmm('R', 'U', 'T', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C2 * V2'
	                        row1 = Math.max(1, lastC);
	                        array1 = new double[row1][lastV - k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array1[p][q] = C[p][q + k];
	                            }
	                        }

	                        row2 = Math.max(1, k);
	                        array2 = new double[row2][lastV - k];

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array2[p][q] = V[p][q + k];
	                            }
	                        }

	                        dgemm('N', 'T', lastC, k, lastV - k, 1.0, array1, row1, array2, row2, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T or W * T'
	                    dtrmm('R', 'U', trans, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - W * V
	                    if (lastV > k) {

	                        // C2 = C2 - W * V2
	                        row1 = Math.max(1, k);
	                        array1 = new double[row1][lastV - k];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array1[p][q] = V[p][q + k];
	                            }
	                        }

	                        row2 = Math.max(1, lastC);
	                        array2 = new double[row2][lastV - k];

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                array2[p][q] = C[p][q + k];
	                            }
	                        }

	                        dgemm('N', 'N', lastC, lastV - k, k, -1.0, work, ldwork, array1, row1, 1.0, array2, row2);

	                        for (p = 0; p < row2; p++) {

	                            for (q = 0; q < (lastV - k); q++) {
	                                C[p][q + k] = array2[p][q];
	                            }
	                        }
	                    } // if (lastV > k)

	                    // W = W * V1
	                    dtrmm('R', 'U', 'N', 'U', lastC, k, 1.0, V, ldv, work, ldwork);

	                    // C1 = C1 - W
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[i][j] = C[i][j] - work[i][j];
	                        }
	                    }
	                } // else if ((side == 'R') || (side == 'r'))
	            } // if ((direct == 'F') || (direct == 'f'))
	            else { // ((direct == 'B') || (direct == 'B'))

	                // Let V = ( V1 V2 ) (V2: last k columns)
	                // where V2 is unit lower triangular
	                if ( (side == 'L') || (side == 'l')) {

	                    // Form H * C or H' * C where C = ( C1 )
	                    // ( C2 )
	                    lastV = Math.max(k, iladlc(k, m, V, ldv));
	                    lastC = iladlc(lastV, n, C, ldc);
	                    // W = C' * V' = (C1'*V1' + C2'*V2') (stored in work)
	                    // W = C2'
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[lastV - k + j][p];
	                        }
	                    }

	                    // W = W * V2'
	                    row1 = Math.max(1, k);
	                    array1 = new double[row1][k];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p][q + lastV - k];
	                        }
	                    }

	                    dtrmm('R', 'L', 'T', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C1'*V1'
	                        dgemm('T', 'T', lastC, k, lastV - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T' or W * T
	                    dtrmm('R', 'L', transt, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - V' * W'
	                    if (lastV > k) {

	                        // C1 = C1 - V1' * W'
	                        dgemm('T', 'T', lastV - k, lastC, k, -1.0, V, ldv, work, ldwork, 1.0, C, ldc);
	                    } // if (lastV > k)

	                    // W = W * V2
	                    row1 = Math.max(1, k);
	                    array1 = new double[row1][k];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p][q + lastV - k];
	                        }
	                    }

	                    dtrmm('R', 'L', 'N', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    // C2 = C2 - W'
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[lastV - k + j][i] = C[lastV - k + j][i] - work[i][j];
	                        }
	                    }
	                } // if ((side == 'L') || (side == 'l'))
	                else if ( (side == 'R') || (side == 'r')) {

	                    // Form C * H or C * H' where C = ( C1 C2 )
	                    lastV = Math.max(k, iladlc(k, n, V, ldv));
	                    lastC = iladlr(m, lastV, C, ldc);
	                    // W = C * V' = (C1*V1' + C2*V2') (stored in work)
	                    // W = C2
	                    for (j = 0; j < k; j++) {

	                        for (p = 0; p < lastC; p++) {
	                            work[p][j] = C[p][lastV - k + j];
	                        }
	                    }

	                    // W = W * V2'
	                    row1 = Math.max(1, k);
	                    array1 = new double[row1][k];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p][q + lastV - k];
	                        }
	                    }

	                    dtrmm('R', 'L', 'T', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    if (lastV > k) {

	                        // W = W + C1 * V1'
	                        dgemm('N', 'T', lastC, k, lastV - k, 1.0, C, ldc, V, ldv, 1.0, work, ldwork);
	                    } // if (lastV > k)

	                    // W = W * T or W * T'
	                    dtrmm('R', 'L', trans, 'N', lastC, k, 1.0, T, ldt, work, ldwork);

	                    // C = C - W * V
	                    if (lastV > k) {

	                        // C1 = C1 - W * V1
	                        dgemm('N', 'N', lastC, lastV - k, k, -1.0, work, ldwork, V, ldv, 1.0, C, ldc);
	                    } // if (lastV > k)

	                    // W = W * V2
	                    row1 = Math.max(1, k);
	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < k; q++) {
	                            array1[p][q] = V[p][q + lastV - k];
	                        }
	                    }

	                    dtrmm('R', 'L', 'N', 'U', lastC, k, 1.0, array1, row1, work, ldwork);

	                    // C1 = C1 - W
	                    for (j = 0; j < k; j++) {

	                        for (i = 0; i < lastC; i++) {
	                            C[i][lastV - k + j] = C[i][lastV - k + j] - work[i][j];
	                        }
	                    }
	                } // else if ((side == 'R') || (side == 'r'))
	            } // else ((direct == 'B') || (direct == 'B'))
	        } // else if ((storev == 'R') || (storev == 'r'))

	        return;
	    } // dlarfb

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLARFG Original DLARFG created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlarfg generates a real elementary reflector H of
	     * order n, such that H * (alpha) = (beta), H' * H = I. ( x ) ( 0 ) where alpha and beta are scalars, and x is an
	     * (n-1)-element real vector. H is represented in the form H = I - tau * (1) * (1 v'), (v) where tau is a real
	     * scalar and v is a real (n-1)-element vector. If the elements of x are all zero, then tau = 0 and H is taken to be
	     * the unit matrix. Otherwise 1 <= tau <= 2.
	     * 
	     * @param n input int The order of the elementary reflector.
	     * @param alpha input/output double[] On entry, the value alpha. On exit, it is overwritten with the value beta.
	     * @param x input/output double[] of dimension (1 + (n-2)*abs(incx)) On entry, the vector x. On exit, it is
	     *            overwritten with the vector v.
	     * @param incx input int The increment between elements of x. incx > 0
	     * @param tau output double[] The value tau
	     */
	    private void dlarfg(final int n, final double[] alpha, final double[] x, final int incx, final double[] tau) {
	        int j;
	        int knt;
	        double beta;
	        double rsafmn;
	        double safmin;
	        double xnorm;

	        if (n <= 1) {
	            tau[0] = 0.0;

	            return;
	        }

	        xnorm = dnrm2(n - 1, x, incx);

	        if (xnorm == 0.0) {

	            // H = I
	            tau[0] = 0.0;
	        } // if (xnorm == 0.0)
	        else { // general case

	            if (alpha[0] >= 0.0) {
	                beta = -Math.abs(dlapy2(alpha[0], xnorm));
	            } else {
	                beta = Math.abs(dlapy2(alpha[0], xnorm));
	            }

	            safmin = dlamch('S') / dlamch('E');
	            knt = 0;
	            if (Math.abs(beta) < safmin) {

	                // xnorm, beta may be inaccurate; scale x and recompute them
	                rsafmn = 1.0 / safmin;

	                do {
	                    knt = knt + 1;
	                    dscal(n - 1, rsafmn, x, incx);
	                    beta = beta * rsafmn;
	                    alpha[0] = alpha[0] * rsafmn;
	                } while (Math.abs(beta) < safmin);

	                // New beta is at most 1, at least safmin
	                xnorm = dnrm2(n - 1, x, incx);

	                if (alpha[0] >= 0.0) {
	                    beta = -Math.abs(dlapy2(alpha[0], xnorm));
	                } else {
	                    beta = Math.abs(dlapy2(alpha[0], xnorm));
	                }
	            } // if (Math.abs(beta) < safmin)

	            tau[0] = (beta - alpha[0]) / beta;
	            dscal(n - 1, 1.0 / (alpha[0] - beta), x, incx);

	            // If alpha is subnormal, it may lose relative accuracy

	            for (j = 1; j <= knt; j++) {
	                beta = beta * safmin;
	            }
	            alpha[0] = beta;
	        } // else general case

	        return;
	    } // dlarfg

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLARFP Original DLARFP created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlarfp generates a real
	     * elementary reflector H of order n, such that H * (alpha) = (beta), H' * H = I. ( x ) ( 0 ) where alpha and beta
	     * are scalars, beta is non-negative, and x is an (n-1)-element real vector. H is represented in the form H = I -
	     * tau * (1) * (1 v'), (v) where tau is a real scalar and v is a real (n-1)-element vector. If the elements of x are
	     * all zero, then tau = 0 and H is taken to be the unit matrix. Otherwise 1 <= tau <= 2.
	     * 
	     * @param n input int The order of the elementary reflector.
	     * @param alpha input/output double[] On entry, the value alpha. On exit, it is overwritten with the value beta.
	     * @param x input/output double[] of dimension (1 + (n-2)*abs(incx)) On entry, the vector x. On exit, it is
	     *            overwritten with the vector v.
	     * @param incx input int The increment between elements of x. incx > 0
	     * @param tau output double[] The value tau
	     */
	    private void dlarfp(final int n, final double[] alpha, final double[] x, final int incx, final double[] tau) {
	        int j;
	        int knt;
	        double beta;
	        double rsafmn;
	        double safmin;
	        double xnorm;

	        if (n <= 0) {
	            tau[0] = 0.0;

	            return;
	        }

	        xnorm = dnrm2(n - 1, x, incx);

	        if (xnorm == 0.0) {

	            // H = [+/-1, 0; I], sign chosen so that alpha[0] >= 0
	            if (alpha[0] >= 0.0) {
	                // When tau[0] == 0.0, the vector is special cased to be all zeros in the
	                // application routines. We do not need to clear it.
	                tau[0] = 0.0;
	            } // if (alpha[0] >= 0.0)
	            else {
	                // However, the application routines rely on explicit zero checks when
	                // tau[0] != 0.0, and we must clear x.
	                tau[0] = 2.0;
	                for (j = 1; j <= n - 1; j++) {
	                    x[ (j - 1) * incx] = 0.0;
	                }
	                alpha[0] = -alpha[0];
	            } // else
	        } // if (xnorm == 0.0)
	        else { // general case

	            if (alpha[0] >= 0.0) {
	                beta = Math.abs(dlapy2(alpha[0], xnorm));
	            } else {
	                beta = -Math.abs(dlapy2(alpha[0], xnorm));
	            }

	            safmin = dlamch('S') / dlamch('E');
	            knt = 0;

	            if (Math.abs(beta) < safmin) {

	                // xnorm, beta may be inaccurate; scale x and recompute them
	                rsafmn = 1.0 / safmin;

	                do {
	                    knt = knt + 1;
	                    dscal(n - 1, rsafmn, x, incx);
	                    beta = beta * rsafmn;
	                    alpha[0] = alpha[0] * rsafmn;
	                } while (Math.abs(beta) < safmin);

	                // New beta is at most 1, at least safmin
	                xnorm = dnrm2(n - 1, x, incx);

	                if (alpha[0] >= 0.0) {
	                    beta = Math.abs(dlapy2(alpha[0], xnorm));
	                } else {
	                    beta = -Math.abs(dlapy2(alpha[0], xnorm));
	                }
	            } // if (Math.abs(beta) < safmin)

	            alpha[0] = alpha[0] + beta;
	            if (beta < 0.0) {
	                beta = -beta;
	                tau[0] = -alpha[0] / beta;
	            } else {
	                alpha[0] = xnorm * (xnorm / alpha[0]);
	                tau[0] = alpha[0] / beta;
	                alpha[0] = -alpha[0];
	            }
	            dscal(n - 1, 1.0 / alpha[0], x, incx);

	            for (j = 1; j <= knt; j++) {
	                beta = beta * safmin;
	            }
	            alpha[0] = beta;
	        } // else general case

	        return;
	    } // dlarfp

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLARFT Original DLARFT created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlarft forms the triangular
	     * factor T of a real block reflector H of order n, which is defined as the product of k elementary reflectors. If
	     * direct = 'F', H = H[0] H[1] ... H[k-1] and T is upper triangular. If direct = 'B', H = H[k-1] ... H[1] H[0] and T
	     * is lower triangular. If storev = 'C', the vector which defines the elementary reflector H[i] is stored in the
	     * i-th column of the array V, and H = I - V * T * V' If storev = 'R', the vector which defines the elementary
	     * reflector H[i] is stored in the i-th row of the array V, and H = I - V' * T * V.
	     * 
	     * @param direct input char Specifies the order in which the elementary reflectors are multiplied to form the block
	     *            reflector: = 'F': H = H[0] H[1] ... H[k-1] (forward) = 'B': H = H[k-1] ... H[1] H[0] (Backward)
	     * @param storev input char Specifies how the vectors which define the elementary reflectors are stored (see also
	     *            Further Details): = 'C': columnwise = 'R': rowwise
	     * @param n input int The order of the block reflector H. n >= 0.
	     * @param k input int The order of the triangular factor T ( = the number of elementary reflectors). k >= 1.
	     * @param V (input/output) double[][] If storev = 'C', dimension = ldv by k. If storev = 'R', dimension = ldv by n.
	     *            See further details.
	     * @param ldv input int The leading dimension of the array V. If storev = 'C', ldv >= max(1,n). If storev = 'R', ldv
	     *            >= k.
	     * @param tau input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector H[i].
	     * @param T output double[][] of dimension ldt by k. The k by k triangular factor T of the block reflector. If
	     *            direct = 'F', T is upper triangular. If direct = 'B', T is lower triangular. The rest of the array is
	     *            not used.
	     * @param ldt input int The leading dimension of the array T. ldt >= k.
	     * 
	     *            <p>
	     *            Further Details: The shape of the matrix V and the storage of the vectors which define the H[i] is
	     *            best illustrated by the following example with n = 5 and k = 3. The elements equal to 1 are not
	     *            stored; the corresponding array elements are modified but restored on exit. The rest of the array is
	     *            not used. direct = 'F' and storev = 'C': V = ( 1 ) (v1 1 ) (v1 v2 1 ) (v1 v2 v3 ) (v1 v2 v3 ) direct =
	     *            'F' and storev = 'R': V = ( 1 v1 v1 v1 v1 ) ( 1 v2 v2 v2 ) ( 1 v3 v3 ) direct = 'B' and storev = 'C':
	     *            V = ( v1 v2 v3 ) ( v1 v2 v3 ) ( 1 v2 v3 ) ( 1 v3 ) ( 1 ) direct = 'B' and storev = 'R': V = ( v1 v1 1
	     *            ) ( v2 v2 v2 1 ) ( v3 v3 v3 v3 1 )
	     *            </p>
	     */
	    private void dlarft(final char direct, final char storev, final int n, final int k, final double[][] V,
	            final int ldv, final double[] tau, final double[][] T, final int ldt) {
	        int i;
	        int j;
	        double vii;
	        double[] vector1;
	        double[] vector2 = null;
	        double[][] array1;
	        int p;
	        int q;
	        int lastV;
	        int prevLastV;

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if ( (direct == 'F') || (direct == 'f')) {
	            prevLastV = n;
	            for (i = 1; i <= k; i++) {
	                prevLastV = Math.max(i, prevLastV);
	                if (tau[i - 1] == 0.0) {

	                    // H[i-1] = I
	                    for (j = 1; j <= i; j++) {
	                        T[j - 1][i - 1] = 0.0;
	                    }
	                } // if (tau[i-1] == 0.0)
	                else { // tau[i-1] != 0.0

	                    // general case
	                    vii = V[i - 1][i - 1];
	                    V[i - 1][i - 1] = 1.0;

	                    if ( (storev == 'C') || (storev == 'c')) {
	                        // Skip any trailing zeros
	                        for (lastV = n; lastV >= i + 1; lastV--) {
	                            if (V[lastV - 1][i - 1] != 0.0) {
	                                break;
	                            }
	                        }
	                        j = Math.min(lastV, prevLastV);

	                        // T(0:i-2,i-1) = -tau[i-1] * V(i-1:j-1,0:i-2)' * V(i-1:j-1,i-1)
	                        array1 = new double[j - i + 1][i - 1];

	                        for (p = 0; p < (j - i + 1); p++) {

	                            for (q = 0; q < (i - 1); q++) {
	                                array1[p][q] = V[p + i - 1][q];
	                            }
	                        }

	                        vector1 = new double[j - i + 1];

	                        for (p = 0; p < (j - i + 1); p++) {
	                            vector1[p] = V[p + i - 1][i - 1];
	                        }

	                        vector2 = new double[i - 1];

	                        for (p = 0; p < (i - 1); p++) {
	                            vector2[p] = T[p][i - 1];
	                        }

	                        dgemv('T', j - i + 1, i - 1, -tau[i - 1], array1, j - i + 1, vector1, 1, 0.0, vector2, 1);

	                        for (p = 0; p < (i - 1); p++) {
	                            T[p][i - 1] = vector2[p];
	                        }
	                    } // if ((storev == 'C') || (storev == 'c'))
	                    else { // ((storev == 'R') || (storev == 'r'))
	                        // Skip any trailing zeros.
	                        for (lastV = n; lastV >= i + 1; lastV--) {
	                            if (V[i - 1][lastV - 1] != 0.0) {
	                                break;
	                            }
	                        }
	                        j = Math.min(lastV, prevLastV);
	                        // T(0:i-2,i-1) = -tau[i-1] * V(0:i-2,i-1:j-1) * V(i-1,i-1:j-1)'
	                        array1 = new double[i - 1][j - i + 1];

	                        for (p = 0; p < (i - 1); p++) {

	                            for (q = 0; q < (j - i + 1); q++) {
	                                array1[p][q] = V[p][q + i - 1];
	                            }
	                        }

	                        vector1 = new double[j - i + 1];

	                        for (p = 0; p < (j - i + 1); p++) {
	                            vector1[p] = V[i - 1][p + i - 1];
	                        }

	                        vector2 = new double[i - 1];

	                        for (p = 0; p < (i - 1); p++) {
	                            vector2[p] = T[p][i - 1];
	                        }

	                        dgemv('N', i - 1, j - i + 1, -tau[i - 1], array1, Math.max(1,i - 1), vector1, 1, 0.0, vector2, 1);

	                        for (p = 0; p < (i - 1); p++) {
	                            T[p][i - 1] = vector2[p];
	                        }
	                    } // else ((storev == 'R') || (storev == 'r'))

	                    V[i - 1][i - 1] = vii;

	                    // T(0:i-2,i-1) = T(0:i-2,0:i-2) * T(0:i-2,i-1)
	                    dtrmv('U', 'N', 'N', i - 1, T, ldt, vector2, 1);

	                    for (p = 0; p < (i - 1); p++) {
	                        T[p][i - 1] = vector2[p];
	                    }

	                    T[i - 1][i - 1] = tau[i - 1];

	                    if (i > 1) {
	                        prevLastV = Math.max(prevLastV, lastV);
	                    } else {
	                        prevLastV = lastV;
	                    }
	                } // else tau[i-1] != 0.0
	            } // for (i = 1; i <= k; i++)
	        } // if ((direct == 'F') || (direct == 'f'))
	        else { // ((direct == 'B') || (direct == 'b'))
	            prevLastV = 1;
	            for (i = k; i >= 1; i--) {

	                if (tau[i - 1] == 0.0) {

	                    // H[i-1] = I
	                    for (j = i; j <= k; j++) {
	                        T[j - 1][i - 1] = 0.0;
	                    }
	                } // if (tau[i-1] == 0.0)
	                else { // tau[i-1] != 0.0

	                    // general case
	                    if (i < k) {

	                        if ( (storev == 'C') || (storev == 'c')) {
	                            vii = V[n - k + i - 1][i - 1];
	                            V[n - k + i - 1][i - 1] = 1.0;
	                            // Skip any leading zeros
	                            for (lastV = 1; lastV <= i - 1; lastV++) {
	                                if (V[lastV - 1][i - 1] != 0.0) {
	                                    break;
	                                }
	                            }
	                            j = Math.max(lastV, prevLastV);
	                            // T(i:k-1,i-1) = -tau[i-1] * V(j-1:n-k+i-1,i:k-1)' *
	                            // V(j-1:n-k+i-1,i-1)
	                            array1 = new double[n - k + i - j + 1][k - i];

	                            for (p = 0; p < (n - k + i - j + 1); p++) {

	                                for (q = 0; q < (k - i); q++) {
	                                    array1[p][q] = V[j - 1 + p][q + i];
	                                }
	                            }

	                            vector1 = new double[n - k + i - j + 1];

	                            for (p = 0; p < (n - k + i - j + 1); p++) {
	                                vector1[p] = V[j - 1 + p][i - 1];
	                            }

	                            vector2 = new double[k - i];

	                            for (p = 0; p < (k - i); p++) {
	                                vector2[p] = T[p + i][i - 1];
	                            }

	                            dgemv('T', n - k + i - j + 1, k - i, -tau[i - 1], array1, n - k + i - j + 1, vector1, 1,
	                                    0.0, vector2, 1);

	                            for (p = 0; p < (k - i); p++) {
	                                T[p + i][i - 1] = vector2[p];
	                            }

	                            V[n - k + i - 1][i - 1] = vii;
	                        } // if ((storev == 'C') || (storev == 'c'))
	                        else { // ((storev == 'R') || (storev == 'r'))
	                            vii = V[i - 1][n - k + i - 1];
	                            V[i - 1][n - k + i - 1] = 1.0;
	                            // Skip any leading zeros
	                            for (lastV = 1; lastV <= i - 1; lastV++) {
	                                if (V[i - 1][lastV - 1] != 0.0) {
	                                    break;
	                                }
	                            }
	                            j = Math.max(lastV, prevLastV);

	                            // T(i:k-1,i-1) = -tau[i-1] * V(i:k-1,j-1:n-k+i-1) *
	                            // V(i-1,j-1:n-k+i-1)'
	                            array1 = new double[k - i][n - k + i - j + 1];

	                            for (p = 0; p < (k - i); p++) {

	                                for (q = 0; q < (n - k + i - j + 1); q++) {
	                                    array1[p][q] = V[p + i][j - 1 + q];
	                                }
	                            }

	                            vector1 = new double[n - k + i - j + 1];

	                            for (p = 0; p < (n - k + i - j + 1); p++) {
	                                vector1[p] = V[i - 1][j - 1 + p];
	                            }

	                            vector2 = new double[k - i];

	                            for (p = 0; p < (k - i); p++) {
	                                vector2[p] = T[p + i][i - 1];
	                            }

	                            dgemv('N', k - i, n - k + i - j + 1, -tau[i - 1], array1, k - i, vector1, 1, 0.0, vector2,
	                                    1);

	                            for (p = 0; p < (k - i); p++) {
	                                T[p + i][i - 1] = vector2[p];
	                            }

	                            V[i - 1][n - k + i - 1] = vii;
	                        } // else ((storev == 'R') || (storev == 'r'))

	                        // T(i:k-1,i-1) = T(i:k-1,i:k-1) * T(i:k-1,i-1)
	                        array1 = new double[k - i][k - i];

	                        for (p = 0; p < (k - i); p++) {

	                            for (q = 0; q < (k - i); q++) {
	                                array1[p][q] = T[p + i][q + i];
	                            }
	                        }

	                        dtrmv('L', 'N', 'N', k - i, array1, k - i, vector2, 1);

	                        for (p = 0; p < (k - i); p++) {
	                            T[p + i][i - 1] = vector2[p];
	                        }

	                        if (i > 1) {
	                            prevLastV = Math.min(prevLastV, lastV);
	                        } else {
	                            prevLastV = lastV;
	                        }
	                    } // if (i < k)

	                    T[i - 1][i - 1] = tau[i - 1];
	                } // else tau[i-1] != 0.0
	            } // for (i = k; i >= 1; i--)
	        } // else ((direct == 'B') || (direct == 'b'))

	        return;
	    } // dlarft

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine DLARFY Original DLARFY created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlarfy applies an elementary reflector, or Householder
	     * matrix, H, to an n by n symmetric matrix C, from both the left and the right. H is represented in the form H = I
	     * - tau * v * v' where tau is a scalar and v is a vector. If tau is zero, then H is taken to be the unit vector
	     * 
	     * @param uplo (input) char Specifies whether the upper or lower triangular part of the matrix C is stored. = 'U':
	     *            Upper triangle = 'L': Lower triangle
	     * @param n (input) int The number of rows and columns of the matrix C. n >= 0.
	     * @param v (input) double[] of dimension (1 + (n-1)*abs(incv))
	     * @param incv (input) int The increment between succesive elements of v. incv must not be zero.
	     * @param tau (input) double
	     * @param C (input/output) double[][] of dimension (ldc, n) On entry, the matrix C. On exit, C is overwritten by H *
	     *            C * H'.
	     * @param ldc (input) int The leading dimension of the array C. ldc >= max(1,n).
	     * @param work (workspace) double[] of dimension (n)
	     */
	    private void dlarfy(final char uplo, final int n, final double[] v, final int incv, final double tau,
	            final double[][] C, final int ldc, final double[] work) {
	        double alpha;

	        if (tau == 0.0) {
	            return;
	        }

	        // Form w = C * v
	        dsymv(uplo, n, 1.0, C, ldc, v, incv, 0.0, work, 1);
	        alpha = -0.5 * tau * ddot(n, work, 1, v, incv);
	        daxpy(n, alpha, v, incv, work, 1);

	        // C = C - v * w' - w * v'
	        dsyr2(uplo, n, -tau, v, incv, work, 1, C, ldc);

	        return;
	    } // dlarfy

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine DLARND Original DLARND created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlarnd returns a random real number from a uniform or
	     * normal distribution. This routine calls the auxiliary routine dlaran to generate a random real number from a
	     * uniform (0,1) distribution. The Box-Muller method is used to transform numbers from a uniform to a normal
	     * distribution.
	     * 
	     * @param idist input int Specifies the distribution of the random numbers: = 1: uniform (0,1) = 2: uniform (-1,1) =
	     *            3: normal (0,1)
	     * @param iseed (input/output) int[] of dimension 4 On entry, the seed of the random number generator; the array
	     *            elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
	     * 
	     * @return DOCUMENT ME!
	     */
	    private double dlarnd(final int idist, final int[] iseed) {
	        double t1;
	        double t2;
	        double result = 0.0;

	        // Generate a real random number from a uniform (0,1) distribution
	        t1 = dlaran(iseed);

	        if (idist == 1) {

	            // uniform (0,1)
	            result = t1;
	        } else if (idist == 2) {

	            // Uniform (-1,1)
	            result = (2.0 * t1) - 1.0;
	        } else if (idist == 3) {

	            // Normal (0,1)
	            t2 = dlaran(iseed);
	            result = Math.sqrt( -2.0 * Math.log(t1)) * Math.cos(2.0 * Math.PI * t2);
	        }

	        return result;
	    } // dlarnd

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLARNV Original DLARNV created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlarnv returns a vector of n
	     * random real numbers from a uniform or normal distribution
	     * 
	     * @param idist input int Specifies the distribution of the random numbers: = 1: uniform (0,1) = 2: uniform (-1,1) =
	     *            3: normal (0,1)
	     * @param iseed input/output int[] of dimension 4. On entry, the seed of the random number generator; the array
	     *            elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated
	     * @param n input int The number of random numbers to be generated.
	     * @param x output double[] of dimension n. The random generated numbers.
	     * 
	     *            The routine calls the auxiliary routine dlaruv to generate random real numbers from a uniform (0,1)
	     *            distribution, in batches of up to 128 using vectorizable code. The Box-Muller method is used to
	     *            transform numbers from a uniform to a normal distribution.
	     */
	    private void dlarnv(final int idist, final int[] iseed, final int n, final double[] x) {
	        final int lv = 128;
	        int i;
	        int il;
	        int il2;
	        int iv;
	        final double[] u = new double[lv];

	        for (iv = 1; iv <= n; iv += lv / 2) {
	            il = Math.min(lv / 2, n - iv + 1);

	            if (idist == 3) {
	                il2 = 2 * il;
	            } else {
	                il2 = il;
	            }

	            // Call dlaruv to generate il2 numbers from a uniform (0,1)
	            // distribution (il2 <= lv)
	            dlaruv(iseed, il2, u);

	            if (idist == 1) {

	                // Copy generated numbers
	                for (i = 0; i < il; i++) {
	                    x[iv + i - 1] = u[i];
	                }
	            } // if (idist == 1)
	            else if (idist == 2) {

	                // Convert generated numbers to uniform (-1,1) distribution
	                for (i = 0; i < il; i++) {
	                    x[iv + i - 1] = (2.0 * u[i]) - 1.0;
	                }
	            } // else if (idist == 2)
	            else if (idist == 3) {

	                // Convert generated numbers to normal (0,1) distribution
	                for (i = 1; i <= il; i++) {
	                    x[iv + i - 2] = Math.sqrt( -2.0 * Math.log(u[ (2 * i) - 2]))
	                            * Math.cos(2.0 * Math.PI * u[ (2 * i) - 1]);
	                }
	            } // else if (idist == 3)

	        } // for (iv = 1; iv <= n; iv += lv/2)
	        return;
	    } // dlarnv

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine DLAROT Original DLAROT created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlarot applies a (Givens) rotation to two adjacent
	     * rows or columns, where one element of the first and/or last column/row may be a separate variable. This is
	     * specifically intended for use on matrices stored in some format other than GE, so that elements of the matrix may
	     * be used or modified for which no array element is provided.
	     * 
	     * <p>
	     * One example is a symmetric matrix in SB format (bandwidth=4), for which uplo = 'L': Two adjacent rows will have
	     * the format: 
	     * row j: * * * * * . . . . 
	     * row j+1: * * * * * . . . . '*' indicates elements for which storage is
	     * provided, '.' indicates elements for which no storage is provided, but are not necessrily zero; their values are
	     * determined by symmetry. ' ' indicates elements which are necessarily zero, and have no storage provided.
	     * </p>
	     * 
	     * <p>
	     * Those columns which have two '*'s can be handled by drot. Those columns which have no '*'s can be ignored, since
	     * as long as the Givens rotations are carefully applied to preserve symmetry, their values are determined. Those
	     * columns which have one '*' have to be handled separately, by using separate variables "p" and "q": 
	     * row j: * * * * * p . . . 
	     * row j+1: q * * * *  . . . .
	     * </p>
	     * 
	     * <p>
	     * The element p would have to be set correctly, then that column is rotated, setting p to its new value. The next
	     * call to dlarot would rotate columns j and j+1, using p, and restore symmetry. The element q would start out being
	     * zero, and be made non-zero by the rotation. Later, rotations would presumably be chosen to zero q out.
	     * </p>
	     * 
	     * <p>
	     * Typical Calling Sequences: rotating the i-th and (i+1)-st rows.
	     * </p>
	     * 
	     * <p>
	     * General dense matrix: dlarot(true, false, false, n, c, s, A[i-1][0], lda, dummy, dummy);
	     * </p>
	     * 
	     * <p>
	     * General banded matrix in GB format: j = Math.max(1, i-kl); nl = Math.min(n, i+ku+1) + 1 - j; dlarot(true, (i-kl)
	     * >= 1, (i+ku) < n, nl, c,s,A[ku+i-j][j-1], lda - 1, xleft, xright); Note that i+1-j is just min(i,kl+1)
	     * </p>
	     * 
	     * <p>
	     * Symmetric banded matrix in SY format, bandwidth k, lower triangle only: j = Math.max(1,i-k); nl = Math.min(k+1,i)
	     * + 1; dlarot(true, (i-k) >= 1, true, nl, c, s, A[i-1][j-1], lda, xleft, xright);
	     * </p>
	     * 
	     * <p>
	     * Same, but upper triangle only: nl = Math.min(k+1,n-i) + 1; dlarot(true, true, (i+k) < n, nl, c, s, A[i-1][i-1],
	     * lda, xleft, xright);
	     * </p>
	     * 
	     * <p>
	     * Symmetric banded matrix in SB format, bandwidth k, lower triangle only: same as for sy, except: A[i-j][j-1], lda
	     * - 1, xleft, xright); Note that i+1-j is just min(i,k+1)
	     * </p>
	     * 
	     * <p>
	     * Same, but upper triangle only: A[k][i-1], lda-1, xleft, xright);
	     * </p>
	     * 
	     * <p>
	     * Rotating columns is just the transpose of rotating rows, except for GB and SB: (rotating columns i and i+1)
	     * </p>
	     * 
	     * <p>
	     * GB: j = Math.max(1,i-ku); nl = Math.min(n, i+kl+1) + 1 - j; dlarot(true, i-ku >= 1, i+kl < n, nl, c, s,
	     * A[ku+j-i][i-1], lda - 1, xtop, xbottm); Note that ku+j+1-i is just max(1,ku+2-i)
	     * </p>
	     * 
	     * <p>
	     * SB: (upper triangle) ............. A[k+j-i][i-1], lda-1, xtop, xbottm);
	     * </p>
	     * 
	     * <p>
	     * SB: (lower triangle) ................... A[0][i-1], lda-1, xtop, xbottm);
	     * </p>
	     * 
	     * @param lrows input boolean If true, then dlarot will rotate two rows. If false, then it will rotate two columns.
	     * @param lleft input boolean If true, then xleft will be used instead of the corresponding element of A for the
	     *            first element in the second row (if lrows = false) or column (if lrows = true) If false, then the
	     *            corresponding element of A will be used.
	     * @param lright input boolean If true, then xright will be used instead of the corresponding element of A for the
	     *            last element in the first row (if lrows = false) or column (if lrows = true). If false, then the
	     *            corresponding element of A will be used.
	     * @param nl input int The length of the rows (if lrows = true) or columns (if lrows = false) to be rotated. If
	     *            xleft and/or xright are used, the columns/rows they are in should be included in nl, e.g., if lleft =
	     *            lright = true, then nl must be at least 2. The number of rows/columns to be rotated exclusive of those
	     *            involving xleft and/or xright may not be negative, i.e., nl minus how many of lleft and lright are
	     *            true must be at least zero; if not, an error message will be output.
	     * @param c input double
	     * @param s input double c and s specify the Givens rotation to be applied. If lrows is true, then the matrix
	     *          ( c s )
	     *          (-s c ) 
	     *            is applied from the left; if false, then the transpose thereof is applied from the right.
	     *            For a Givens rotation, c**2 + s**2 should be 1, but this is not checked.
	     * @param A input/output double[] The array containing the rows/columns to be rotated. The first element of A should
	     *            be the upper left element to be rotated.
	     * @param lda input int The "effective" leading dimension of A. If A contains a matrix stored in GE or SY format,
	     *            then this is just the leading dimension of A as dimensioned in the calling routine. If A contains a
	     *            matrix stored in band (GB or SB) format, then this should be *one less* than the leading dimension
	     *            used in the calling routine. Thus, if A were dimensioned A(lda,*) in dlarot, then A[0][j-1] would be
	     *            the j-th element in the first of the two rows to be rotated, and A[1][j-1] would be the j-th in the
	     *            second, regardless of how the array may be stored in the calling routine. [A cannot, however, actually
	     *            be dimensioned thus, since for band format, the row number may exceed lda, which is not legal code.]
	     *            If lrows = true, then lda must be at least 1, otherwise it must be at least nl minus the number of
	     *            true values in xleft and xright.
	     * @param xleft input/output double[] If lleft is true, then xleft will be used and modified instead of A[1][0] (if
	     *            lrows = true) or A[0][1] (if lrows = false).
	     * @param xright input/output double[] If lright is true, then xright will be used and modified instead of
	     *            A[0][nl-1] (if lrows = true) or A[nl-1][0] (if lrows = false).
	     */
	    private void dlarot(final boolean lrows, final boolean lleft, final boolean lright, final int nl, final double c,
	            final double s, final double[] A, final int lda, final double[] xleft, final double[] xright) {
	        int iinc;
	        int inext;
	        int ix;
	        int iy;
	        int iyt = 0;
	        int nt;
	        final double[] xt = new double[2];
	        final double[] yt = new double[2];
	        double[] dx;
	        double[] dy;
	        int i;
	        int index;

	        // Set up indices, arrays for ends
	        if (lrows) {
	            iinc = lda;
	            inext = 1;
	        } else {
	            iinc = 1;
	            inext = lda;
	        }

	        if (lleft) {
	            nt = 1;
	            ix = 1 + iinc;
	            iy = 2 + lda;
	            xt[0] = A[0];
	            yt[0] = xleft[0];
	        } else {
	            nt = 0;
	            ix = 1;
	            iy = 1 + inext;
	        }

	        if (lright) {
	            iyt = 1 + inext + ( (nl - 1) * iinc);
	            nt = nt + 1;
	            xt[nt - 1] = xright[0];
	            yt[nt - 1] = A[iyt - 1];
	        }

	        // Check for errors
	        if (nl < nt) {
	            System.err.println("dlarot has error 4");

	            return;
	        }

	        if ( (lda <= 0) || ( ( !lrows) && (lda < (nl - nt)))) {
	            System.err.println("dlarot had error 8");

	            return;
	        }

	        // Rotate
	        dx = new double[nl - nt];
	        dy = new double[nl - nt];
	        index = 0;

	        for (i = 0; i < (nl - nt); i++) {
	            dx[i] = A[ix + index - 1];
	            dy[i] = A[iy + index - 1];
	            index += iinc;
	        }

	        drot(nl - nt, dx, 1, dy, 1, c, s);
	        index = 0;

	        for (i = 0; i < (nl - nt); i++) {
	            A[ix + index - 1] = dx[i];
	            A[iy + index - 1] = dy[i];
	            index += iinc;
	        }

	        drot(nt, xt, 1, yt, 1, c, s);

	        // Stuff values back into xleft, xright, etc.
	        if (lleft) {
	            A[0] = xt[0];
	            xleft[0] = yt[0];
	        }

	        if (lright) {
	            xright[0] = xt[nt - 1];
	            A[iyt - 1] = yt[nt - 1];
	        }

	        return;
	    } // dlarot

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLARTG Original DLARTG created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlartg generates a plane
	     * rotation so that [ cs sn ] . [ f ] = [ r ] where cs*cs + sn*sn = 1. [ -sn cs ] [ g ] [ 0 ] If g = 0, then cs = 1
	     * and sn = 0. If f = 0 and g != 0, then cs = 0 and sn = 1 without doing any floating point operations (saves work
	     * in dbdsqr when there are zeros on the . If f exceeds g in magnitude, then cs will be positive.
	     * 
	     * @param f input double The first component of the vector to be rotated.
	     * @param g input double The second component of the vector to be rotated.
	     * @param cs output double[] The cosine of the rotation.
	     * @param sn output double[] The sine of the rotation.
	     * @param r output double[] The nonzero component of the rotated vector.
	     */
	    private void dlartg(final double f, final double g, final double[] cs, final double[] sn, final double[] r) {
	        int count;
	        int i;
	        double eps;
	        double f1;
	        double g1;
	        double scale;

	        if (first_dlartg) {
	            first_dlartg = false;
	            safmin = dlamch('S');
	            eps = dlamch('E');
	            safmn2 = Math.pow(dlamch('B'), (int) (Math.log(safmin / eps) / Math.log(dlamch('B')) / 2.0));
	            safmx2 = 1.0 / safmn2;
	        } // if (first_dlartg)

	        if (g == 0.0) {
	            cs[0] = 1.0;
	            sn[0] = 0.0;
	            r[0] = f;
	        } else if (f == 0.0) {
	            cs[0] = 0.0;
	            sn[0] = 1.0;
	            r[0] = g;
	        } else {
	            f1 = f;
	            g1 = g;
	            scale = Math.max(Math.abs(f1), Math.abs(g1));

	            if (scale >= safmx2) {
	                count = 0;

	                do {
	                    count = count + 1;
	                    f1 = f1 * safmn2;
	                    g1 = g1 * safmn2;
	                    scale = Math.max(Math.abs(f1), Math.abs(g1));
	                } while (scale >= safmx2);

	                r[0] = Math.sqrt( (f1 * f1) + (g1 * g1));
	                cs[0] = f1 / r[0];
	                sn[0] = g1 / r[0];

	                for (i = 1; i <= count; i++) {
	                    r[0] = r[0] * safmx2;
	                }
	            } // if (scale >= safmx2)
	            else if (scale <= safmn2) {
	                count = 0;

	                do {
	                    count = count + 1;
	                    f1 = f1 * safmx2;
	                    g1 = g1 * safmx2;
	                    scale = Math.max(Math.abs(f1), Math.abs(g1));
	                } while (scale <= safmn2);

	                r[0] = Math.sqrt( (f1 * f1) + (g1 * g1));
	                cs[0] = f1 / r[0];
	                sn[0] = g1 / r[0];

	                for (i = 1; i <= count; i++) {
	                    r[0] = r[0] * safmn2;
	                }
	            } // else if (scale <= safmn2)
	            else {
	                r[0] = Math.sqrt( (f1 * f1) + (g1 * g1));
	                cs[0] = f1 / r[0];
	                sn[0] = g1 / r[0];
	            }

	            if ( (Math.abs(f) > Math.abs(g)) && (cs[0] < 0.0)) {
	                cs[0] = -cs[0];
	                sn[0] = -sn[0];
	                r[0] = -r[0];
	            }
	        }

	        return;
	    } // dlartg

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLARUV Original DLARUV created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlaruv returns a vector of n
	     * random real numbers from a uniform (0,1) distribution (n <= 128). This is an auxiliary routine called by dlarnv.
	     * 
	     * @param iseed input/output int[] of dimension 4 On entry, the seed of the random number generator; the array
	     *            elements must be between 0 and 4095, and iseed[3] must be odd. On exit, the seed is updated.
	     * @param n input int The number of random numbers to be generated. n <= 128.
	     * @param x output double[] of dimension n. The generated random numbers.
	     * 
	     *            This routine uses a multiplicative congruential method with modulus 2**48 and multiplier
	     *            33952834046453 (see G.S. Fishman, "Multiplicative congruential random number generators with modulus
	     *            2**b: an exhaustive analysis for b = 32 and a partial analysis for b = 48", Math. Comp. 189, pp.
	     *            331-344, 1990).
	     * 
	     *            48-bit integers are stored in 4 integer array elements with 12 bits per element. Hence the routine is
	     *            portable across machines with integers of 32 bits or more.
	     */
	    private void dlaruv(final int[] iseed, final int n, final double[] x) {
	        final int lv = 128;
	        final int ipw2 = 4096;
	        final double r = 1.0 / ipw2;
	        int i;
	        int i1;
	        int i2;
	        int i3;
	        int i4;
	        int it1 = 0;
	        int it2 = 0;
	        int it3 = 0;
	        int it4 = 0;
	        final int[][] mm = new int[lv][4];

	        mm[0][0] = 494;
	        mm[0][1] = 322;
	        mm[0][2] = 2508;
	        mm[0][3] = 2549;
	        mm[1][0] = 2637;
	        mm[1][1] = 789;
	        mm[1][2] = 3754;
	        mm[1][3] = 1145;
	        mm[2][0] = 255;
	        mm[2][1] = 1440;
	        mm[2][2] = 1766;
	        mm[2][3] = 2253;
	        mm[3][0] = 2008;
	        mm[3][1] = 752;
	        mm[3][2] = 3572;
	        mm[3][3] = 305;
	        mm[4][0] = 1253;
	        mm[4][1] = 2859;
	        mm[4][2] = 2893;
	        mm[4][3] = 3301;
	        mm[5][0] = 3344;
	        mm[5][1] = 123;
	        mm[5][2] = 307;
	        mm[5][3] = 1065;
	        mm[6][0] = 4084;
	        mm[6][1] = 1848;
	        mm[6][2] = 1297;
	        mm[6][3] = 3133;
	        mm[7][0] = 1739;
	        mm[7][1] = 643;
	        mm[7][2] = 3966;
	        mm[7][3] = 2913;
	        mm[8][0] = 3143;
	        mm[8][1] = 2405;
	        mm[8][2] = 758;
	        mm[8][3] = 3285;
	        mm[9][0] = 3468;
	        mm[9][1] = 2638;
	        mm[9][2] = 2598;
	        mm[9][3] = 1241;
	        mm[10][0] = 688;
	        mm[10][1] = 2344;
	        mm[10][2] = 3406;
	        mm[10][3] = 1197;
	        mm[11][0] = 1657;
	        mm[11][1] = 46;
	        mm[11][2] = 2922;
	        mm[11][3] = 3729;
	        mm[12][0] = 1238;
	        mm[12][1] = 3814;
	        mm[12][2] = 1038;
	        mm[12][3] = 2501;
	        mm[13][0] = 3166;
	        mm[13][1] = 913;
	        mm[13][2] = 2934;
	        mm[13][3] = 1673;
	        mm[14][0] = 1292;
	        mm[14][1] = 3649;
	        mm[14][2] = 2091;
	        mm[14][3] = 541;
	        mm[15][0] = 3422;
	        mm[15][1] = 339;
	        mm[15][2] = 2451;
	        mm[15][3] = 2753;
	        mm[16][0] = 1270;
	        mm[16][1] = 3808;
	        mm[16][2] = 1580;
	        mm[16][3] = 949;
	        mm[17][0] = 2016;
	        mm[17][1] = 822;
	        mm[17][2] = 1958;
	        mm[17][3] = 2361;
	        mm[18][0] = 154;
	        mm[18][1] = 2832;
	        mm[18][2] = 2055;
	        mm[18][3] = 1165;
	        mm[19][0] = 2862;
	        mm[19][1] = 3078;
	        mm[19][2] = 1507;
	        mm[19][3] = 4081;
	        mm[20][0] = 697;
	        mm[20][1] = 3633;
	        mm[20][2] = 1078;
	        mm[20][3] = 2725;
	        mm[21][0] = 1706;
	        mm[21][1] = 2970;
	        mm[21][2] = 3273;
	        mm[21][3] = 3305;
	        mm[22][0] = 491;
	        mm[22][1] = 637;
	        mm[22][2] = 17;
	        mm[22][3] = 3069;
	        mm[23][0] = 931;
	        mm[23][1] = 2249;
	        mm[23][2] = 854;
	        mm[23][3] = 3617;
	        mm[24][0] = 1444;
	        mm[24][1] = 2081;
	        mm[24][2] = 2916;
	        mm[24][3] = 3733;
	        mm[25][0] = 444;
	        mm[25][1] = 4019;
	        mm[25][2] = 3971;
	        mm[25][3] = 409;
	        mm[26][0] = 3577;
	        mm[26][1] = 1478;
	        mm[26][2] = 2889;
	        mm[26][3] = 2157;
	        mm[27][0] = 3944;
	        mm[27][1] = 242;
	        mm[27][2] = 3831;
	        mm[27][3] = 1361;
	        mm[28][0] = 2184;
	        mm[28][1] = 481;
	        mm[28][2] = 2621;
	        mm[28][3] = 3973;
	        mm[29][0] = 1661;
	        mm[29][1] = 2075;
	        mm[29][2] = 1541;
	        mm[29][3] = 1865;
	        mm[30][0] = 3482;
	        mm[30][1] = 4058;
	        mm[30][2] = 893;
	        mm[30][3] = 2525;
	        mm[31][0] = 657;
	        mm[31][1] = 622;
	        mm[31][2] = 736;
	        mm[31][3] = 1409;
	        mm[32][0] = 3023;
	        mm[32][1] = 3376;
	        mm[32][2] = 3992;
	        mm[32][3] = 3445;
	        mm[33][0] = 3618;
	        mm[33][1] = 812;
	        mm[33][2] = 787;
	        mm[33][3] = 3577;
	        mm[34][0] = 1267;
	        mm[34][1] = 234;
	        mm[34][2] = 2125;
	        mm[34][3] = 77;
	        mm[35][0] = 1828;
	        mm[35][1] = 641;
	        mm[35][2] = 2364;
	        mm[35][3] = 3761;
	        mm[36][0] = 164;
	        mm[36][1] = 4005;
	        mm[36][2] = 2460;
	        mm[36][3] = 2149;
	        mm[37][0] = 3798;
	        mm[37][1] = 1122;
	        mm[37][2] = 257;
	        mm[37][3] = 1449;
	        mm[38][0] = 3087;
	        mm[38][1] = 3135;
	        mm[38][2] = 1574;
	        mm[38][3] = 3005;
	        mm[39][0] = 2400;
	        mm[39][1] = 2640;
	        mm[39][2] = 3912;
	        mm[39][3] = 225;
	        mm[40][0] = 2870;
	        mm[40][1] = 2302;
	        mm[40][2] = 1216;
	        mm[40][3] = 85;
	        mm[41][0] = 3876;
	        mm[41][1] = 40;
	        mm[41][2] = 3248;
	        mm[41][3] = 3673;
	        mm[42][0] = 1905;
	        mm[42][1] = 1832;
	        mm[42][2] = 3401;
	        mm[42][3] = 3117;
	        mm[43][0] = 1593;
	        mm[43][1] = 2247;
	        mm[43][2] = 2124;
	        mm[43][3] = 3089;
	        mm[44][0] = 1797;
	        mm[44][1] = 2034;
	        mm[44][2] = 2762;
	        mm[44][3] = 1349;
	        mm[45][0] = 1234;
	        mm[45][1] = 2637;
	        mm[45][2] = 149;
	        mm[45][3] = 2057;
	        mm[46][0] = 3460;
	        mm[46][1] = 1287;
	        mm[46][2] = 2245;
	        mm[46][3] = 413;
	        mm[47][0] = 328;
	        mm[47][1] = 1691;
	        mm[47][2] = 166;
	        mm[47][3] = 65;
	        mm[48][0] = 2861;
	        mm[48][1] = 496;
	        mm[48][2] = 466;
	        mm[48][3] = 1845;
	        mm[49][0] = 1950;
	        mm[49][1] = 1597;
	        mm[49][2] = 4018;
	        mm[49][3] = 697;
	        mm[50][0] = 617;
	        mm[50][1] = 2394;
	        mm[50][2] = 1399;
	        mm[50][3] = 3085;
	        mm[51][0] = 2070;
	        mm[51][1] = 2584;
	        mm[51][2] = 190;
	        mm[51][3] = 3441;
	        mm[52][0] = 3331;
	        mm[52][1] = 1843;
	        mm[52][2] = 2879;
	        mm[52][3] = 1573;
	        mm[53][0] = 769;
	        mm[53][1] = 336;
	        mm[53][2] = 153;
	        mm[53][3] = 3689;
	        mm[54][0] = 1558;
	        mm[54][1] = 1472;
	        mm[54][2] = 2320;
	        mm[54][3] = 2941;
	        mm[55][0] = 2412;
	        mm[55][1] = 2407;
	        mm[55][2] = 18;
	        mm[55][3] = 929;
	        mm[56][0] = 2800;
	        mm[56][1] = 433;
	        mm[56][2] = 712;
	        mm[56][3] = 533;
	        mm[57][0] = 189;
	        mm[57][1] = 2096;
	        mm[57][2] = 2159;
	        mm[57][3] = 2841;
	        mm[58][0] = 287;
	        mm[58][1] = 1761;
	        mm[58][2] = 2318;
	        mm[58][3] = 4077;
	        mm[59][0] = 2045;
	        mm[59][1] = 2810;
	        mm[59][2] = 2091;
	        mm[59][3] = 721;
	        mm[60][0] = 1227;
	        mm[60][1] = 566;
	        mm[60][2] = 3443;
	        mm[60][3] = 2821;
	        mm[61][0] = 2838;
	        mm[61][1] = 442;
	        mm[61][2] = 1510;
	        mm[61][3] = 2249;
	        mm[62][0] = 209;
	        mm[62][1] = 41;
	        mm[62][2] = 449;
	        mm[62][3] = 2397;
	        mm[63][0] = 2770;
	        mm[63][1] = 1238;
	        mm[63][2] = 1956;
	        mm[63][3] = 2817;
	        mm[64][0] = 3654;
	        mm[64][1] = 1086;
	        mm[64][2] = 2201;
	        mm[64][3] = 245;
	        mm[65][0] = 3993;
	        mm[65][1] = 603;
	        mm[65][2] = 3137;
	        mm[65][3] = 1913;
	        mm[66][0] = 192;
	        mm[66][1] = 840;
	        mm[66][2] = 3399;
	        mm[66][3] = 1997;
	        mm[67][0] = 2253;
	        mm[67][1] = 3168;
	        mm[67][2] = 1321;
	        mm[67][3] = 3121;
	        mm[68][0] = 3491;
	        mm[68][1] = 1499;
	        mm[68][2] = 2271;
	        mm[68][3] = 997;
	        mm[69][0] = 2889;
	        mm[69][1] = 1084;
	        mm[69][2] = 3667;
	        mm[69][3] = 1833;
	        mm[70][0] = 2857;
	        mm[70][1] = 3438;
	        mm[70][2] = 2703;
	        mm[70][3] = 2877;
	        mm[71][0] = 2094;
	        mm[71][1] = 2408;
	        mm[71][2] = 629;
	        mm[71][3] = 1633;
	        mm[72][0] = 1818;
	        mm[72][1] = 1589;
	        mm[72][2] = 2365;
	        mm[72][3] = 981;
	        mm[73][0] = 688;
	        mm[73][1] = 2391;
	        mm[73][2] = 2431;
	        mm[73][3] = 2009;
	        mm[74][0] = 1407;
	        mm[74][1] = 288;
	        mm[74][2] = 1113;
	        mm[74][3] = 941;
	        mm[75][0] = 634;
	        mm[75][1] = 26;
	        mm[75][2] = 3922;
	        mm[75][3] = 2449;
	        mm[76][0] = 3231;
	        mm[76][1] = 512;
	        mm[76][2] = 2554;
	        mm[76][3] = 197;
	        mm[77][0] = 815;
	        mm[77][1] = 1456;
	        mm[77][2] = 184;
	        mm[77][3] = 2441;
	        mm[78][0] = 3524;
	        mm[78][1] = 171;
	        mm[78][2] = 2099;
	        mm[78][3] = 285;
	        mm[79][0] = 1914;
	        mm[79][1] = 1677;
	        mm[79][2] = 3228;
	        mm[79][3] = 1473;
	        mm[80][0] = 516;
	        mm[80][1] = 2657;
	        mm[80][2] = 4012;
	        mm[80][3] = 2741;
	        mm[81][0] = 164;
	        mm[81][1] = 2270;
	        mm[81][2] = 1921;
	        mm[81][3] = 3129;
	        mm[82][0] = 303;
	        mm[82][1] = 2587;
	        mm[82][2] = 3452;
	        mm[82][3] = 909;
	        mm[83][0] = 2144;
	        mm[83][1] = 2961;
	        mm[83][2] = 3901;
	        mm[83][3] = 2801;
	        mm[84][0] = 3480;
	        mm[84][1] = 1970;
	        mm[84][2] = 572;
	        mm[84][3] = 421;
	        mm[85][0] = 119;
	        mm[85][1] = 1817;
	        mm[85][2] = 3309;
	        mm[85][3] = 4073;
	        mm[86][0] = 3357;
	        mm[86][1] = 676;
	        mm[86][2] = 3171;
	        mm[86][3] = 2813;
	        mm[87][0] = 837;
	        mm[87][1] = 1410;
	        mm[87][2] = 817;
	        mm[87][3] = 2337;
	        mm[88][0] = 2826;
	        mm[88][1] = 3723;
	        mm[88][2] = 3039;
	        mm[88][3] = 1429;
	        mm[89][0] = 2332;
	        mm[89][1] = 2803;
	        mm[89][2] = 1696;
	        mm[89][3] = 1177;
	        mm[90][0] = 2089;
	        mm[90][1] = 3185;
	        mm[90][2] = 1256;
	        mm[90][3] = 1901;
	        mm[91][0] = 3780;
	        mm[91][1] = 184;
	        mm[91][2] = 3715;
	        mm[91][3] = 81;
	        mm[92][0] = 1700;
	        mm[92][1] = 663;
	        mm[92][2] = 2077;
	        mm[92][3] = 1669;
	        mm[93][0] = 3712;
	        mm[93][1] = 499;
	        mm[93][2] = 3019;
	        mm[93][3] = 2633;
	        mm[94][0] = 150;
	        mm[94][1] = 3784;
	        mm[94][2] = 1497;
	        mm[94][3] = 2269;
	        mm[95][0] = 2000;
	        mm[95][1] = 1631;
	        mm[95][2] = 1101;
	        mm[95][3] = 129;
	        mm[96][0] = 3375;
	        mm[96][1] = 1925;
	        mm[96][2] = 717;
	        mm[96][3] = 1141;
	        mm[97][0] = 1621;
	        mm[97][1] = 3912;
	        mm[97][2] = 51;
	        mm[97][3] = 249;
	        mm[98][0] = 3090;
	        mm[98][1] = 1398;
	        mm[98][2] = 981;
	        mm[98][3] = 3917;
	        mm[99][0] = 3765;
	        mm[99][1] = 1349;
	        mm[99][2] = 1978;
	        mm[99][3] = 2481;
	        mm[100][0] = 1149;
	        mm[100][1] = 1441;
	        mm[100][2] = 1813;
	        mm[100][3] = 3941;
	        mm[101][0] = 3146;
	        mm[101][1] = 2224;
	        mm[101][2] = 3881;
	        mm[101][3] = 2217;
	        mm[102][0] = 33;
	        mm[102][1] = 2411;
	        mm[102][2] = 76;
	        mm[102][3] = 2749;
	        mm[103][0] = 3082;
	        mm[103][1] = 1907;
	        mm[103][2] = 3846;
	        mm[103][3] = 3041;
	        mm[104][0] = 2741;
	        mm[104][1] = 3192;
	        mm[104][2] = 3694;
	        mm[104][3] = 1877;
	        mm[105][0] = 359;
	        mm[105][1] = 2786;
	        mm[105][2] = 1682;
	        mm[105][3] = 345;
	        mm[106][0] = 3316;
	        mm[106][1] = 382;
	        mm[106][2] = 124;
	        mm[106][3] = 2861;
	        mm[107][0] = 1749;
	        mm[107][1] = 37;
	        mm[107][2] = 1660;
	        mm[107][3] = 1809;
	        mm[108][0] = 185;
	        mm[108][1] = 759;
	        mm[108][2] = 3997;
	        mm[108][3] = 3141;
	        mm[109][0] = 2784;
	        mm[109][1] = 2948;
	        mm[109][2] = 479;
	        mm[109][3] = 2825;
	        mm[110][0] = 2202;
	        mm[110][1] = 1862;
	        mm[110][2] = 1141;
	        mm[110][3] = 157;
	        mm[111][0] = 2199;
	        mm[111][1] = 3802;
	        mm[111][2] = 886;
	        mm[111][3] = 2881;
	        mm[112][0] = 1364;
	        mm[112][1] = 2423;
	        mm[112][2] = 3514;
	        mm[112][3] = 3637;
	        mm[113][0] = 1244;
	        mm[113][1] = 2051;
	        mm[113][2] = 1301;
	        mm[113][3] = 1465;
	        mm[114][0] = 2020;
	        mm[114][1] = 2295;
	        mm[114][2] = 3604;
	        mm[114][3] = 2829;
	        mm[115][0] = 3160;
	        mm[115][1] = 1332;
	        mm[115][2] = 1888;
	        mm[115][3] = 2161;
	        mm[116][0] = 2785;
	        mm[116][1] = 1832;
	        mm[116][2] = 1836;
	        mm[116][3] = 3365;
	        mm[117][0] = 2772;
	        mm[117][1] = 2405;
	        mm[117][2] = 1990;
	        mm[117][3] = 361;
	        mm[118][0] = 1217;
	        mm[118][1] = 3638;
	        mm[118][2] = 2058;
	        mm[118][3] = 2685;
	        mm[119][0] = 1822;
	        mm[119][1] = 3661;
	        mm[119][2] = 692;
	        mm[119][3] = 3745;
	        mm[120][0] = 1245;
	        mm[120][1] = 327;
	        mm[120][2] = 1194;
	        mm[120][3] = 2325;
	        mm[121][0] = 2252;
	        mm[121][1] = 3660;
	        mm[121][2] = 20;
	        mm[121][3] = 3609;
	        mm[122][0] = 3904;
	        mm[122][1] = 716;
	        mm[122][2] = 3285;
	        mm[122][3] = 3821;
	        mm[123][0] = 2774;
	        mm[123][1] = 1842;
	        mm[123][2] = 2046;
	        mm[123][3] = 3537;
	        mm[124][0] = 997;
	        mm[124][1] = 3987;
	        mm[124][2] = 2107;
	        mm[124][3] = 517;
	        mm[125][0] = 2573;
	        mm[125][1] = 1368;
	        mm[125][2] = 3508;
	        mm[125][3] = 3017;
	        mm[126][0] = 1148;
	        mm[126][1] = 1848;
	        mm[126][2] = 3525;
	        mm[126][3] = 2141;
	        mm[127][0] = 545;
	        mm[127][1] = 2366;
	        mm[127][2] = 3801;
	        mm[127][3] = 1537;

	        i1 = iseed[0];
	        i2 = iseed[1];
	        i3 = iseed[2];
	        i4 = iseed[3];

	        for (i = 0; i < Math.min(n, lv); i++) {
	            // Multiply the seed by the (i+1)-th power of the multiplier modulo
	            // 2**48
	            while (true) {
	                it4 = i4 * mm[i][3];
	                it3 = it4 / ipw2;
	                it4 = it4 - (ipw2 * it3);
	                it3 = it3 + (i3 * mm[i][3]) + (i4 * mm[i][2]);
	                it2 = it3 / ipw2;
	                it3 = it3 - (ipw2 * it2);
	                it2 = it2 + (i2 * mm[i][3]) + (i3 * mm[i][2]) + (i4 * mm[i][1]);
	                it1 = it2 / ipw2;
	                it2 = it2 - (ipw2 * it1);
	                it1 = it1 + (i1 * mm[i][3]) + (i2 * mm[i][2]) + (i3 * mm[i][1]) + (i4 * mm[i][0]);
	                it1 = it1 % ipw2;

	                // Convert 48-bit integer to a real number in the interval (0,1)

	                x[i] = r * (it1 + (r * (it2 + (r * (it3 + (r * it4))))));
	                if (x[i] != 1.0) {
	                    break;
	                } // if (x[i] != 1.0)
	                // x[i] == 1.0
	                // If a real number has n bits of precision, and the first n bits of the 48-bit integer
	                // happen all to be 1 (which will occur about once every 2**n calls), then x[i] will be
	                // rounded to exactly 1.0
	                // Since x[i] is not supposed to return exactly 0.0 or 1.0, the statistically correct
	                // thing to do in this situation is simply to iterate again.
	                // N.B. The case x[i] = 0.0 should not be possible.
	                i1 = i1 + 2;
	                i2 = i2 + 2;
	                i3 = i3 + 2;
	                i4 = i4 + 2;
	            } // while(true)
	        } // for (i = 0; i < Math.min(n,lv); i++)

	        // Return final value of seed
	        iseed[0] = it1;
	        iseed[1] = it2;
	        iseed[2] = it3;
	        iseed[3] = it4;

	        return;
	    } // dlaruv

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLASCL Original DLASCL created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlascl multiplies the m by n
	     * real matrix A by the real scalar cto/cfrom. This is done without over/underflow as long as the final result
	     * cto*A[i][j]/cfrom does not over/underflow. type specifies that A may be full, upper triangular, lower triangular,
	     * upper Hessenberg, or banded.
	     * 
	     * @param type input char type indicates the storage type of the input matrix. = 'G': A is a full matrix. = 'L': A
	     *            is a lower triangular matrix. = 'U': A is an upper triangular matrix. = 'H': A is an upper Hessenberg
	     *            matrix. = 'B': A is a symmetric band matrix with lower bandwidth kL and upper bandwidth ku and with
	     *            only the lower half stored. = 'Q': A is a symmetric band matrix with lower bandwidth kL and upper
	     *            bandwidth ku and with only the upper half stored. = 'Z': A is a band matrix with lower bandwith kL and
	     *            upper bandwidth ku
	     * @param kL input int The lower bandwidth of A. Referenced only if type = 'B', 'Q', or 'Z'.
	     * @param ku input int The upper bandwidth of A. Referenced only if type = 'B', 'Q', or 'Z'.
	     * @param cfrom input double
	     * @param cto input double The matrix A is multiplied by cto/cfrom. A[i][j] is computed without over/underflow if
	     *            the final result cto*A[i][j]/cfrom can be represented without over/underflow. cfrom must be nonzero.
	     * @param m input int The number of rows of the matrix A. m >= 0.
	     * @param n input int The number of columns of the matrix A. n >= 0.
	     * @param A input/output double[][] of dimension lda by n. The matrix to be multiplied by cto/cfrom.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     */
	    private void dlascl(final char type, final int kL, final int ku, final double cfrom, final double cto, final int m,
	            final int n, final double[][] A, final int lda, final int[] info) {
	        boolean done;
	        int i;
	        int itype;
	        int j;
	        int k1;
	        int k2;
	        int k3;
	        int k4;
	        double bignum;
	        double cfrom1;
	        double cfromc;
	        double cto1;
	        double ctoc;
	        double mul;
	        double smlnum;

	        // Test the input arguments
	        info[0] = 0;

	        if ( (type == 'G') || (type == 'g')) {
	            itype = 0;
	        } else if ( (type == 'L') || (type == 'l')) {
	            itype = 1;
	        } else if ( (type == 'U') || (type == 'u')) {
	            itype = 2;
	        } else if ( (type == 'H') || (type == 'h')) {
	            itype = 3;
	        } else if ( (type == 'B') || (type == 'b')) {
	            itype = 4;
	        } else if ( (type == 'Q') || (type == 'q')) {
	            itype = 5;
	        } else if ( (type == 'Z') || (type == 'z')) {
	            itype = 6;
	        } else {
	            itype = -1;
	        }

	        if (itype == -1) {
	            info[0] = -1;
	        } else if ( (cfrom == 0.0) || (Double.isNaN(cfrom))) {
	            info[0] = -4;
	        } else if (Double.isNaN(cto)) {
	            info[0] = -5;
	        } else if (m < 0) {
	            info[0] = -6;
	        } else if ( (n < 0) || ( (itype == 4) && (n != m)) || ( (itype == 5) && (n != m))) {
	            info[0] = -7;
	        } else if ( (itype <= 3) && (lda < Math.max(1, m))) {
	            System.err.println("itype = " + itype + " m = " + m + " lda = " + lda);
	            info[0] = -9;
	        } else if (itype >= 4) {

	            if ( (kL < 0) || (kL > Math.max(m - 1, 0))) {
	                info[0] = -2;
	            } else if ( (ku < 0) || (ku > Math.max(n - 1, 0)) || ( ( (itype == 4) || (itype == 5)) && (kL != ku))) {
	                info[0] = -3;
	            } else if ( ( (itype == 4) && (lda < (kL + 1))) || ( (itype == 5) && (lda < (ku + 1)))
	                    || ( (itype == 6) && (lda < ( (2 * kL) + ku + 1)))) {
	                info[0] = -9;
	            }
	        } // else if (itype >= 4)

	        if (info[0] != 0) {
//	            System.err.println("Error dlascl had info = " + info[0]);
	            System.err.print("Error dlascl had info = " + info[0] + "\n");
	            return;
	        }

	        // Quick return if possible
	        if ( (n == 0) || (m == 0)) {
	            return;
	        }

	        // Get machine parameters
	        smlnum = dlamch('S');
	        bignum = 1.0 / smlnum;

	        cfromc = cfrom;
	        ctoc = cto;

	        do {
	            cfrom1 = cfromc * smlnum;
	            if (cfrom1 == cfromc) {
	                // cfromc is an infinity. Multiply by a correctly signed zero for finite ctoc,
	                // or a NaN if ctoc is infinite
	                mul = ctoc / cfromc;
	                done = true;
	                cto1 = ctoc;
	            } // if (cfrom1 == cfromc)
	            else {
	                cto1 = ctoc / bignum;
	                if (cto1 == ctoc) {
	                    // ctoc is either 0 or an infinity. In both cases, ctoc itself
	                    // serves as the correct multiplication factor
	                    mul = ctoc;
	                    done = true;
	                    cfromc = 1.0;
	                } else if ( (Math.abs(cfrom1) > Math.abs(ctoc)) && (ctoc != 0.0)) {
	                    mul = smlnum;
	                    done = false;
	                    cfromc = cfrom1;
	                } else if (Math.abs(cto1) > Math.abs(cfromc)) {
	                    mul = bignum;
	                    done = false;
	                    ctoc = cto1;
	                } else {
	                    mul = ctoc / cfromc;
	                    done = true;
	                }
	            }

	            if (itype == 0) {

	                // Full matrix
	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // if (itype == 0)
	            else if (itype == 1) {

	                // Lower triangular matrix
	                for (j = 0; j < n; j++) {

	                    for (i = j; i < m; i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // else if (itype == 1)
	            else if (itype == 2) {

	                // Upper triangular matrix
	                for (j = 0; j < n; j++) {

	                    for (i = 0; i <= Math.min(j, m - 1); i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // else if (itype == 2)
	            else if (itype == 3) {

	                // Upper Hessenberg matrix
	                for (j = 0; j < n; j++) {

	                    for (i = 0; i <= Math.min(j + 1, m - 1); i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // else if (itype == 3)
	            else if (itype == 4) {

	                // Lower half of a symmetric band matrix
	                k3 = kL + 1;
	                k4 = n + 1;

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i <= Math.min(k3 - 1, k4 - j - 2); i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // else if (itype == 4)
	            else if (itype == 5) {

	                // upper half of a symmetric band matrix
	                k1 = ku + 2;
	                k3 = ku + 1;

	                for (j = 0; j < n; j++) {

	                    for (i = Math.max(k1 - j - 2, 0); i <= (k3 - 1); i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // else if (itype == 5)
	            else if (itype == 6) {

	                // Band matrix
	                k1 = kL + ku + 2;
	                k2 = kL + 1;
	                k3 = (2 * kL) + ku + 1;
	                k4 = kL + ku + 1 + m;

	                for (j = 0; j < n; j++) {

	                    for (i = Math.max(k1 - j - 2, k2 - 1); i <= Math.min(k3 - 1, k4 - j - 2); i++) {
	                        A[i][j] = A[i][j] * mul;
	                    }
	                }
	            } // else if (itype == 6)
	        } while ( !done);

	        return;
	    } // dlascl

	    /**
	     * This is a port of version 3.2 auxiliary routine DLASET. Original DLASET created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlaset initializes an m-by-n matrix A
	     * to beta on the diagonal and alpha on the offdiagonals.
	     * 
	     * @param uplo input char Specifies the part of the matrix to be set. = 'U': Upper triangular part is set; the
	     *            strictly lower triangular part of A is not changed. = 'L': Lower triangular part is set; the strictly
	     *            upper triangular part of A is not changed. Otherwise: All of the matrix A is set.
	     * @param m input int The number of rows of the matrix A. m >= 0.
	     * @param n input int The number of columns of the matrix A. n >= 0.
	     * @param alpha input double The constant to which the offdiagonal elements are to be set.
	     * @param beta input double The constant to which the diagonal elements are to be set.
	     * @param A input/output double[][] of dimension lda by n. On exit, the leading m-by-n submatrix of A is set as
	     *            follows: If uplo = 'U', A(i,j) = alpha, 0 <= i <= j-1, 0 <= j <= n-1, If uplo = 'L', A(i,j) = alpha,
	     *            j+1 <= i <= m-1, 0 <= j <= n-1, Otherwise, A(i,j) = alpha, 0 <= i <= m-1, 0 <= j <= n-1, i!= j and,
	     *            for all uplo, A(i,i) = beta, 0 <= i <= min(m-1,n-1).
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     */
	    private void dlaset(final char uplo, final int m, final int n, final double alpha, final double beta,
	            final double[][] A, final int lda) {
	        int i;
	        int j;

	        if ( (uplo == 'U') || (uplo == 'u')) {

	            // Set the srictly upper triangular or trapezoidal part of the array to
	            // alpha.
	            for (j = 1; j < n; j++) {

	                for (i = 0; i <= Math.min(j - 1, m - 1); i++) {
	                    A[i][j] = alpha;
	                }
	            }
	        } // if ((uplo == 'U') || (uplo == 'u'))
	        else if ( (uplo == 'L') || (uplo == 'l')) {

	            // Set the strictly lower triangular or trapezoidal part of the array to
	            // alpha.
	            for (j = 0; j <= Math.min(m - 1, n - 1); j++) {

	                for (i = j + 1; i <= (m - 1); i++) {
	                    A[i][j] = alpha;
	                }
	            }
	        } // else if ((uplo == 'L') || (uplo == 'l'))
	        else {

	            // Set the leading m-by-n submatrix to alpha
	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    A[i][j] = alpha;
	                }
	            }
	        } // else

	        // Set the first min(m,n) diagonal elements to beta
	        for (i = 0; i <= Math.min(m - 1, n - 1); i++) {
	            A[i][i] = beta;
	        }

	        return;
	    } // dlaset

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLASR Original DLASR created by Univ. of Tennessee, Univ.
	     * of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlasr applies a sequence of plane
	     * rotations to a real matrix A, from either the left or the right. when side = 'L', the transformation takes the
	     * form A = P * A and when side = 'R', the transformation takes the form A = A * P**T where P is an orthogonal
	     * matrix consisting of a sequence of z plane rotations, with z = m when side = 'L' and z = n when side = 'R', and
	     * P**T is the transpose of P.
	     * 
	     * When direct = 'F' (Forward sequence), then P = P(z-2) * ... * P(1) * P(0) and when direct = 'B' (Backward
	     * sequence), then P = P(0) * P(1) * ... * P(z-2) where P(k) is a plane rotation matrix defined by the 2-by-2
	     * rotation R(k) = ( c(k) s(k) ) ( -s(k) c(k) )
	     * 
	     * When pivot = 'V' (Variable pivot), the rotation is performed for the plane (k,k+1), i.e., P(k) has the form P(k)
	     * = ( 1 ) ( ... ) ( 1 ) ( c(k) s(k) ) ( -s(k) c(k) ) ( 1 ) ( ... ) ( 1 ) where R(k) appears as a rank-2
	     * modification to the identity matrix in rows and columns k and k+1.
	     * 
	     * When pivot = 'T' (Top pivot), the rotation is performed for the plane (1,k+1), so P(k) has the form P(k) = ( c(k)
	     * s(k) ) ( 1 ) ( ... ) ( 1 ) ( -s(k) c(k) ) ( 1 ) ( ... ) ( 1 ) where R(k) appears in rows and column 1 and k+1
	     * 
	     * 
	     * Similarly, when pivot = 'B' (Bottom pivot), the rotation is performed for the plane (k,z), giving P(k) the form
	     * P(k) = ( 1 ) ( ... ) ( 1 ) ( c(k) s(k) ) ( 1 ) ( ... ) ( 1 ) ( -s(k) c(k) ) where R(k) appears in rows and
	     * columns k and z. The rotations are performed without ever forming P(k) explicitly.
	     * 
	     * 
	     * @param side input char Specifies whether the plane rotation matrix P is applied to A on the left or the right. =
	     *            'L': Left, compute A = P*A = 'R': Right, compute A = A*P'
	     * @param pivot input char Specifies the plane for which p[k] is a plane rotation matrix. = 'V': Variable pivot, the
	     *            plane (k,k+1) = 'T': Top pivot, the plane (1,k+1) = 'B': Bottom pivot, the plane (k,z)
	     * @param direct input char Specifies whether P is a forward or backward sequence of plane rotations. = 'F':
	     *            Forward, p = p[z-2]*...*p[1]*p[0] = 'B': Backward, p = p[0]*p[1]*...*p[z-2]
	     * @param m input int The number of rows of the matrix A. If m <= 1, an immediate return is effected.
	     * @param n input int The number of columns of the matrix A. If n <= 1, an immediate return is effected.
	     * @param c input double[]
	     * @param s input double[] c and s are dimension (m-1) if side = 'L', (n-1) if side = 'R' c[k] and s[k] contain the
	     *            cosine and sine that define the matrix p[k]. The two by two plane rotation part of the matrix p[k],
	     *            R[k], has the form R[k] = ( c[k] s[k]) (-s[k] c[k])
	     * @param A input/output double[][] of dimension lda by n. On entry, the m by n matrix A. On exit, A is overwritten
	     *            by P*A if side = 'L' or by A*P' if side = 'R'.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,m).
	     */
	    private void dlasr(final char side, final char pivot, final char direct, final int m, final int n,
	            final double[] c, final double[] s, final double[][] A, final int lda) {
	        int i;
	        int info;
	        int j;
	        double ctemp;
	        double stemp;
	        double temp;

	        // Test the input parameters
	        info = 0;

	        if ( (side != 'L') && (side != 'l') && (side != 'R') && (side != 'r')) {
	            info = 1;
	        } else if ( (pivot != 'V') && (pivot != 'v') && (pivot != 'T') && (pivot != 't') && (pivot != 'B')
	                && (pivot != 'b')) {
	            info = 2;
	        } else if ( (direct != 'F') && (direct != 'f') && (direct != 'B') && (direct != 'b')) {
	            info = 3;
	        } else if (m < 0) {
	            info = 4;
	        } else if (n < 0) {
	            info = 5;
	        } else if (lda < Math.max(1, m)) {
	            info = 9;
	        }

	        if (info != 0) {
	            System.err.println("Error dlasr had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if ( (m == 0) || (n == 0)) {
	            return;
	        }

	        if ( (side == 'L') || (side == 'l')) {

	            // Form P*A
	            if ( (pivot == 'V') || (pivot == 'v')) {

	                if ( (direct == 'F') || (direct == 'f')) {

	                    for (j = 0; j < (m - 1); j++) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < n; i++) {
	                                temp = A[j + 1][i];
	                                A[j + 1][i] = (ctemp * temp) - (stemp * A[j][i]);
	                                A[j][i] = (stemp * temp) + (ctemp * A[j][i]);
	                            } // for (i = 0; i < n; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = 0; j < m-1; j++)
	                } // if ((direct == 'F') || (direct == 'f'))
	                else if ( (direct == 'B') || (direct == 'b')) {

	                    for (j = m - 2; j >= 0; j--) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < n; i++) {
	                                temp = A[j + 1][i];
	                                A[j + 1][i] = (ctemp * temp) - (stemp * A[j][i]);
	                                A[j][i] = (stemp * temp) + (ctemp * A[j][i]);
	                            } // for (i = 0; i < n; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = m-2; j >= 0; j--)
	                } // else if ((direct == 'B') || (direct == 'b'))
	            } // if ((pivot == 'V') || (pivot == 'v'))
	            else if ( (pivot == 'T') || (pivot == 't')) {

	                if ( (direct == 'F') || (direct == 'f')) {

	                    for (j = 1; j < m; j++) {
	                        ctemp = c[j - 1];
	                        stemp = s[j - 1];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < n; i++) {
	                                temp = A[j][i];
	                                A[j][i] = (ctemp * temp) - (stemp * A[0][i]);
	                                A[0][i] = (stemp * temp) + (ctemp * A[0][i]);
	                            } // for (i = 0; i < n; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = 1; j < m; j++)
	                } // if ((direct == 'F') || (direct == 'f'))
	                else if ( (direct == 'B') || (direct == 'b')) {

	                    for (j = m - 1; j >= 1; j--) {
	                        ctemp = c[j - 1];
	                        stemp = s[j - 1];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < n; i++) {
	                                temp = A[j][i];
	                                A[j][i] = (ctemp * temp) - (stemp * A[0][i]);
	                                A[0][i] = (stemp * temp) + (ctemp * A[0][i]);
	                            } // for (i = 0; i < n; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = m-1; j >= 1; j--)
	                } // else if ((direct == 'B') || (direct == 'b'))
	            } // else if ((pivot == 'T') || (pivot == 't'))
	            else if ( (pivot == 'B') || (pivot == 'b')) {

	                if ( (direct == 'F') || (direct == 'f')) {

	                    for (j = 0; j < (m - 1); j++) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < n; i++) {
	                                temp = A[j][i];
	                                A[j][i] = (stemp * A[m - 1][i]) + (ctemp * temp);
	                                A[m - 1][i] = (ctemp * A[m - 1][i]) - (stemp * temp);
	                            } // for (i = 0; i < n; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = 0; j < m-1; j++)
	                } // if ((direct == 'F') || (direct == 'f'))
	                else if ( (direct == 'B') || (direct == 'b')) {

	                    for (j = m - 2; j >= 0; j--) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < n; i++) {
	                                temp = A[j][i];
	                                A[j][i] = (stemp * A[m - 1][i]) + (ctemp * temp);
	                                A[m - 1][i] = (ctemp * A[m - 1][i]) - (stemp * temp);
	                            } // for (i = 0; i < n; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = m-2; j >= 0; j--)
	                } // else if (direct == 'B') || (direct == 'b'))
	            } // else if ((pivot == 'B') || (pivot == 'b'))
	        } // if ((side == 'L') || (side == 'l'))
	        else if ( (side == 'R') || (side == 'r')) {

	            // Form A * P'
	            if ( (pivot == 'V') || (pivot == 'v')) {

	                if ( (direct == 'F') || (direct == 'f')) {

	                    for (j = 0; j < (n - 1); j++) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < m; i++) {
	                                temp = A[i][j + 1];
	                                A[i][j + 1] = (ctemp * temp) - (stemp * A[i][j]);
	                                A[i][j] = (stemp * temp) + (ctemp * A[i][j]);
	                            } // for (i = 0; i < m; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = 0; j < n-1; j++)
	                } // if ((direct == 'F') || (direct == 'f'))
	                else if ( (direct == 'B') || (direct == 'b')) {

	                    for (j = n - 2; j >= 0; j--) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < m; i++) {
	                                temp = A[i][j + 1];
	                                A[i][j + 1] = (ctemp * temp) - (stemp * A[i][j]);
	                                A[i][j] = (stemp * temp) + (ctemp * A[i][j]);
	                            } // for (i = 0; i < m; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = n-2; j >= 0; j--)
	                } // else if ((direct == 'B') || (direct == 'b'))
	            } // if ((pivot == 'V') || (pivot == 'v'))
	            else if ( (pivot == 'T') || (pivot == 't')) {

	                if ( (direct == 'F') || (direct == 'f')) {

	                    for (j = 1; j < n; j++) {
	                        ctemp = c[j - 1];
	                        stemp = s[j - 1];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < m; i++) {
	                                temp = A[i][j];
	                                A[i][j] = (ctemp * temp) - (stemp * A[i][0]);
	                                A[i][0] = (stemp * temp) + (ctemp * A[i][0]);
	                            } // for (i = 0; i < m; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = 1; j < n; j++)
	                } // if ((direct == 'F') || (direct == 'f'))
	                else if ( (direct == 'B') || (direct == 'b')) {

	                    for (j = n - 1; j >= 1; j--) {
	                        ctemp = c[j - 1];
	                        stemp = s[j - 1];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < m; i++) {
	                                temp = A[i][j];
	                                A[i][j] = (ctemp * temp) - (stemp * A[i][0]);
	                                A[i][0] = (stemp * temp) + (ctemp * A[i][0]);
	                            } // for (i = 0; i < m; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = n-1; j >= 1; j--)
	                } // else if ((direct == 'B') || (direct == 'b'))
	            } // else if ((pivot == 'T') || (pivot == 't'))
	            else if ( (pivot == 'B') || (pivot == 'b')) {

	                if ( (direct == 'F') || (direct == 'f')) {

	                    for (j = 0; j < (n - 1); j++) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < m; i++) {
	                                temp = A[i][j];
	                                A[i][j] = (stemp * A[i][n - 1]) + (ctemp * temp);
	                                A[i][n - 1] = (ctemp * A[i][n - 1]) - (stemp * temp);
	                            } // for (i = 0; i < m; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = 0; j < n-1; j++)
	                } // if ((direct == 'F') || (direct == 'f'))
	                else if ( (direct == 'B') || (direct == 'b')) {

	                    for (j = n - 2; j >= 0; j--) {
	                        ctemp = c[j];
	                        stemp = s[j];

	                        if ( (ctemp != 1.0) || (stemp != 0.0)) {

	                            for (i = 0; i < m; i++) {
	                                temp = A[i][j];
	                                A[i][j] = (stemp * A[i][n - 1]) + (ctemp * temp);
	                                A[i][n - 1] = (ctemp * A[i][n - 1]) - (stemp * temp);
	                            } // for (i = 0; i < m; i++)
	                        } // if ((ctemp != 1.0) || (stemp != 0.0))
	                    } // for (j = n-2; j >= 0; j--)
	                } // else if ((direct == 'B') || (direct == 'b'))
	            } // else if ((pivot == 'B') || (pivot == 'b'))
	        } // else if ((side == 'R') || (side == 'r'))

	        return;
	    } // dlasr

	    /**
	     * This is a port of the version 3.2 LAPACK auxiliary routine DLASRT Original DLASRT created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlasrt sorts the numbers in
	     * d in increasing order if id == 'I' or in decreasing order if id == 'D'. Use quick sort, reverting to insertion
	     * sort on arrays of size <= 20. Dimension of stack limits n to about 2**32.
	     * 
	     * @param id input char = 'I': sort d in increasing order = 'D': sort d in decreasing order
	     * @param n input int The length of the array d.
	     * @param d input/output double[] of dimension n. On entry, the array to be sorted. On exit, d has been sorted into
	     *            increasing order (d[0] <= ... <= d[n-1]) or into decreasing order (d[0] >= ... >= d[n-1]), depending
	     *            on id.
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     */
	    private void dlasrt(final char id, final int n, final double[] d, final int[] info) {
	        final int select = 20;
	        int dir;
	        int endd;
	        int i;
	        int j;
	        int start;
	        int stkpnt;
	        double d1;
	        double d2;
	        double d3;
	        double dmnmx;
	        double tmp;
	        final int[][] stack = new int[2][32];

	        // Test the input parameters
	        info[0] = 0;
	        dir = -1;

	        if ( (id == 'D') || (id == 'd')) {
	            dir = 0;
	        } else if ( (id == 'I') || (id == 'i')) {
	            dir = 1;
	        }

	        if (dir == -1) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dlasrt had info = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n <= 1) {
	            return;
	        }

	        stkpnt = 0;
	        stack[0][0] = 0;
	        stack[1][0] = n - 1;

	        do {
	            start = stack[0][stkpnt];
	            endd = stack[1][stkpnt];
	            stkpnt = stkpnt - 1;

	            if ( ( (endd - start) <= select) && ( (endd - start) > 0)) {

	                // Do insertion sort on d(start:endd)
	                if (dir == 0) {

	                    // Sort into decreasing order
	                    loop1: for (i = start + 1; i <= endd; i++) {

	                        for (j = i; j >= (start + 1); j--) {

	                            if (d[j] > d[j - 1]) {
	                                dmnmx = d[j];
	                                d[j] = d[j - 1];
	                                d[j - 1] = dmnmx;
	                            } else {
	                                continue loop1;
	                            }
	                        } // for (j = i; j >= start+1; j--)
	                    } // for (i = start+1; i <= endd; i++)
	                } // if (dir == 0)
	                else { // dir == 1

	                    // Sort into increasing order
	                    loop2: for (i = start + 1; i <= endd; i++) {

	                        for (j = i; j >= (start + 1); j--) {

	                            if (d[j] < d[j - 1]) {
	                                dmnmx = d[j];
	                                d[j] = d[j - 1];
	                                d[j - 1] = dmnmx;
	                            } else {
	                                continue loop2;
	                            }
	                        } // for (j = i; j >= start+1; j--)
	                    } // for (i = start+1; i <= endd; i++)
	                } // else dir == 1
	            } // if (((endd - start) <= select) && ((endd - start) > 0))
	            else if ( (endd - start) > select) {

	                // Partition d(start:endd) and stack parts, largest one first
	                // Choose partition entry as median of 3
	                d1 = d[start];
	                d2 = d[endd];
	                i = (start + endd) / 2;
	                d3 = d[i];

	                if (d1 < d2) {

	                    if (d3 < d1) {
	                        dmnmx = d1;
	                    } else if (d3 < d2) {
	                        dmnmx = d3;
	                    } else {
	                        dmnmx = d2;
	                    }
	                } // if (d1 < d2)
	                else { // d1 >= d2

	                    if (d3 < d2) {
	                        dmnmx = d2;
	                    } else if (d3 < d1) {
	                        dmnmx = d3;
	                    } else {
	                        dmnmx = d1;
	                    }
	                } // else d1 >= d2

	                if (dir == 0) {

	                    // Sort into decreasing order
	                    i = start - 1;
	                    j = endd + 1;

	                    loop3: do {
	                        j = j - 1;

	                        if (d[j] < dmnmx) {
	                            continue loop3;
	                        }

	                        do {
	                            i = i + 1;
	                        } while (d[i] > dmnmx);

	                        if (i < j) {
	                            tmp = d[i];
	                            d[i] = d[j];
	                            d[j] = tmp;

	                            continue loop3;
	                        } // if (i < j)

	                        break loop3;
	                    } // loop3
	                    while (true);

	                    if ( (j - start) > (endd - j - 1)) {
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = start;
	                        stack[1][stkpnt] = j;
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = j + 1;
	                        stack[1][stkpnt] = endd;
	                    } // if ((j - start) > (endd - j - 1))
	                    else { // ((j - start) <= (endd - j - 1))
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = j + 1;
	                        stack[1][stkpnt] = endd;
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = start;
	                        stack[1][stkpnt] = j;
	                    } // else ((j - start) <= (endd - j - 1))
	                } // if (dir == 0)
	                else { // dir == 1

	                    // Sort into increasing order
	                    i = start - 1;
	                    j = endd + 1;

	                    loop4: do {
	                        j = j - 1;

	                        if (d[j] > dmnmx) {
	                            continue loop4;
	                        }

	                        do {
	                            i = i + 1;
	                        } while (d[i] < dmnmx);

	                        if (i < j) {
	                            tmp = d[i];
	                            d[i] = d[j];
	                            d[j] = tmp;

	                            continue loop4;
	                        } // if (i < j)

	                        break loop4;
	                    } // loop4
	                    while (true);

	                    if ( (j - start) > (endd - j - 1)) {
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = start;
	                        stack[1][stkpnt] = j;
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = j + 1;
	                        stack[1][stkpnt] = endd;
	                    } // if ((j-start) > (endd-j-1))
	                    else { // ((j-start) <= (endd-j-1))
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = j + 1;
	                        stack[1][stkpnt] = endd;
	                        stkpnt = stkpnt + 1;
	                        stack[0][stkpnt] = start;
	                        stack[1][stkpnt] = j;
	                    } // else ((j-start) <= (endd-j-1)
	                } // else dir == 1
	            } // else if ((endd - start) > select)
	        } while (stkpnt > -1);

	        return;
	    } // dlasrt

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLASSQ Original DLASSQ created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlassq returns the values
	     * scl and smsq such that (scl**2)*smsq = x[0]**2 + x[incx]**2 + ... + x[(n-1)*incx]**2 + (scale**2)*sumsq The value
	     * of sumsq is assumed to be non-negative and scl returns the value scl = max(scale,abs(x[i])). scale and sumsq
	     * refer to the original supplied values in scale[] and sumsq[]. scl and smsq are the returned values in scale[] and
	     * sumsq[] that overwrite the orginal values. This routine makes only one pass through the vector x.
	     * 
	     * @param n input int The number of elements to be used from the vector x
	     * @param x input double[] The vector for which a scaled sum of squares is computed, using x[0], x[incx], ...,
	     *            x[(n-1)*incx]
	     * @param incx input int The increment between successive values of the vector x. incx > 0.
	     * @param scale input/output double[] On entry, the value scale in the equation above. On exit, scale is overwritten
	     *            with scl, the scaling factor for the sum of squares
	     * @param sumsq input/output double[] On entry, the value sumsq in the equation above. On exit, sumsq is overwritten
	     *            with smsq, the basic sum of squares from which scl has been factored out.
	     */
	    private void dlassq(final int n, final double[] x, final int incx, final double[] scale, final double[] sumsq) {
	        int ix;
	        double absxi;
	        double ratio;

	        if (n > 0) {

	            for (ix = 0; ix <= ( (n - 1) * incx); ix += incx) {

	                if (x[ix] != 0.0) {
	                    absxi = Math.abs(x[ix]);

	                    if (scale[0] < absxi) {
	                        ratio = scale[0] / absxi;
	                        sumsq[0] = 1 + (sumsq[0] * ratio * ratio);
	                        scale[0] = absxi;
	                    } // if (scale[0] < absxi)
	                    else { // scale[0] >= absxi
	                        ratio = absxi / scale[0];
	                        sumsq[0] = sumsq[0] + (ratio * ratio);
	                    } // else scale[0] >= absxi
	                } // if (x[ix] != 0.0)
	            } // for (ix = 0; ix <= (n-1)*incx; ix += incx)
	        } // if (n > 0)

	        return;
	    } // dlassq

	    /**
	     * This is a port of version 3.2 LAPACK auxiliary routine DLASV2 Original DLASV2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dlasv2 computes the singular
	     * value decomposition of a 2-by-2 triangular matrix [ f g ] [ 0 h ]. On return, abs(ssmax[0]) is the larger
	     * singular value, abs(ssmin[0]) is the smaller singular value, and (csl[0],snl[0]) and (csr[0],snr[0]) are the left
	     * and right singular vectors for abs(ssmax[0]), giving the decomposition [ csl snl] [f g ] [ csr -snr] = [ ssmax 0
	     * ] [-snl csl] [0 h ] [ snr csr] [ 0 ssmin ].
	     * 
	     * @param f input double The (0,0) element of a 2-by-2 matrix.
	     * @param g input double The (0,1) element of a 2-by-2 matrix.
	     * @param h input double The (1,1) element of a 2-by-2 matrix.
	     * @param ssmin output double[] abs(ssmin[0]) is the smaller singular value.
	     * @param ssmax output double[] abs(ssmax[0]) is the larger singular value.
	     * @param snr output double[]
	     * @param csr output double[] The vector (csr[0],snr[0]) is a unit right singular vector for the singular value
	     *            abs(ssmax[0]).
	     * @param snl output double[]
	     * @param csl output double[] The vector (csl[0],snl[0]) is a unit left singular vector for the singular value
	     *            abs(ssmax[0]). Further details: Any input parameter may be aliased with any output parameter.
	     * 
	     *            <p>
	     *            Barring over/underflow and assuming a guard digit in subtraction, all output quantities are correct to
	     *            within a few units in the last place (ulps).
	     *            </p>
	     * 
	     *            <p>
	     *            In IEEE arithmetic, the code works correctly if one matrix element is infinite.
	     *            </p>
	     * 
	     *            <p>
	     *            Overflow will not occur unless the largest singular value itself overflows or is within a few ulps of
	     *            overflow. (On machines with partial overflow, like the Cray, overflow may occur if the largest
	     *            singular value is within a factor of 2 of overflow.)
	     *            </p>
	     * 
	     *            <p>
	     *            Underflow is harmless if underflow is gradual. Otherwise, results may correspond to a matrix modified
	     *            by perturbations of size near the underflow threshold.
	     *            </p>
	     */
	    private void dlasv2(final double f, final double g, final double h, final double[] ssmin, final double[] ssmax,
	            final double[] snr, final double[] csr, final double[] snl, final double[] csl) {
	        boolean gasmal;
	        boolean swap;
	        int pmax;
	        double a;
	        double clt = 0.0;
	        double crt = 0.0;
	        double d;
	        double fa;
	        double ft;
	        double ga;
	        double gt;
	        double ha;
	        double ht;
	        double L;
	        double m;
	        double mm;
	        double r;
	        double s;
	        double slt = 0.0;
	        double srt = 0.0;
	        double t;
	        double temp;
	        double tsign;
	        double tt;

	        ft = f;
	        fa = Math.abs(ft);
	        ht = h;
	        ha = Math.abs(h);

	        // pmax points to the maximum value of the matrix
	        // pmax = 1 if f largest in absolute value
	        // pmax = 2 if g largest in absolute value
	        // pmax = 3 if h largest in absolute value
	        pmax = 1;
	        swap = (ha > fa);

	        if (swap) {
	            pmax = 3;
	            temp = ft;
	            ft = ht;
	            ht = temp;
	            temp = fa;
	            fa = ha;
	            ha = temp;
	            // Now fa >= ha
	        } // if (swap)

	        gt = g;
	        ga = Math.abs(gt);

	        if (ga == 0.0) {

	            // Diagonal matrix
	            ssmin[0] = ha;
	            ssmax[0] = fa;
	            clt = 1.0;
	            crt = 1.0;
	            slt = 0.0;
	            srt = 0.0;
	        } // if (ga == 0.0)
	        else {
	            gasmal = true;

	            if (ga > fa) {
	                pmax = 2;

	                if ( (fa / ga) < dlamch('E')) {

	                    // Case of very large ga
	                    gasmal = false;
	                    ssmax[0] = ga;

	                    if (ha > 1.0) {
	                        ssmin[0] = fa / (ga / ha);
	                    } else {
	                        ssmin[0] = (fa / ga) * ha;
	                    }

	                    clt = 1.0;
	                    slt = ht / gt;
	                    srt = 1.0;
	                    crt = ft / gt;
	                } // if ((fa/ga) < dlamch('E'))
	            } // if (ga > fa)

	            if (gasmal) {

	                // Normal case
	                d = fa - ha;

	                if (d == fa) {

	                    // Copes with infinite F or H
	                    L = 1.0;
	                } // if (d == fa)
	                else {
	                    L = d / fa;
	                } // else

	                // Note that 0 <= L <= 1
	                m = gt / ft;

	                // Note that abs(m) <= 1/macheps
	                t = 2.0 - L;

	                // Note that t >= 1
	                mm = m * m;
	                tt = t * t;
	                s = Math.sqrt(tt + mm);

	                // Note that 1 <= s <= 1 + 1/macheps
	                if (L == 0.0) {
	                    r = Math.abs(m);
	                } else {
	                    r = Math.sqrt( (L * L) + mm);
	                }

	                // Note that 0 <= r <= 1 + 1/macheps
	                a = 0.5 * (s + r);

	                // Note that 1 <= a <= 1 + abs(m);
	                ssmin[0] = ha / a;
	                ssmax[0] = fa * a;

	                if (mm == 0.0) {

	                    // Note that m is very tiny
	                    if (L == 0.0) {

	                        if ( ( (ft >= 0.0) && (gt >= 0.0)) || ( (ft < 0.0) && (gt < 0.0))) {
	                            t = 2.0;
	                        } else {
	                            t = -2.0;
	                        }
	                    } // if (L == 0.0)
	                    else if (ft >= 0.0) {
	                        t = (gt / Math.abs(d)) + (m / t);
	                    } // else if (ft >= 0.0)
	                    else {
	                        t = ( -gt / Math.abs(d)) + (m / t);
	                    } // else
	                } // if (mm == 0.0)
	                else {
	                    t = ( (m / (s + t)) + (m / (r + L))) * (1.0 + a);
	                }

	                L = Math.sqrt( (t * t) + 4.0);
	                crt = 2.0 / L;
	                srt = t / L;
	                clt = (crt + (srt * m)) / a;
	                slt = (ht / ft) * srt / a;
	            } // if (gasmal)
	        } // else

	        if (swap) {
	            csl[0] = srt;
	            snl[0] = crt;
	            csr[0] = slt;
	            snr[0] = clt;
	        } // if (swap)
	        else {
	            csl[0] = clt;
	            snl[0] = slt;
	            csr[0] = crt;
	            snr[0] = srt;
	        } // else

	        // Correct signs of ssmax and ssmin
	        tsign = 1.0;

	        if (pmax == 1) {

	            if (csr[0] < 0.0) {
	                tsign = -tsign;
	            }

	            if (csl[0] < 0.0) {
	                tsign = -tsign;
	            }

	            if (f < 0) {
	                tsign = -tsign;
	            }
	        } // if (pmax == 1)

	        if (pmax == 2) {

	            if (snr[0] < 0.0) {
	                tsign = -tsign;
	            }

	            if (csl[0] < 0.0) {
	                tsign = -tsign;
	            }

	            if (g < 0.0) {
	                tsign = -tsign;
	            }
	        } // if (pmax == 2)

	        if (pmax == 3) {

	            if (snr[0] < 0.0) {
	                tsign = -tsign;
	            }

	            if (snl[0] < 0.0) {
	                tsign = -tsign;
	            }

	            if (h < 0.0) {
	                tsign = -tsign;
	            }
	        } // if (pmax == 3)

	        if (tsign >= 0.0) {
	            ssmax[0] = Math.abs(ssmax[0]);
	        } else {
	            ssmax[0] = -Math.abs(ssmax[0]);
	        }

	        if (f < 0.0) {
	            tsign = -tsign;
	        }

	        if (h < 0.0) {
	            tsign = -tsign;
	        }

	        if (tsign >= 0.0) {
	            ssmin[0] = Math.abs(ssmin[0]);
	        } else {
	            ssmin[0] = -Math.abs(ssmin[0]);
	        }

	        return;
	    } // dlasv2

	    /**
	     * This is a port of version 3.4.0 LAPACK test routine DLATB4. Univ. of Tennessee, Univ. of California Berkeley,
	     * University of Colorado and NAG Ltd.. November 2011
	     * 
	     * .. Scalar Arguments .. CHARACTER DIST, TYPE CHARACTER*3 PATH INTEGER IMAT, KL, KU, M, MODE, N DOUBLE PRECISION
	     * ANORM, CNDNUM ..
	     * 
	     * Purpose =======
	     * 
	     * DLATB4 sets parameters for the matrix generator based on the type of matrix to be generated.
	     * 
	     * Arguments =========
	     * 
	     * PATH (input) String The LAPACK path name.
	     * 
	     * IMAT (input) INTEGER An integer key describing which matrix to generate for this path.
	     * 
	     * M (input) INTEGER The number of rows in the matrix to be generated.
	     * 
	     * N (input) INTEGER The number of columns in the matrix to be generated.
	     * 
	     * TYPE (output) CHARACTER*1 The type of the matrix to be generated: = 'S': symmetric matrix = 'P': symmetric
	     * positive (semi)definite matrix = 'N': nonsymmetric matrix
	     * 
	     * KL (output) INTEGER The lower band width of the matrix to be generated.
	     * 
	     * KU (output) INTEGER The upper band width of the matrix to be generated.
	     * 
	     * ANORM (output) DOUBLE PRECISION The desired norm of the matrix to be generated. The diagonal matrix of singular
	     * values or eigenvalues is scaled by this value.
	     * 
	     * MODE (output) INTEGER A key indicating how to choose the vector of eigenvalues.
	     * 
	     * CNDNUM (output) DOUBLE PRECISION The desired condition number.
	     * 
	     * DIST (output) CHARACTER*1 The type of distribution to be used by the random number generator.
	     */
	    private void dlatb4(final String path, final int imat, final int m, final int n, final char[] type, final int[] kl,
	            final int[] ku, final double anorm[], final int[] mode, final double[] cndnum, final char[] dist) {
	        String c2;
	        int mat;
	        // Set some constants for use in the subroutine.
	        if (first_dlatb4) {
	            first_dlatb4 = false;
	            eps_dlatb4 = dlamch('P'); // Precision
	            badc2_dlatb4 = 0.1 / eps_dlatb4;
	            badc1_dlatb4 = Math.sqrt(badc2_dlatb4);
	            small_dlatb4[0] = dlamch('S'); // Safe minimum
	            large_dlatb4[0] = 1.0 / small_dlatb4[0];

	            // If it looks like we're on a Cray, take the square root of
	            // small_dlatb4 and large_dlatb4 to avoid overflow and underflow problems.
	            dlabad(small_dlatb4, large_dlatb4);
	            small_dlatb4[0] = 0.25 * (small_dlatb4[0] / eps_dlatb4);
	            large_dlatb4[0] = 1.0 / small_dlatb4[0];
	        } // if (first_dlatb4)

	        c2 = path.substring(1, 3);

	        // Set some parameters we don't plan to change.

	        dist[0] = 'S';
	        mode[0] = 3;
	        if ( (c2.equalsIgnoreCase("QR")) || (c2.equalsIgnoreCase("LQ")) || (c2.equalsIgnoreCase("QL"))
	                || (c2.equalsIgnoreCase("RQ"))) {
	            // xQR, xLQ, xQL, xRQ: Set parameters to generate a general m x n matrix.
	            // Set type[0], the type of matrix to be generated.
	            type[0] = 'N';

	            // Set the lower and upper bandwidths.
	            if (imat == 1) {
	                kl[0] = 0;
	                ku[0] = 0;
	            } else if (imat == 2) {
	                kl[0] = 0;
	                ku[0] = Math.max(n - 1, 0);
	            } else if (imat == 3) {
	                kl[0] = Math.max(m - 1, 0);
	                ku[0] = 0;
	            } else {
	                kl[0] = Math.max(m - 1, 0);
	                ku[0] = Math.max(n - 1, 0);
	            }

	            // Set the condition number and norm.
	            if (imat == 5) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 6) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (imat == 7) {
	                anorm[0] = small_dlatb4[0];
	            } else if (imat == 8) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // if ((c2.equalsIgnoreCase("QR")) || (c2.equalsIgnoreCase("LQ")) ||
	        else if (c2.equalsIgnoreCase("GE")) {
	            // xGE: Set parameters to generate a general m x n matrix.

	            // Set type[0], the type of matrix to be generated.
	            type[0] = 'N';

	            // Set the lower and upper bandwidths.
	            if (imat == 1) {
	                kl[0] = 0;
	                ku[0] = 0;
	            } else if (imat == 2) {
	                kl[0] = 0;
	                ku[0] = Math.max(n - 1, 0);
	            } else if (imat == 3) {
	                kl[0] = Math.max(m - 1, 0);
	                ku[0] = 0;
	            } else {
	                kl[0] = Math.max(m - 1, 0);
	                ku[0] = Math.max(n - 1, 0);
	            }

	            // Set the condition number and norm.
	            if (imat == 8) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 9) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (imat == 10) {
	                anorm[0] = small_dlatb4[0];
	            } else if (imat == 11) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if (c2.equalsIgnoreCase("GE"))
	        else if (c2.equalsIgnoreCase("GB")) {
	            // xGB: Set parameters to generate a general banded matrix.

	            // Set type[0], the type of matrix to be generated.
	            type[0] = 'N';

	            // Set the condition number and norm
	            if (imat == 5) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 6) {
	                cndnum[0] = 0.1 * badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (imat == 7) {
	                anorm[0] = small_dlatb4[0];
	            } else if (imat == 8) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if (c2.equalsIgnoreCase("GB"))
	        else if (c2.equalsIgnoreCase("GT")) {
	            // xGT; Set parameters to generate a generate tridiagonal matrix.

	            // Set type[0], the type of matrix to be generated
	            type[0] = 'N';

	            // Set the lower and upper bandwidths.
	            if (imat == 1) {
	                kl[0] = 0;
	            } else {
	                kl[0] = 1;
	            }
	            ku[0] = kl[0];

	            // Set the condition number and norm.
	            if (imat == 3) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 4) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if ( (imat == 5) || (imat == 11)) {
	                anorm[0] = small_dlatb4[0];
	            } else if ( (imat == 6) || (imat == 12)) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if (c2.equalsIgnoreCase("GT))
	        else if ( (c2.equalsIgnoreCase("PO")) || (c2.equalsIgnoreCase("PP")) || (c2.equalsIgnoreCase("SY"))
	                || (c2.equalsIgnoreCase("SP"))) {
	            // xPO, xPP, XSY, xSP: Set parameters to generate a symmetric matrx.

	            // Set type[0], the type of matrix to be generated
	            type[0] = c2.charAt(0);

	            // Set the lower and upper bandwidths.
	            if (imat == 1) {
	                kl[0] = 0;
	            } else {
	                kl[0] = Math.max(0, n - 1);
	            }
	            ku[0] = kl[0];

	            // Set the condition number and norm.
	            if (imat == 6) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 7) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (imat == 8) {
	                anorm[0] = small_dlatb4[0];
	            } else if (imat == 9) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if ((c2.equalsIgnoreCase("PO")) || (c2.equalsIgnoreCase("PP")) ||
	        else if (c2.equalsIgnoreCase("PB")) {
	            // xPB: Set the parameters to generate a symmetric band matrix.

	            // Set type[0], the type of matrix to be generated.
	            type[0] = 'P';

	            // Set the norm and condition number.
	            if (imat == 5) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 6) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (imat == 7) {
	                anorm[0] = small_dlatb4[0];
	            } else if (imat == 8) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if (c2.equalsIgnoreCase("PB))
	        else if (c2.equalsIgnoreCase("PT")) {
	            // xPT: Set parameters to generate a symmetric positive definite tridiagonal matrix.

	            type[0] = 'P';
	            if (imat == 1) {
	                kl[0] = 0;
	            } else {
	                kl[0] = 1;
	            }
	            ku[0] = kl[0];

	            // Set the condition number and norm.
	            if (imat == 3) {
	                cndnum[0] = badc1_dlatb4;
	            } else if (imat == 4) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if ( (imat == 5) || (imat == 11)) {
	                anorm[0] = small_dlatb4[0];
	            } else if ( (imat == 6) || (imat == 12)) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if (c2.equalsIgnoreCase("PT"))
	        else if ( (c2.equalsIgnoreCase("TR")) || (c2.equalsIgnoreCase("TP"))) {
	            // xTR, xTP: Set parameters to generate a triangular matrix

	            // Set type[0], the type of matrix to be generated.
	            type[0] = 'N';

	            // Set the lower and upper bandwidths.
	            mat = Math.abs(imat);
	            if ( (mat == 1) || (mat == 7)) {
	                kl[0] = 0;
	                ku[0] = 0;
	            } else if (imat < 0) {
	                kl[0] = Math.max(0, n - 1);
	                ku[0] = 0;
	            } else {
	                kl[0] = 0;
	                ku[0] = Math.max(0, n - 1);
	            }

	            // Set the condition number and norm.
	            if ( (mat == 3) || (mat == 9)) {
	                cndnum[0] = badc1_dlatb4;
	            } else if ( (mat == 4) || (mat == 10)) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (mat == 5) {
	                anorm[0] = small_dlatb4[0];
	            } else if (mat == 6) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if ((c2.equalsIgnoreCase("TR")) || (c2.equalsIgnoreCase("TP")))
	        else if (c2.equalsIgnoreCase("TB")) {
	            // xTB: Set parameters to generate a triangular band matrix.

	            // Set type[0], the type of matrix to be generated.
	            type[0] = 'N';

	            // Set the norm and condition number.
	            if ( (imat == 2) || (imat == 8)) {
	                cndnum[0] = badc1_dlatb4;
	            } else if ( (imat == 3) || (imat == 9)) {
	                cndnum[0] = badc2_dlatb4;
	            } else {
	                cndnum[0] = 2.0;
	            }

	            if (imat == 4) {
	                anorm[0] = small_dlatb4[0];
	            } else if (imat == 5) {
	                anorm[0] = large_dlatb4[0];
	            } else {
	                anorm[0] = 1.0;
	            }
	        } // else if (c2.equalsIgnoreCase("TB"))

	        if (n <= 1) {
	            cndnum[0] = 1.0;
	        }

	        return;
	    } // dlatb4

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine DLATM1 Original DLATM1 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlatm1 computes the entries of D[0...n-1] as specified
	     * by mode, cond, and irsign. idist and iseed determine the generation of random numbers. dlatm1 is called by dlatmr
	     * to generate random test matrices for LAPACK programs.
	     * 
	     * @param mode input int On entry describes how D is to be computed: = 0 means do not change D. = 1 sets D[0] = 1
	     *            and D[1:n-1] = 1.0/cond. = 2 sets D[0:n-2] = 1 and D[n-1] = 1.0/cond. = 3 sets D[i] =
	     *            cond**(-(i)/(n-1)) = 4 sets D[i] = 1 - (i)/(n-1)*(1 - 1/cond) = 5 sets D to random numbers in the
	     *            range (1/cond, 1) such that their logarithms are uniformly distributed. = 6 sets D to random numbers
	     *            from the same distribution as the rest of the matrix. < 0 has the same meaning as abs(mode), except
	     *            that the order of the elements of D is reversed. Thus if mode is positive, D has entries ranging from
	     *            1 to 1/cond. If negative, from 1/cond to 1.
	     * @param cond input double On entry, used as described under mode above. If used, it must be >= 1.
	     * @param irsign input int On entry, if mode neither -6, 0, or 6, determines sign of entries of D. 0 => leave
	     *            entries of D unchanged 1 => multiply each entry of D by 1 or -1 with probability 0.5
	     * @param idist input int On entry, idist specifies the type of distribution to be used to generate a random matrix.
	     *            1 => uniform(0,1) 2 => uniform(-1,1) 3 => normal(0,1)
	     * @param iseed input/output int[] On entry iseed specifies the seed of the random number generator. The random
	     *            number generator uses a linear congruential sequence limited to small integers, and so should produce
	     *            machine independent random numbers. The values of iseed are changed on exit, and can be used in the
	     *            next call to dlatm1 to continue the same random number sequence.
	     * @param D input/output double[] of dimension min(m,n). Array to be computed according to mode, cond, and irsign.
	     *            May be changed on exit if mode is nonzero.
	     * @param n input int The number of entries of D.
	     * @param info output int[] 0 => normal termination -1 => if mode not in range -6 to 6. -2 => if mode neither -6, 0,
	     *            or 6, and irsign neither 0 nor 1 -3 => if mode neither -6, 0, or 6 and cond less than 1 -4 => if mode
	     *            equals 6 or -6 and idist not in range 1 to 3 -7 => if n negative
	     */
	    private void dlatm1(final int mode, final double cond, final int irsign, final int idist, final int[] iseed,
	            final double[] D, final int n, final int[] info) {
	        int i;
	        double alpha;
	        double temp;

	        // Decode and test the input parameters. Initialiize flags & seed.
	        info[0] = 0;

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        // Set info if an error
	        if ( (mode < -6) || (mode > 6)) {
	            info[0] = -1;
	        } else if ( (mode != -6) && (mode != 0) && (mode != 6) && (irsign != 0) && (irsign != 1)) {
	            info[0] = -2;
	        } else if ( (mode != -6) && (mode != 0) && (mode != 6) && (cond < 1.0)) {
	            info[0] = -3;
	        } else if ( ( (mode == 6) || (mode == -6)) && ( (idist < 1) || (idist > 3))) {
	            info[0] = -4;
	        } else if (n < 0) {
	            info[0] = -7;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dlatm1 had info[0] = " + info[0]);

	            return;
	        }

	        // Compute D according to cond and mode
	        if (mode != 0) {

	            switch (Math.abs(mode)) {

	                case 1:

	                    // One large D value
	                    for (i = 1; i < n; i++) {
	                        D[i] = 1.0 / cond;
	                    }

	                    D[0] = 1.0;
	                    break;

	                case 2:

	                    // One small D value
	                    for (i = 0; i < (n - 1); i++) {
	                        D[i] = 1.0;
	                    }

	                    D[n - 1] = 1.0 / cond;
	                    break;

	                case 3:

	                    // Exponentially distributed D values
	                    D[0] = 1.0;
	                    if (n > 1) {
	                        alpha = Math.pow(cond, -1.0 / (n - 1));

	                        for (i = 1; i < n; i++) {
	                            D[i] = Math.pow(alpha, i);
	                        }
	                    } // if (n > 1)

	                    break;

	                case 4:

	                    // Arithmetically distributed D values
	                    D[0] = 1.0;
	                    if (n > 1) {
	                        temp = 1.0 / cond;
	                        alpha = (1.0 - temp) / (n - 1.0);

	                        for (i = 2; i <= n; i++) {
	                            D[i - 1] = ( (n - i) * alpha) + temp;
	                        }
	                    } // if (n > 1)

	                    break;

	                case 5:

	                    // Randomly distributed D values on (1/cond, 1)
	                    alpha = Math.log(1.0 / cond);
	                    for (i = 0; i < n; i++) {
	                        D[i] = Math.exp(alpha * dlaran(iseed));
	                    }

	                    break;

	                case 6:

	                    // Randomly distributed values from idist
	                    dlarnv(idist, iseed, n, D);
	                    break;
	            } // switch(Math.abs(mode))

	            // If mode neither -6, nor 0, or nor 6, and irsign = 1, assign random
	            // signs to D
	            if ( (mode != -6) && (mode != 0) && (mode != 6) && (irsign == 1)) {

	                for (i = 0; i < n; i++) {
	                    temp = dlaran(iseed);

	                    if (temp > 0.5) {
	                        D[i] = -D[i];
	                    }
	                }
	            } // if ((mode != -6) && (mode != 0) && (mode != 6) && (irsign == 1))

	            // Reverse if mode < 0
	            if (mode < 0) {

	                for (i = 1; i <= (n / 2); i++) {
	                    temp = D[i - 1];
	                    D[i - 1] = D[n - i];
	                    D[n - i] = temp;
	                }
	            } // if (mode < 0)
	        } // if (mode != 0)

	        return;
	    } // dlatm1

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine DLATM2 Original DLATM2 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlatm2 returns the (i,j) entry of a random matrix of
	     * dimension (m,n) described by the other parameters. It is called by the dlatmr routine in order to build random
	     * test matrices. No error checking on parameters is done, because this routine is called in a tight loop by dlatmr
	     * which has already checked the parameters.
	     * 
	     * <p>
	     * Use of dlatm2 differs from dlatm3 in the order in which the random number generator is called to fill in random
	     * matrix entries. With dlatm2, the generator is called to fill in the pivoted matrix columnwise. With dlatm3, the
	     * generator is called to fill in the matrix columnwise, after which it is pivoted. Thus, dlatm3 can be used to
	     * construct random matrices which differ only in their order of rows and/or columns. dlatm2 is used to construct
	     * band matrices while avoiding calling the random number generator for entries outisde the band (and therefore
	     * generating random numbers).
	     * </p>
	     * 
	     * <p>
	     * The matrix whose (i,j) entry is returned is constructed as follows (this routine only computes one entry):
	     * </p>
	     * 
	     * <p>
	     * If i is outside (1..m) or j is outside (1..n), return zero. (This is convenient for generating matrices in band
	     * format).
	     * </p>
	     * 
	     * <p>
	     * Generate a matrix A with random entries of distribution idist.
	     * </p>
	     * 
	     * <p>
	     * Set the diagonal to D.
	     * </p>
	     * 
	     * <p>
	     * Grade the matrix, if desired, from the left (by dl) and/or from the right (by dr or dl) as specified by igrade.
	     * </p>
	     * 
	     * <p>
	     * Permute, if desired, the rows and/or columns as specified by ipvtng and iwork.
	     * </p>
	     * 
	     * <p>
	     * Band the matrix to have lower bandwidth kl and upper bandwidth ku.
	     * </p>
	     * 
	     * <p>
	     * Set random entries to zero as specified by sparse.
	     * </p>
	     * 
	     * @param m input int Number of rows of the matrix.
	     * @param n input int Number of columns of the matrix.
	     * @param i input int Row of entry to be returned.
	     * @param j input int Column of entry to be returned.
	     * @param kl input int Lower bandwidth.
	     * @param ku input int Upper bandwidth.
	     * @param idist input int On entry, idist specifies the type of distribution to be used to generate a random matrix.
	     *            1 => uniform(0,1) 2 => uniform(-1,1) 3 => normal(0,1)
	     * @param iseed input/output int[] of dimension 4 Seed for random number generator. Changed on exit.
	     * @param D input double[] of dimension min(i,j) Diagonal entries of matrix.
	     * @param igrade input int Specifies grading of matrix as follows: 0 => no grading 1 => matrix premultiplied by
	     *            diag(dl) 2 => matrix postmultiplied by diag(dr) 3 => matrix premultiplied by diag(dl) and
	     *            postmultiplied by diag(dr) 4 => matrix premultiplied by diag(dl) and postmultiplied by inv(diag(dl)) 5
	     *            => matrix premultiplied by diag(dl) and postmultiplied by diag(dl)
	     * @param dl input double[] of dimension i or j, as appropriate Left scale factors for grading matrix.
	     * @param dr input double[] of dimension i or j, as appropriate Right scale factors for grading matrix.
	     * @param ipvtng input int On entry specifies pivoting permutations as follows: 0 => none. 1 => row pivoting. 2 =>
	     *            column pivoting. 3 => full pivoting, i.e., on both sides
	     * @param iwork input int[] of dimension i or j, as appropriate This array specifies the permutation used. The row
	     *            (or column) in position k was originally in position iwork[k-1]. This differs from iwork for dlatm3.
	     * @param sparse input double between 0.0 and 1.0. On entry specifies the sparsity of the matrix if sparse matrix is
	     *            to be generated. A uniform (0,1) random number x is generated and compared to sparse; if x is larger
	     *            the matrix entry is unchanged and if x is smaller the entry is set to zero. Thus on average a fraction
	     *            sparse of the entries will be set to zero.
	     * 
	     * @return double
	     */
	    private double dlatm2(final int m, final int n, final int i, final int j, final int kl, final int ku,
	            final int idist, final int[] iseed, final double[] D, final int igrade, final double[] dl,
	            final double[] dr, final int ipvtng, final int[] iwork, final double sparse) {
	        int isub = 0;
	        int jsub = 0;
	        double temp;

	        // Check for i and j in range
	        if ( (i < 1) || (i > m) || (j < 1) || (j > n)) {
	            return 0.0;
	        }

	        // Check for banding
	        if ( (j > (i + ku)) || (j < (i - kl))) {
	            return 0.0;
	        }

	        // Check for sparsity
	        if (sparse > 0.0) {

	            if (dlaran(iseed) < sparse) {
	                return 0.0;
	            }
	        }

	        // Compute subscripts depending on ipvtng
	        if (ipvtng == 0) {
	            isub = i;
	            jsub = j;
	        } else if (ipvtng == 1) {
	            isub = iwork[i - 1];
	            jsub = j;
	        } else if (ipvtng == 2) {
	            isub = i;
	            jsub = iwork[j - 1];
	        } else if (ipvtng == 3) {
	            isub = iwork[i - 1];
	            jsub = iwork[j - 1];
	        }

	        // Compute entry and grade it according to igrade
	        if (isub == jsub) {
	            temp = D[isub - 1];
	        } else {
	            temp = dlarnd(idist, iseed);
	        }

	        if (igrade == 1) {
	            temp = temp * dl[isub - 1];
	        } else if (igrade == 2) {
	            temp = temp * dr[jsub - 1];
	        } else if (igrade == 3) {
	            temp = temp * dl[isub - 1] * dr[jsub - 1];
	        } else if ( (igrade == 4) && (isub != jsub)) {
	            temp = temp * dl[isub - 1] / dl[jsub - 1];
	        } else if (igrade == 5) {
	            temp = temp * dl[isub - 1] * dl[jsub - 1];
	        }

	        return temp;
	    } // dlatm2

	    /**
	     * This is the port of the version 3.1 LAPACK auxiliary test routine DLATM3 Original DLATM3 created by Univ. of
	     * Tennessee, Univ. of California Berkeley, and NAG Ltd., November, 2006 dlatm3 returns the (isub, jsub) entry of a
	     * random matrix of dimension (m,n) described by the other parameters. (isub, jsub) is the final position of the
	     * (i,j) entry after pivoting according to ipvtng and iwork. dlatm3 is called by the dlatmr routine in order to
	     * build random test matrices. No error checking is done, because this routine is called in a tight loop by dlatmr
	     * which has already checked the parameters.
	     * 
	     * <p>
	     * Use of dlatm3 differs from dlatm2 in the order in which the random number generator is called to fill in random
	     * matrix entries. With dlatm2, the generator is called to fill in the pivoted matrix columnwise. With dlatm3, the
	     * generator is called to fill in the matrix columnwise, after which it is pivoted. Thus, dlatm3 can be used to
	     * construct random matrices which differ only in their order of rows and/or columns. dlatm2 is used to construct
	     * band matrices while avoiding calling the random number generator for entries outside the band (and therefore
	     * generating random numbers in different orders for different pivot orders).
	     * </p>
	     * 
	     * <p>
	     * The matrix whose (isub, jsub) entry is returned is constructed as follows (this routine only computes one entry):
	     * </p>
	     * 
	     * <p>
	     * If isub is outside (1...m) or jsub is outside (1...n), return zero. (this is convenient for generating matrices
	     * in band format).
	     * </p>
	     * 
	     * <p>
	     * Generate a matrix A with random entries of distribution idist.
	     * </p>
	     * 
	     * <p>
	     * Set the diagonal to D.
	     * </p>
	     * 
	     * <p>
	     * Grade the matrix, if desired, from the left (by dl) and/or from the right (by dr or dl) as specified by igrade.
	     * </p>
	     * 
	     * <p>
	     * Permute, if desired, the rows and/or columns as specified by ipvtng and iwork.
	     * </p>
	     * 
	     * <p>
	     * Band the matrix to have lower bandwidth kl and upper bandwidth ku.
	     * </p>
	     * 
	     * <p>
	     * Set random entries to zero as specified by sparse.
	     * </p>
	     * 
	     * @param m input int Number of rows of matrix
	     * @param n input int Number of columns of matrix.
	     * @param i input int Row of unpivoted entry to be returned.
	     * @param j input int Column of unpivoted entry to be returned.
	     * @param isub output int[] Row of pivoted entry to be returned.
	     * @param jsub output int[] Column of pivoted entry to be returned.
	     * @param kl input int Lower bandwidth
	     * @param ku input int Upper bandwidth
	     * @param idist input int On entry, idist specifies the type of distribution to be used to generate a random matrix.
	     *            1 => uniform (0,1) 2 => uniform (-1,1) 3 => normal (0,1)
	     * @param iseed input/output int[] of dimension 4 Seed for random number generator. Changed on exit.
	     * @param D input double[] of dimension min(i,j). Diagonal entries of matrix.
	     * @param igrade input int Specifies the grading of the matrix as follows: 0 => no grading 1 => matrix premultiplied
	     *            by diag (dl) 2 => matrix postmultiplied by diag (dr) 3 => matrix premultiplied by diag (dl) and
	     *            postmultiplied by diag (dr) 4 => matrix premultiplied by diag (dl) and postmultiplied by inv(diag(dl))
	     *            5 => matrix premultiplied by diag(dl) and postmultiplied by diag(dl)
	     * @param dl input double[] of dimension i or j, as appropriate Left scale factors for grading matrix.
	     * @param dr input double[] of dimension i or j, as appropriate Right scale factors for grading matrix.
	     * @param ipvtng input int On entry specifies the pivoting permutations as follows: 0 => none 1 => row pivoting 2 =>
	     *            column pivoting 3 => full pivoting, i.e., on both sides
	     * @param iwork input int[] of dimension i or j, as appropriate This array specifies the permutation used. The row
	     *            (or column) originally in position k is in position iwork[k-1] after pivoting. This differs from iwork
	     *            for dlatm2.
	     * @param sparse input double between 0.0 and 1.0. On entry specifies the sparsity of the matrix if sparse matrix is
	     *            to be generated. A uniform (0,1) random number x is generated and compared to sparse; if x is larger
	     *            the matrix entry is unchanged and if x is smaller the entry is set to zero. Thus on the average a
	     *            fraction sparse of the entries will be set to zero.
	     * 
	     * @return double
	     */
	    private double dlatm3(final int m, final int n, final int i, final int j, final int[] isub, final int[] jsub,
	            final int kl, final int ku, final int idist, final int[] iseed, final double[] D, final int igrade,
	            final double[] dl, final double[] dr, final int ipvtng, final int[] iwork, final double sparse) {
	        double temp;

	        // Check for i and j in range
	        if ( (i < 1) || (i > m) || (j < 1) || (j > n)) {
	            isub[0] = i;
	            jsub[0] = j;

	            return 0.0;
	        }

	        // Compute subscripts depending on ipvtng
	        if (ipvtng == 0) {
	            isub[0] = i;
	            jsub[0] = j;
	        } else if (ipvtng == 1) {
	            isub[0] = iwork[i - 1];
	            jsub[0] = j;
	        } else if (ipvtng == 2) {
	            isub[0] = i;
	            jsub[0] = iwork[j - 1];
	        } else if (ipvtng == 3) {
	            isub[0] = iwork[i - 1];
	            jsub[0] = iwork[j - 1];
	        }

	        // Check for banding
	        if ( (jsub[0] > (isub[0] + ku)) || (jsub[0] < (isub[0] - kl))) {
	            return 0.0;
	        }

	        // Check for sparsity
	        if (sparse > 0.0) {

	            if (dlaran(iseed) < sparse) {
	                return 0.0;
	            }
	        }

	        // Compute entry and grade it according it according to igrade
	        if (i == j) {
	            temp = D[i - 1];
	        } else {
	            temp = dlarnd(idist, iseed);
	        }

	        if (igrade == 1) {
	            temp = temp * dl[i - 1];
	        } else if (igrade == 2) {
	            temp = temp * dr[j - 1];
	        } else if (igrade == 3) {
	            temp = temp * dl[i - 1] * dr[j - 1];
	        } else if ( (igrade == 4) && (i != j)) {
	            temp = temp * dl[i - 1] / dl[j - 1];
	        } else if (igrade == 5) {
	            temp = temp * dl[i - 1] * dl[j - 1];
	        }

	        return temp;
	    } // dlatm3

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary test routine DLATM4 Original DLATM4 created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlatm4 generates basic square matrices, which may
	     * later be multiplied by others in order to produce test matrices. It is intended mainly to be used to test the
	     * generalized eigenvalue routines.
	     * 
	     * <p>
	     * It first generates the diagonal and (possibly) subdiagonal, according to the value of itype, nz1, nz2, isign,
	     * amagn, and rcond. It then fills in the upper triangle with random numbers, if triang is non-zero.
	     * </p>
	     * 
	     * @param itype input int The "type" of matrix on the diagonal and sub-diagonal. If itype < 0, then type abs(itype)
	     *            is generated and then swapped end for end (A[i][j] := A'([n-1-j][n-1-i].) See also the description of
	     *            amagn and isign. Special types: = 0: the zero matrix. = 1: the identity = 2: a transposed Jordan
	     *            block. = 3: If n is odd, then a k+1 by k+1 transposed Jordan block followed by a k by k identity
	     *            block, where k = (n-1)/2. If n is even, then k = (n-2)/2, and a zero diagona entry is tacked onto the
	     *            end.
	     * 
	     *            <p>
	     *            Diagonal types. The diagonal consists of nz1 zeros, then k = n-nz1-nz2 nonzeros. The subdiagonal is
	     *            zero. itype specifies the nonzero diagonal entries as follows: = 4: 1, ..., k = 5: 1, rcond, ...,
	     *            rcond = 6: 1, ..., 1, rcond = 7: 1, a, a**2, ..., a**(k-1) = rcond = 8: 1, 1-d, 1-2*d, ..., 1-(k-1)*d
	     *            = rcond = 9: random numbers chosen from (rcond,1) = 10: random numbers with distribution idist (see
	     *            dlarnd.)
	     *            </p>
	     * @param n input int The order of the matrix.
	     * @param nz1 input int If abs(itype) > 3, then the first nz1 diagonal entries will be zero.
	     * @param nz2 input int If the abs(itype) > 3, the the last nz2 diagonal entries will be zero.
	     * @param isign input int = 0: The sign of the diagonal and subdiagonal entries will be left unchanged. = 1: The
	     *            diagonal and subdiagonal entries will have their sign changed at random. = 2: If itype is 2 or 3, then
	     *            the same as isign = 1. Otherwise, with probability 0.5, even-odd pairs of diagonal entries
	     *            A[2*j][2*j], A[2*j+1][2*j+1] will be converted to a 2 by 2 block by pre- and post-multiplying by
	     *            distinct random orthogonal rotations. The remaining diagonal entries will have their sign changed at
	     *            random.
	     * @param amagn input double The diagonal and subdiagonal entries will be multiplied by amagn.
	     * @param rcond input double If abs(itype) > 4, then the smallest diagonal entry will be rcond. rcond must be
	     *            between 0 and 1.
	     * @param triang input double The entries above the diagonal will be random numbers with magnitude bounded by triang
	     *            (i.e., random numbers multiplied by triang.)
	     * @param idist input int Specifies the type of distribution to be used to generate a random matrix. = 1: uniform
	     *            (0, 1) = 2: uniform (-1, 1) = 3: normal (0, 1)
	     * @param iseed (input/output) int[] of dimension 4 On entry iseed specifies the seed of the random number
	     *            generator. The values of iseed are changed on exit, and can be used in the next call to dlatm4 to
	     *            continue the same random number sequence. Note: iseed[3] should be odd, for the random number
	     *            generator used at present.
	     * @param A output double[][] of dimension (lda,n) Array to be computed.
	     * @param lda input int Leading dimension of A. Must be at least 1 and at least n.
	     */
	    private void dlatm4(final int itype, final int n, final int nz1, final int nz2, final int isign,
	            final double amagn, final double rcond, final double triang, final int idist, final int[] iseed,
	            final double[][] A, final int lda) {
	        int i;
	        int ioff;
	        int isdb;
	        int isde;
	        int jc;
	        int jd;
	        int jr;
	        int k;
	        int kbeg;
	        int kend;
	        int klen;
	        double alpha;
	        double cl;
	        double cr;
	        double safmin;
	        double sl;
	        double sr;
	        double sv1;
	        double sv2;
	        double temp;

	        if (n <= 0) {
	            return;
	        }

	        dlaset('F', n, n, 0.0, 0.0, A, lda);

	        // Insure a correct iseed
	        if ( (iseed[3] % 2) != 1) {
	            iseed[3] = iseed[3] + 1;
	        }

	        // Compute diagonal and subdiagonal according to itype, nz1, nz2, and
	        // rcond
	        if (itype != 0) {

	            if (Math.abs(itype) >= 4) {
	                kbeg = Math.max(1, Math.min(n, nz1 + 1));
	                kend = Math.max(kbeg, Math.min(n, n - nz2));
	                klen = kend + 1 - kbeg;
	            } // if (Math.abs(itype) >= 4)
	            else { // Math.abs(itype) < 4
	                kbeg = 1;
	                kend = n;
	                klen = n;
	            } // else Math.abs(itype) < 4

	            isdb = 1;
	            isde = 0;

	            switch (Math.abs(itype)) {

	                case 1: // Identity
	                    for (jd = 0; jd < n; jd++) {
	                        A[jd][jd] = 1.0;
	                    }

	                    break;

	                case 2: // Transposed Jordan block
	                    for (jd = 0; jd < (n - 1); jd++) {
	                        A[jd + 1][jd] = 1.0;
	                    }

	                    isdb = 1;
	                    isde = n - 1;
	                    break;

	                case 3: // Transposed Jordan block , followed by identity.
	                    k = (n - 1) / 2;
	                    for (jd = 0; jd < k; jd++) {
	                        A[jd + 1][jd] = 1.0;
	                    }

	                    isdb = 1;
	                    isde = k;
	                    for (jd = k + 1; jd <= (2 * k); jd++) {
	                        A[jd][jd] = 1.0;
	                    }

	                    break;

	                case 4: // 1, ..., k
	                    for (jd = kbeg; jd <= kend; jd++) {
	                        A[jd - 1][jd - 1] = (double) (jd - nz1);
	                    }

	                    break;

	                case 5: // One large D value
	                    for (jd = kbeg; jd < kend; jd++) {
	                        A[jd][jd] = rcond;
	                    }

	                    A[kbeg - 1][kbeg - 1] = 1.0;
	                    break;

	                case 6: // One small D value
	                    for (jd = kbeg - 1; jd < (kend - 1); jd++) {
	                        A[jd][jd] = 1.0;
	                    }

	                    A[kend - 1][kend - 1] = rcond;
	                    break;

	                case 7: // Exponentially distributed D values
	                    A[kbeg - 1][kbeg - 1] = 1.0;
	                    if (klen > 1) {
	                        alpha = Math.pow(rcond, 1.0 / (klen - 1));

	                        for (i = 2; i <= klen; i++) {
	                            A[nz1 + i - 1][nz1 + i - 1] = Math.pow(alpha, (double) (i - 1));
	                        }
	                    } // if (klen > 1)

	                    break;

	                case 8: // Arithmetically distributed D values
	                    A[kbeg - 1][kbeg - 1] = 1.0;
	                    if (klen > 1) {
	                        alpha = (1.0 - rcond) / (klen - 1);

	                        for (i = 2; i <= klen; i++) {
	                            A[nz1 + i - 1][nz1 + i - 1] = ( (klen - i) * alpha) + rcond;
	                        } // for (i = 2; i <= klen; i++)
	                    } // if (klen > 1)

	                    break;

	                case 9: // Randomly distributed D values on (rcond, 1)
	                    alpha = Math.log(rcond);
	                    for (jd = kbeg - 1; jd < kend; jd++) {
	                        A[jd][jd] = Math.exp(alpha * dlaran(iseed));
	                    }

	                    break;

	                case 10: // Randomly distributed D values from dist
	                    for (jd = kbeg - 1; jd < kend; jd++) {
	                        A[jd][jd] = dlarnd(idist, iseed);
	                    }

	                    break;

	                default:
	            } // switch(Math.abs(itype))

	            // Scale by amagn
	            for (jd = kbeg - 1; jd < kend; jd++) {
	                A[jd][jd] = amagn * A[jd][jd];
	            }

	            for (jd = isdb - 1; jd < isde; jd++) {
	                A[jd + 1][jd] = amagn * A[jd + 1][jd];
	            }

	            // If isign = 1 or 2, assign random signs to diagonal and subdiagonal
	            if (isign > 0) {

	                for (jd = kbeg - 1; jd < kend; jd++) {

	                    if (A[jd][jd] != 0.0) {

	                        if (dlaran(iseed) > 0.5) {
	                            A[jd][jd] = -A[jd][jd];
	                        } // if (dlaran(iseed} > 0.5)
	                    } // if (A[jd][jd] != 0.0)
	                } // for (jd = kbeg-1; jd < kend; jd++)

	                for (jd = isdb - 1; jd < isde; jd++) {

	                    if (A[jd + 1][jd] != 0.0) {

	                        if (dlaran(iseed) > 0.5) {
	                            A[jd + 1][jd] = -A[jd + 1][jd];
	                        } // if (dlaran(iseed) > 0.5)
	                    } // if (A[jd+1][jd] != 0.0)
	                } // for (jd = isdb-1; jd < isde; jd++)
	            } // if (isign > 0)

	            // Reverse if itype < 0
	            if (itype < 0) {

	                for (jd = kbeg; jd <= ( (kbeg + kend - 1) / 2); jd++) {
	                    temp = A[jd - 1][jd - 1];
	                    A[jd - 1][jd - 1] = A[kbeg + kend - jd - 1][kbeg + kend - jd - 1];
	                    A[kbeg + kend - jd - 1][kbeg + kend - jd - 1] = temp;
	                } // for (jd = kbeg; jd <= (kbeg+kend-1)/2; jd++)

	                for (jd = 1; jd <= ( (n - 1) / 2); jd++) {
	                    temp = A[jd][jd - 1];
	                    A[jd][jd - 1] = A[n - jd][n - 1 - jd];
	                    A[n - jd][n - 1 - jd] = temp;
	                } // for (jd = 1; jd <= (n-1)/2; jd++)
	            } // if (itype < 0)

	            // If isign = 2 and no subdiagonals already, then apply random
	            // rotations to make 2 by 2 blocks
	            if ( (isign == 2) && (itype != 2) && (itype != 3)) {
	                safmin = dlamch('S');

	                for (jd = kbeg - 1; jd < (kend - 1); jd += 2) {

	                    if (dlaran(iseed) > 0.5) {

	                        // Rotation on left
	                        cl = (2.0 * dlaran(iseed)) - 1.0;
	                        sl = (2.0 * dlaran(iseed)) - 1.0;
	                        temp = 1.0 / Math.max(safmin, Math.sqrt( (cl * cl) + (sl * sl)));
	                        cl = cl * temp;
	                        sl = sl * temp;

	                        // Rotation on right
	                        cr = (2.0 * dlaran(iseed)) - 1.0;
	                        sr = (2.0 * dlaran(iseed)) - 1.0;
	                        temp = 1.0 / Math.max(safmin, Math.sqrt( (cr * cr) + (sr * sr)));
	                        cr = cr * temp;
	                        sr = sr * temp;

	                        // Apply
	                        sv1 = A[jd][jd];
	                        sv2 = A[jd + 1][jd + 1];
	                        A[jd][jd] = (cl * cr * sv1) + (sl * sr * sv2);
	                        A[jd + 1][jd] = ( -sl * cr * sv1) + (cl * sr * sv2);
	                        A[jd][jd + 1] = ( -cl * sr * sv1) + (sl * cr * sv2);
	                        A[jd + 1][jd + 1] = (sl * sr * sv1) + (cl * cr * sv2);
	                    } // if (dlaran(iseed) > 0.5)
	                } // for (jd = kbeg-1; jd < kend-1; jd += 2)
	            } // if ((isign == 2) && (itype != 2) && (itype != 3))
	        } // if (itype != 0)

	        // Fill in upper triangle (except for 2 by 2 blocks)
	        if (triang != 0.0) {

	            if ( (isign != 2) || (itype == 2) || (itype == 3)) {
	                ioff = 1;
	            } // if ((isign != 2) || (itype == 2) || (itype == 3))
	            else {
	                ioff = 2;

	                for (jr = 0; jr < (n - 1); jr++) {

	                    if (A[jr + 1][jr] == 0.0) {
	                        A[jr][jr + 1] = triang * dlarnd(idist, iseed);
	                    } // if (A[jr+1][jr] == 0.0)
	                } // for (jr = 0; jr < n-1; jr++)
	            } // else

	            for (jc = 1; jc < n; jc++) {

	                for (jr = 0; jr <= (jc - ioff); jr++) {
	                    A[jr][jc] = triang * dlarnd(idist, iseed);
	                }
	            } // for (jc = 1; jc < n; jc++)
	        } // if (triang != 0.0)

	        return;
	    } // dlatm4

	    /**
	     * This is a port of version 3.1 LAPACK test routine DLATMR Original DLATMR created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dlatmr generates random matrices of various types for testing
	     * LAPACK programs. dlatmr operates by applying the following sequence of operations: 1.) Generate a matrix A with
	     * random entries of distribution dist which is symmetric if sym = 'S' and nonsymmetric if sym = 'N'. 2.) Set the
	     * diagonal to D, where D may be input or computed according to mode, cond, dmax, and rsign as described below. 3.)
	     * Grade the matrix, if desired, from the left and/or right as specified by grade. The inputs dl, model, condl, dr,
	     * moder, and condr also determine the grading as described below. 4.) Permute, if desired, the rows and/or columns
	     * as specified by pivtng and ipivot. 5.) Set random entries to zero, if desired, to get a random sparse matrix as
	     * specified by sparse. 6.) Make A a band matrix, if desired, by zeroing out the matrix outside a band of lower
	     * bandwidth kl and upper bandwidth ku. 7.) Scale A, if desired, to have maximum entry anorm 8.) Pack the matrix if
	     * desired. Options specified by pack are: no packing, zero out upper half (if symmetric), zero out lower half (if
	     * symmetric), store the upper half columnwise (if symmetric or square upper triangular), store the lower half
	     * columnwise (if symmetric or square lower triangular), same as upper half rowwise if symmetric, store the lower
	     * triangle in banded format (if symmetric), store the upper triangle if banded format (if symmetric), and store the
	     * entire matrix in banded format
	     * 
	     * <p>
	     * Note: If two calls to dlatmr differ only in the pack parameter, they will generate mathematically equivalent
	     * matrices.
	     * </p>
	     * 
	     * <p>
	     * If two calls to dlatmr both have full bandwidth (kl = m-1 and ku = n-1), and differ only in the pivtng and pack
	     * parameters, then the matrices generated will differ only in the order of the rows and/or columns, and otherwise
	     * contain the same data. This consistency cannot be and is not maintained with less than full bandwidth.
	     * </p>
	     * 
	     * @param m input int Number of rows of A.
	     * @param n input int Number of columns of A.
	     * @param dist input char On entry, dist specifies the type of distribution to be used to generate a random matrix.
	     *            'U' => uniform(0,1) ('U' for uniform) 'S' => uniform(-1,1) ('S' for symmetric) 'N' => normal(0,1) ('N'
	     *            for normal)
	     * @param iseed input/output int[] of dimension 4 On entry iseed specifies the seed of the random number generator.
	     *            They should lie between 0 and 4095 inclusive, and iseed[3] should be odd. The random number generator
	     *            uses a linear congruential sequence limited to small integers, and so should produce machine
	     *            independent random numbers. The values of iseed are changed on exit, and can be used in the next call
	     *            to dlatmr to continue the same random number sequence.
	     * @param sym input char If sym = 'S' or 'H', generated matrix is symmetric. If sym = 'N', generated matrix is
	     *            nonsymmetric.
	     * @param D (input/output) double[] of dimension (min(m,n)) On entry this array specifies the diagonal entries of
	     *            the diagonal of A. D may either be specified on entry, or set according to mode and cond as described
	     *            below. May be changed on exit if mode is nonzero.
	     * @param mode input int On entry describes how D is to be used: = 0 means use D as input = 1 sets D[0] = 1 and
	     *            D[1:n-1] = 1.0/cond = 2 sets D[0:n-2] = 1 and D[n-1] = 1.0/cond = 3 sets D[i] = cond**(-(i)/(n-1)) = 4
	     *            sets D[i] = 1 - (i)/(n-1)*(1 - 1/cond) = 5 sets D to random numbers in the range (1/cond, 1) such that
	     *            their logarithms are uniformly distributed. = 6 sets D to random numbers from the same distribution as
	     *            the rest of the matrix. < 0 has the same meaning as abs(mode), except that the order of the elements
	     *            of D is reversed. Thus, if mode is positive, D has entries ranging from 1 to 1/cond, and if negative,
	     *            from 1/cond to 1.
	     * @param cond input double On entry, used as described under mode above. If used, it must be >= 1.
	     * @param dmax input double If mode is neither -6, 0, nor 6, the diagonal is scaled by dmax/max(abs(D[i])), so that
	     *            maximum absolute entry of diagonal is abs(dmax). If dmax is negative (or zero), diagonal will be
	     *            scaled by a negative number (or zero).
	     * @param rsign input char If mode is neither -6, 0, nor 6, specifies sign of diagonal as follows: 'T' => diagonal
	     *            entries are multiplied by 1 or -1 with probability 0.5. 'F' => diagonal unchanged
	     * @param grade input char Specifies grading of matrix as follows: 'N' => no grading 'L' => matrix premultiplied by
	     *            diag(dl) (only if matrix nonsymmetric) 'R' => matrix postmultiplied by diag(dr) (only if matrix
	     *            nonsymmetric) 'B' => matrix premultiplied by diag(dl) and postmultiplied by diag(dr) (only if matrix
	     *            nonsymmetric) 'S' or 'H' => matrix premultiplied by diag(dl) and postmultiplied by diag(dl) ('S' for
	     *            symmetric, or 'H' for Hermitian) 'E' => matrix premultiplied for diag(dl) and postmultiplied by
	     *            inv(diag(dl)) ( 'E' for eigenvalue invariance) (only if matrix nonsymmetric) Note: If grade = 'E',
	     *            then m must equal n.
	     * @param dl input/output double[] of dimension m If model = 0, then on entry this array specifies the diagonal
	     *            entries of a diagonal matrix used as described under grade above. If model is not zero, then dl will
	     *            be set according to model and condl, analagous to the way D is set according to mode and cond (except
	     *            that there is no dmax parameter for dl). If grade = 'E', then dl cannot have zero entries. Not
	     *            referenced if grade = 'N' or 'R'.
	     * @param model input int This specifies how the diagonal array dl is to be computed, just as mode specifies how D
	     *            is to be computed.
	     * @param condl input double When model is not zero, this specifies the condition number of the computed dl.
	     * @param dr input/output double[] of dimension n. If moder = 0, then on entry this array specifies the diaognal
	     *            entries of a diagonal matrix used as described under grade above. If moder is not zero, then dr will
	     *            be set according to moder and condr, analagous to the way D is set according to mode and cond (except
	     *            that there is no dmax parameter for dr). Not referenced if grade = 'N', 'L', 'H', 'S', or 'E'.
	     * @param moder input int This specifies how the diagonal array dr is to be computed, just as mode specifies how D
	     *            is to be computed.
	     * @param condr input double While moder is not zero, this specifies the condition number of the computed dr.
	     * @param pivtng input char On entry specifies the pivoting permutations as follows: 'N' or ' ' => none 'L' => left
	     *            or row pivoting (matrix must be nonsymmetric). 'R' => right or column pivoting (matrix must be
	     *            nonsymmetric). 'B' or 'F' => both or full pivoting, i.e., on both sides. In this case, m must equal
	     *            n.]
	     * 
	     *            If two calls to dlatmr both have full bandwidth (kl = m-1 and ku = n-1), and differ only in the pivtng
	     *            and pack parameters, then the matrices generated will differ only in the order of the rows and/or the
	     *            columns, and otherwise contain the same data. This consistency cannot be maintained with less than
	     *            full bandwidth.
	     * @param ipivot input int[] of dimension m or n. This array specifies the permutation used. After the basic matrix
	     *            is generated, the rows, columns, or both are permuted. If, say, row pivoting is selected, dlatmr
	     *            starts with the *last* row and interchanges the m-th and ipivot(m)-th rows, then moves to the
	     *            next-to-last row, interchanging the (m-1)-th and the ipivot(m-1)-th rows, and so on. In terms of
	     *            "2-cycles", the permutation is (1 ipivot[0]) (2 ipivot[1]) ... (m ipivot[m-1]) where the rightmost
	     *            cycle is applied first. This is the *inverse* of the effect of pivoting in LINPACK. The idea is that
	     *            factoring (with pivoting) an identity matrix which has been inverse-pivoted in this way should result
	     *            in a pivot vector identical to ipivot. Not referenced if pivtng = 'N'.
	     * @param kl input int On entry, specifies the lower bandwidth of the matrix. For example, kl = 0 implies upper
	     *            triangular, kl = 1 implies upper Hessenberg, and kl at least m-1 implies the matrix is not banded.
	     *            Must equal ku if matrix is symmetric.
	     * @param ku input int On entry specifies the upper bandwidth of the matrix. For example, ku = 0 implies lower
	     *            triangular, ku = 1 implies lower Hessenberg, and ku at least n-1 implies the matrix is not banded.
	     *            Must equal kl if the matrix is symmetric.
	     * @param sparse input double On entry specifies the sparsity of the matrix if a sparse matrix is to be generated.
	     *            sparse should lie between 0 and 1. To generate a sparse matrix, for each matrix entry a uniform (0,1)
	     *            random number x is generated and compared to sparse; if x is larger the matrix entry is unchanged and
	     *            if x is smaller the entry is set to zero. Thus on average a fraction sparse of the entries will be set
	     *            to zero.
	     * @param anorm input double On entry specifies the maximum entry of output matrix (output matrix will be multiplied
	     *            by a constant so that its largest absolute entry equals anorm) if anorm is nonnegative. If anorm is
	     *            negative, no scaling is done.
	     * @param pack input char On entry specifies packing of matrix as follows: 'N' => no packing 'U' => zero out all
	     *            subdiagonal entries (if symmetric) 'L' => zero out all superdiagonal entries (if symmetric) 'C' =>
	     *            store the upper triangle columnwise (only if matrix symmetric or square upper triangular) 'R' => store
	     *            the lower triangle columnwise (only if matrix symmetric or square lower triangular) (same as upper
	     *            half rowwise if symmetric) 'B' => store the lower triangle in band storage scheme (only if matrix
	     *            symmetric) 'Q' => store the upper triangle in band storage scheme (only if matrix symmetric) 'Z' =>
	     *            store the entire matrix in band storage scheme (pivoting can be provided for by using this option to
	     *            store A in the trailing rows of the allocated storage)
	     * 
	     *            Using these options, the various LAPACK packed and banded storage schemes can be obtained: GB - use
	     *            'Z' PB, SB, or TB - use 'B' or 'Q' PP, SP, or TP - use 'C' or 'R'
	     * 
	     *            If two calls to dlatmr differ only in the pack parameter, they will generate mathematically equivalent
	     *            matrices.
	     * @param A output double[][] of dimension (lda, n) On exit A is the desired test matrix. Only those entries of A
	     *            which are significant on output will be referenced (even if A is in packed or band storage format).
	     *            The 'unoccupied corners' of A in band format will be zeroed out.
	     * @param lda input int On entry lda specifies the first dimension of A as declared in the calling program. If pack
	     *            = 'N', 'U', or 'L', lda must be at least max(1,m). If pack = 'C' or 'R', lda must be at least 1. If
	     *            pack = 'B' or 'Q', lda must be at least min (ku+1,n). If pack = 'Z', lda must be at least kuu+kll+1,
	     *            where kuu = min(ku,n-1) and kll = min(kl,n-1).
	     * @param iwork workspace int[] of dimension m or n Not referenced if pivtng = 'N'.
	     * @param info output int[] Error parameter on exit: 0 => normal return -1 => m negative or unequal to n and sym =
	     *            'S' or 'H' -2 => n negative -3 => dist illegal string -5 => sym illegal string -7 => mode not in range
	     *            -6 to 6 -8 => cond less than 1.0, and mode neither -6, 0, nor 6 -10 => mode neither -6, 0, nor 6 and
	     *            rsign illegal string -11 => grade illegal string, or grade = 'E' and m not equal to n, or grade = 'L',
	     *            'R', 'B', or 'E', and sym = 'S' or 'H' -12 => grade = 'E' and dl contains zero -13 => model not in
	     *            range -6 to 6 and grade = 'L', 'B', 'H', 'S', or 'E' -14 => condl less than 1.0, grade = 'L', 'B',
	     *            'H', 'S', or 'E', and model neither -6, 0, nor 6. -16 => moder not in range -6 to 6 and grade = 'R' or
	     *            'B' -17 => condr less than 1.0, grade = 'R' or 'B', and moder neither -6, 0, nor 6. -18 => pivtng
	     *            illegal string, or pivtng = 'B' or 'F' and m not equal to n, or pivtng = 'L' or 'R' and sym = 'S' or
	     *            'H'. -19 => ipivot contains out of range number and pivtng not equal to 'N' -20 => kl negative -21 =>
	     *            ku negative, or sym = 'S' or 'H' and ku not equal to kl -22 => sparse not in range 0 to 1. -24 => pack
	     *            illegal string, or pack = 'U', 'L', 'B', or 'Q' and sym = 'N', or pack = 'C' and sym = 'N' and either
	     *            kl not equal to 0 or n not equal to m, or pack = 'R' and sym = 'N', and either ku not equal to 0 or n
	     *            not equal to m. -26 => lda too small 1 => Error return from dlatm1 (computing D) 2 => Cannot scale
	     *            diagonal to dmax (max. entry is 0) 3 => Error return from dlatm1 (computing dl) 4 => Error return form
	     *            dlatm1 (computing dr) 5 => anorm is positive, but matrix, constructed prior to attempting to scale it
	     *            to have norm anorm, is zero.
	     */
	    private void dlatmr(final int m, final int n, final char dist, final int[] iseed, final char sym, final double[] D,
	            final int mode, final double cond, final double dmax, final char rsign, final char grade,
	            final double[] dl, final int model, final double condl, final double[] dr, final int moder,
	            final double condr, final char pivtng, final int[] ipivot, final int kl, final int ku, final double sparse,
	            final double anorm, final char pack, final double[][] A, final int lda, final int[] iwork, final int[] info) {
	        boolean badpvt;
	        boolean dzero;
	        boolean fulbnd;
	        int i;
	        int idist;
	        int igrade;
	        int iisub;
	        int ipack;
	        int ipvtng;
	        int irsign;
	        final int[] isub = new int[1];
	        int isym;
	        int j;
	        int jjsub;
	        final int[] jsub = new int[1];
	        int k;
	        int kll;
	        int kuu;
	        int mnmin;
	        int mnsub;
	        int mxsub;
	        int npvts = 0;
	        double alpha;
	        double onorm = 0.0;
	        double temp;
	        final double[] tempa = new double[1];
	        double[] ap = null;

	        // Decode and test the input parameters. Initialize flags & seed.
	        info[0] = 0;

	        // Quick return if possible
	        if ( (m == 0) || (n == 0)) {
	            return;
	        }

	        // Decode dist
	        if ( (dist == 'U') || (dist == 'u')) {
	            idist = 1;
	        } else if ( (dist == 'S') || (dist == 's')) {
	            idist = 2;
	        } else if ( (dist == 'N') || (dist == 'n')) {
	            idist = 3;
	        } else {
	            idist = -1;
	        }

	        // Decode sym
	        if ( (sym == 'S') || (sym == 's')) {
	            isym = 0;
	        } else if ( (sym == 'N') || (sym == 'n')) {
	            isym = 1;
	        } else if ( (sym == 'H') || (sym == 'h')) {
	            isym = 0;
	        } else {
	            isym = -1;
	        }

	        // Decode rsign
	        if ( (rsign == 'F') || (rsign == 'f')) {
	            irsign = 0;
	        } else if ( (rsign == 'T') || (rsign == 't')) {
	            irsign = 1;
	        } else {
	            irsign = -1;
	        }

	        // Decode pivtng
	        if ( (pivtng == 'N') || (pivtng == 'n')) {
	            ipvtng = 0;
	        } else if (pivtng == ' ') {
	            ipvtng = 0;
	        } else if ( (pivtng == 'L') || (pivtng == 'l')) {
	            ipvtng = 1;
	            npvts = m;
	        } else if ( (pivtng == 'R') || (pivtng == 'r')) {
	            ipvtng = 2;
	            npvts = n;
	        } else if ( (pivtng == 'B') || (pivtng == 'b')) {
	            ipvtng = 3;
	            npvts = Math.min(n, m);
	        } else if ( (pivtng == 'F') || (pivtng == 'f')) {
	            ipvtng = 3;
	            npvts = Math.min(n, m);
	        } else {
	            ipvtng = -1;
	        }

	        // Decode grade
	        if ( (grade == 'N') || (grade == 'n')) {
	            igrade = 0;
	        } else if ( (grade == 'L') || (grade == 'l')) {
	            igrade = 1;
	        } else if ( (grade == 'R') || (grade == 'r')) {
	            igrade = 2;
	        } else if ( (grade == 'B') || (grade == 'b')) {
	            igrade = 3;
	        } else if ( (grade == 'E') || (grade == 'e')) {
	            igrade = 4;
	        } else if ( (grade == 'H') || (grade == 'h') || (grade == 'S') || (grade == 's')) {
	            igrade = 5;
	        } else {
	            igrade = -1;
	        }

	        // Decode pack
	        if ( (pack == 'N') || (pack == 'n')) {
	            ipack = 0;
	        } else if ( (pack == 'U') || (pack == 'u')) {
	            ipack = 1;
	        } else if ( (pack == 'L') || (pack == 'l')) {
	            ipack = 2;
	        } else if ( (pack == 'C') || (pack == 'c')) {
	            ipack = 3;
	        } else if ( (pack == 'R') || (pack == 'r')) {
	            ipack = 4;
	        } else if ( (pack == 'B') || (pack == 'b')) {
	            ipack = 5;
	        } else if ( (pack == 'Q') || (pack == 'q')) {
	            ipack = 6;
	        } else if ( (pack == 'Z') || (pack == 'z')) {
	            ipack = 7;
	        } else {
	            ipack = -1;
	        }

	        // Set certain internal parameters
	        mnmin = Math.min(m, n);
	        kll = Math.min(kl, m - 1);
	        kuu = Math.min(ku, n - 1);

	        // If inv(dl) is used, check to see if dl has a zero entry.
	        dzero = false;

	        if ( (igrade == 4) && (model == 0)) {

	            for (i = 0; i < m; i++) {

	                if (dl[i] == 0.0) {
	                    dzero = true;
	                }
	            }
	        } // if ((igrade == 4) && (model == 0))

	        // Check values in ipivot
	        badpvt = false;

	        if (ipvtng > 0) {

	            for (j = 0; j < npvts; j++) {

	                if ( (ipivot[j] <= 0) || (ipivot[j] > npvts)) {
	                    badpvt = true;
	                }
	            }
	        } // if (ipvtng > 0)

	        // Set info if an error
	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (m != n) && (isym == 0)) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (idist == -1) {
	            info[0] = -3;
	        } else if (isym == -1) {
	            info[0] = -5;
	        } else if ( (mode < -6) || (mode > 6)) {
	            info[0] = -7;
	        } else if ( (mode != -6) && (mode != 0) && (mode != 6) && (cond < 1.0)) {
	            info[0] = -8;
	        } else if ( (mode != -6) && (mode != 0) && (mode != 6) && (irsign == -1)) {
	            info[0] = -10;
	        } else if ( (igrade == -1) || ( (igrade == 4) && (m != n))
	                || ( ( (igrade >= 1) && (igrade <= 4)) && (isym == 0))) {
	            info[0] = -11;
	        } else if ( (igrade == 4) && dzero) {
	            info[0] = -12;
	        } else if ( ( (igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5))
	                && ( (model < -6) || (model > 6))) {
	            info[0] = -13;
	        } else if ( ( (igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5)) && (model != -6)
	                && (model != 0) && (model != 6) && (condl < 1.0)) {
	            info[0] = -14;
	        } else if ( ( (igrade == 2) || (igrade == 3)) && ( (moder < -6) || (moder > 6))) {
	            info[0] = -16;
	        } else if ( ( (igrade == 2) || (igrade == 3))
	                && ( (moder != -6) && (moder != 0) && (moder != 6) && (condr < 1.0))) {
	            info[0] = -17;
	        } else if ( (ipvtng == -1) || ( (ipvtng == 3) && (m != n))
	                || ( ( (ipvtng == 1) || (ipvtng == 2)) && (isym == 0))) {
	            info[0] = -18;
	        } else if ( (ipvtng != 0) && badpvt) {
	            info[0] = -19;
	        } else if (kl < 0) {
	            info[0] = -20;
	        } else if ( (ku < 0) || ( (isym == 0) && (kl != ku))) {
	            info[0] = -21;
	        } else if ( (sparse < 0.0) || (sparse > 1.0)) {
	            info[0] = -22;
	        } else if ( (ipack == -1) || ( ( (ipack == 1) || (ipack == 2) || (ipack == 5) || (ipack == 6)) && (isym == 1))
	                || ( (ipack == 3) && (isym == 1) && ( (kl != 0) || (m != n)))
	                || ( (ipack == 4) && (isym == 1) && ( (ku != 0) || (m != n)))) {
	            info[0] = -24;
	        } else if ( ( ( (ipack == 0) || (ipack == 1) || (ipack == 2)) && (lda < Math.max(1, m)))
	                || ( ( (ipack == 3) || (ipack == 4)) && (lda < 1))
	                || ( ( (ipack == 5) || (ipack == 6)) && (lda < (kuu + 1)))
	                || ( (ipack == 7) && (lda < (kll + kuu + 1)))) {
	            info[0] = -26;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dlamtr had info[0] = " + info[0]);

	            return;
	        }

	        // Decide if we can pivot consistently
	        fulbnd = false;

	        if ( (kuu == (n - 1)) && (kll == (m - 1))) {
	            fulbnd = true;
	        }

	        // Initialize random number generator
	        for (i = 0; i < 4; i++) {
	            iseed[i] = Math.abs(iseed[i]) % 4096;
	        }

	        iseed[3] = (2 * (iseed[3] / 2)) + 1;

	        // Set up D, dl, and dr, if indicated
	        // Compute D according to cond and mode
	        dlatm1(mode, cond, irsign, idist, iseed, D, mnmin, info);

	        if (info[0] != 0) {
	            info[0] = 1;

	            return;
	        }

	        if ( (mode != 0) && (mode != -6) && (mode != 6)) {

	            // Scale by dmax
	            temp = Math.abs(D[0]);

	            for (i = 1; i < mnmin; i++) {
	                temp = Math.max(temp, Math.abs(D[i]));
	            }

	            if ( (temp == 0.0) && (dmax != 0.0)) {
	                info[0] = 2;

	                return;
	            }

	            if (temp != 0.0) {
	                alpha = dmax / temp;
	            } else {
	                alpha = 1.0;
	            }

	            for (i = 0; i < mnmin; i++) {
	                D[i] = alpha * D[i];
	            }
	        } // if ((mode != 0) && (mode != -6) && (mode != 6))

	        // Compute dl if grading set
	        if ( (igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5)) {
	            dlatm1(model, condl, 0, idist, iseed, dl, m, info);

	            if (info[0] != 0) {
	                info[0] = 3;

	                return;
	            }
	        } // if ((igrade == 1) || (igrade == 3) || (igrade == 4) || (igrade == 5))

	        // Compute dr if grading set
	        if ( (igrade == 2) || (igrade == 3)) {
	            dlatm1(moder, condr, 0, idist, iseed, dr, n, info);

	            if (info[0] != 0) {
	                info[0] = 4;

	                return;
	            }
	        } // if ((igrade == 2) || (igrade == 3))

	        // Generate iwork if pivoting
	        if (ipvtng > 0) {

	            for (i = 1; i <= npvts; i++) {
	                iwork[i - 1] = i;
	            }

	            if (fulbnd) {

	                for (i = 1; i <= npvts; i++) {
	                    k = ipivot[i - 1];
	                    j = iwork[i - 1];
	                    iwork[i - 1] = iwork[k - 1];
	                    iwork[k - 1] = j;
	                }
	            } else {

	                for (i = npvts; i >= 1; i--) {
	                    k = ipivot[i - 1];
	                    j = iwork[i - 1];
	                    iwork[i - 1] = iwork[k - 1];
	                    iwork[k - 1] = j;
	                }
	            }
	        } // if (ipvtng > 0)

	        // Generate matrices for each kind of packing. Always sweep matrix
	        // columnwise (if symmetric, upper half only) so that matrix generated
	        // does not depend on pack.

	        if (fulbnd) {

	            // Use dlatm3 so matrices generated with differing pivoting only
	            // differ only in the order of their rows and/or columns
	            if (ipack == 0) {

	                if (isym == 0) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = 1; i <= j; i++) {
	                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                            A[isub[0] - 1][jsub[0] - 1] = temp;
	                            A[jsub[0] - 1][isub[0] - 1] = temp;
	                        }
	                    }
	                } // if (isym == 0)
	                else if (isym == 1) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = 1; i <= m; i++) {
	                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                            A[isub[0] - 1][jsub[0] - 1] = temp;
	                        }
	                    }
	                } // else if (isym == 1)
	            } // if (ipack == 0)
	            else if (ipack == 1) {

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);
	                        mnsub = Math.min(isub[0], jsub[0]);
	                        mxsub = Math.max(isub[0], jsub[0]);
	                        A[mnsub - 1][mxsub - 1] = temp;

	                        if (mnsub != mxsub) {
	                            A[mxsub - 1][mnsub - 1] = 0.0;
	                        }
	                    }
	                }
	            } // else if (ipack == 1)
	            else if (ipack == 2) {

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);
	                        mnsub = Math.min(isub[0], jsub[0]);
	                        mxsub = Math.max(isub[0], jsub[0]);
	                        A[mxsub - 1][mnsub - 1] = temp;

	                        if (mnsub != mxsub) {
	                            A[mnsub - 1][mxsub - 1] = 0.0;
	                        }
	                    }
	                }
	            } // else if (ipack == 2)
	            else if (ipack == 3) {
	                ap = new double[n * (n + 1) / 2];

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);

	                        // Compute k = location of (isub,jsub) entry in
	                        // packed array
	                        mnsub = Math.min(isub[0], jsub[0]);
	                        mxsub = Math.max(isub[0], jsub[0]);
	                        k = (mxsub * (mxsub - 1) / 2) + mnsub;

	                        // Convert k to (iisub,jjsub) location
	                        jjsub = ( (k - 1) / lda) + 1;
	                        iisub = k - (lda * (jjsub - 1));
	                        A[iisub - 1][jjsub - 1] = temp;
	                        ap[k - 1] = temp;
	                    }
	                }
	            } // else if (ipack == 3)
	            else if (ipack == 4) {
	                ap = new double[n * (n + 1) / 2];

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);

	                        // Compute k = location of (isub,jsub) entry in
	                        // packed array
	                        mnsub = Math.min(isub[0], jsub[0]);
	                        mxsub = Math.max(isub[0], jsub[0]);

	                        if (mnsub == 1) {
	                            k = mxsub;
	                        } else {
	                            k = (n * (n + 1) / 2) - ( (n - mnsub + 1) * (n - mnsub + 2) / 2) + mxsub - mnsub + 1;
	                        }

	                        // Convert k to (iisub,jjsub) location
	                        jjsub = ( (k - 1) / lda) + 1;
	                        iisub = k - (lda * (jjsub - 1));
	                        A[iisub - 1][jjsub - 1] = temp;
	                        ap[k - 1] = temp;
	                    }
	                }
	            } // else if (ipack == 4)
	            else if (ipack == 5) {

	                for (j = 1; j <= n; j++) {

	                    for (i = j - kuu; i <= j; i++) {

	                        if (i < 1) {
	                            A[j - i][i + n - 1] = 0.0;
	                        } else {
	                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                            mnsub = Math.min(isub[0], jsub[0]);
	                            mxsub = Math.max(isub[0], jsub[0]);
	                            A[mxsub - mnsub][mnsub - 1] = temp;
	                        }
	                    }
	                }
	            } // else if (ipack == 5)
	            else if (ipack == 6) {

	                for (j = 1; j <= n; j++) {

	                    for (i = j - kuu; i <= j; i++) {
	                        temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);
	                        mnsub = Math.min(isub[0], jsub[0]);
	                        mxsub = Math.max(isub[0], jsub[0]);
	                        A[mnsub - mxsub + kuu][mxsub - 1] = temp;
	                    }
	                }
	            } // else if (ipack == 6)
	            else if (ipack == 7) {

	                if (isym == 0) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = j - kuu; i <= j; i++) {
	                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                            mnsub = Math.min(isub[0], jsub[0]);
	                            mxsub = Math.max(isub[0], jsub[0]);
	                            A[mnsub - mxsub + kuu][mxsub - 1] = temp;

	                            if (i < 1) {
	                                A[j - i + kuu][i + n - 1] = 0.0;
	                            }

	                            if ( (i >= 1) && (mnsub != mxsub)) {
	                                A[mxsub - mnsub + kuu][mnsub - 1] = temp;
	                            }
	                        }
	                    }
	                } // if (isym == 0)
	                else if (isym == 1) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = j - kuu; i <= (j + kll); i++) {
	                            temp = dlatm3(m, n, i, j, isub, jsub, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                            A[isub[0] - jsub[0] + kuu][jsub[0] - 1] = temp;
	                        }
	                    }
	                } // else if (isym == 1)
	            } // else if (ipack == 7)
	        } // if (fulbnd)
	        else { // not fulbnd

	            // Use dlatm2
	            if (ipack == 0) {

	                if (isym == 0) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = 1; i <= j; i++) {
	                            A[i - 1][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                            A[j - 1][i - 1] = A[i - 1][j - 1];
	                        }
	                    }
	                } // if (isym == 0)
	                else if (isym == 1) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = 1; i <= m; i++) {
	                            A[i - 1][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                        }
	                    }
	                } // else if (isym == 1)
	            } // if (ipack == 0)
	            else if (ipack == 1) {

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        A[i - 1][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);

	                        if (i != j) {
	                            A[j - 1][i - 1] = 0.0;
	                        }
	                    }
	                }
	            } // else if (ipack == 1)
	            else if (ipack == 2) {

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        A[j - 1][i - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng, iwork,
	                                sparse);

	                        if (i != j) {
	                            A[i - 1][j - 1] = 0.0;
	                        }
	                    }
	                }
	            } // else if (ipack == 2)
	            else if (ipack == 3) {
	                ap = new double[n * (n + 1) / 2];
	                isub[0] = 0;
	                jsub[0] = 1;

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {
	                        isub[0] = isub[0] + 1;

	                        if (isub[0] > lda) {
	                            isub[0] = 1;
	                            jsub[0] = jsub[0] + 1;
	                        }

	                        A[isub[0] - 1][jsub[0] - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr,
	                                ipvtng, iwork, sparse);
	                        k = isub[0] + (lda * (jsub[0] - 1));
	                        ap[k - 1] = A[isub[0] - 1][jsub[0] - 1];
	                    }
	                }
	            } // else if (ipack == 3)
	            else if (ipack == 4) {
	                ap = new double[n * (n + 1) / 2];

	                if (isym == 0) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = 1; i <= j; i++) {

	                            // Compute k = location of (i,j) entry in packed
	                            // array
	                            if (i == 1) {
	                                k = j;
	                            } else {
	                                k = (n * (n + 1) / 2) - ( (n - i + 1) * (n - i + 2) / 2) + j - i + 1;
	                            }

	                            // Convert k to (isub,jsub) location
	                            jsub[0] = ( (k - 1) / lda) + 1;
	                            isub[0] = k - (lda * (jsub[0] - 1));
	                            A[isub[0] - 1][jsub[0] - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr,
	                                    ipvtng, iwork, sparse);
	                            ap[k - 1] = A[isub[0] - 1][jsub[0] - 1];
	                        }
	                    }
	                } // if (isym == 0)
	                else { // isym != 0
	                    isub[0] = 0;
	                    jsub[0] = 1;

	                    for (j = 1; j <= n; j++) {

	                        for (i = j; i <= m; i++) {
	                            isub[0] = isub[0] + 1;

	                            if (isub[0] > lda) {
	                                isub[0] = 1;
	                                jsub[0] = jsub[0] + 1;
	                            }

	                            A[isub[0] - 1][jsub[0] - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr,
	                                    ipvtng, iwork, sparse);
	                            k = isub[0] + (lda * (jsub[0] - 1));
	                            ap[k - 1] = A[isub[0] - 1][jsub[0] - 1];
	                        }
	                    }
	                } // else isym != 0
	            } // else if (ipack == 4)
	            else if (ipack == 5) {

	                for (j = 1; j <= n; j++) {

	                    for (i = j - kuu; i <= j; i++) {

	                        if (i < 1) {
	                            A[j - i][i + n - 1] = 0.0;
	                        } else {
	                            A[j - i][i - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                        }
	                    }
	                }
	            } // else if (ipack == 5)
	            else if (ipack == 6) {

	                for (j = 1; j <= n; j++) {

	                    for (i = j - kuu; i <= j; i++) {
	                        A[i - j + kuu][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                iwork, sparse);
	                    }
	                }
	            } // else if (ipack == 6)
	            else if (ipack == 7) {

	                if (isym == 0) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = j - kuu; i <= j; i++) {
	                            A[i - j + kuu][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);

	                            if (i < 1) {
	                                A[j - i + kuu][i + n - 1] = 0.0;
	                            }

	                            if ( (i >= 1) && (i != j)) {
	                                A[j - i + kuu][i - 1] = A[i - j + kuu][j - 1];
	                            }
	                        }
	                    }
	                } // if (isym == 0)
	                else if (isym == 1) {

	                    for (j = 1; j <= n; j++) {

	                        for (i = j - kuu; i <= (j + kll); i++) {
	                            A[i - j + kuu][j - 1] = dlatm2(m, n, i, j, kl, ku, idist, iseed, D, igrade, dl, dr, ipvtng,
	                                    iwork, sparse);
	                        }
	                    }
	                } // else if (isym == 1)
	            } // else if (ipack == 7)
	        } // else not fulbnd

	        // Scaling the norm
	        if (ipack == 0) {
	            onorm = dlange('M', m, n, A, lda, tempa);
	        } else if (ipack == 1) {
	            onorm = dlansy('M', 'U', n, A, lda, tempa);
	        } else if (ipack == 2) {
	            onorm = dlansy('M', 'L', n, A, lda, tempa);
	        } else if (ipack == 3) {
	            onorm = dlansp('M', 'U', n, ap, tempa);
	        } // else if (ipack == 3)
	        else if (ipack == 4) {
	            onorm = dlansp('M', 'L', n, ap, tempa);
	        } // else if (ipack == 4)
	        else if (ipack == 5) {
	            onorm = dlansb('M', 'L', n, kll, A, lda, tempa);
	        } // else if (ipack == 5)
	        else if (ipack == 6) {
	            onorm = dlansb('M', 'U', n, kuu, A, lda, tempa);
	        } // else if (ipack == 6)
	        else if (ipack == 7) {
	            onorm = dlangb('M', n, kll, kuu, A, lda, tempa);
	        } // else if (ipack == 7)

	        if (anorm >= 0.0) {

	            if ( (anorm > 0.0) && (onorm == 0.0)) {

	                // Desired scaling impossible
	                info[0] = 5;

	                return;
	            } else if ( ( (anorm > 1.0) && (onorm < 1.0)) || ( (anorm < 1.0) && (onorm > 1.0))) {

	                // Scale carefully to avoid over / underflow
	                if (ipack <= 2) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i < m; i++) {
	                            A[i][j] = (1.0 / onorm) * A[i][j];
	                            A[i][j] = anorm * A[i][j];
	                        }
	                    }
	                } // if (ipack <= 2)
	                else if ( (ipack == 3) || (ipack == 4)) {

	                    for (i = 0; i < (n * (n + 1) / 2); i++) {
	                        ap[i] = (1.0 / onorm) * ap[i];
	                        ap[i] = anorm * ap[i];
	                    }
	                } // else if ((ipack == 3) || (ipack == 4))
	                else if (ipack >= 5) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i < (kll + kuu + 1); i++) {
	                            A[i][j] = (1.0 / onorm) * A[i][j];
	                            A[i][j] = anorm * A[i][j];
	                        }
	                    }
	                } // else if (ipack >= 5)
	            } // else if (((anorm > 1.0) && (onorm < 1.0)) || ((anorm < 1.0) &&
	            else {

	                // Scale straightforwardly
	                if (ipack <= 2) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i < m; i++) {
	                            A[i][j] = (anorm / onorm) * A[i][j];
	                        }
	                    }
	                } // if (ipack <= 2)
	                else if ( (ipack == 3) || (ipack == 4)) {

	                    for (i = 0; i < (n * (n + 1) / 2); i++) {
	                        ap[i] = (anorm / onorm) * ap[i];
	                    }
	                } // else if ((ipack == 3) || (ipack == 4))
	                else if (ipack >= 5) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i < (kll + kuu + 1); i++) {
	                            A[i][j] = (anorm / onorm) * A[i][j];
	                        }
	                    }
	                } // else if (ipack >= 5)
	            } // else
	        } // if (anorm >= 0.0)

	        if (ipack == 3) {
	            isub[0] = 0;
	            jsub[0] = 1;

	            for (j = 1; j <= n; j++) {

	                for (i = 1; i <= j; i++) {
	                    isub[0] = isub[0] + 1;

	                    if (isub[0] > lda) {
	                        isub[0] = 1;
	                        jsub[0] = jsub[0] + 1;
	                    }

	                    k = isub[0] + (lda * (jsub[0] - 1));
	                    A[isub[0] - 1][jsub[0] - 1] = ap[k - 1];
	                }
	            }
	        } // else if (ipack == 3)
	        else if (ipack == 4) {

	            if (isym == 0) {

	                for (j = 1; j <= n; j++) {

	                    for (i = 1; i <= j; i++) {

	                        // Compute k = location of (i,j) entry in packed
	                        // array
	                        if (i == 1) {
	                            k = j;
	                        } else {
	                            k = (n * (n + 1) / 2) - ( (n - i + 1) * (n - i + 2) / 2) + j - i + 1;
	                        }

	                        // Convert k to (isub,jsub) location
	                        jsub[0] = ( (k - 1) / lda) + 1;
	                        isub[0] = k - (lda * (jsub[0] - 1));
	                        A[isub[0] - 1][jsub[0] - 1] = ap[k - 1];
	                    }
	                }
	            } // if (isym == 0)
	            else { // isym != 0
	                isub[0] = 0;
	                jsub[0] = 1;

	                for (j = 1; j <= n; j++) {

	                    for (i = j; i <= m; i++) {
	                        isub[0] = isub[0] + 1;

	                        if (isub[0] > lda) {
	                            isub[0] = 1;
	                            jsub[0] = jsub[0] + 1;
	                        }

	                        k = isub[0] + (lda * (jsub[0] - 1));
	                        A[isub[0] - 1][jsub[0] - 1] = ap[k - 1];
	                    }
	                }
	            } // else isym != 0
	        } // else if (ipack == 4)
	        return;
	    } // dlatmr

	    /**
	     * This is a port of version 3.1 LAPACK test routine DLATMS Original DLATMS created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dlatms generates random matrices with specified singular values
	     * (or symmetric/hermitian with specified eigenvalues) for testing LAPACK programs.
	     * 
	     * <p>
	     * dlatms operates by applying the following sequence of operations:
	     * </p>
	     * 
	     * <p>
	     * Set the diagonal to D, where D may be input or computed according to mode, cond, dmax, and sym as described
	     * below.
	     * </p>
	     * 
	     * <p>
	     * Generate a matrix with appropriate band structure, by one of two methods:
	     * </p>
	     * 
	     * <p>
	     * Method A: Generate a dense m by n matrix by multiplying D on the left and the right by random unitary matrices,
	     * then:
	     * </p>
	     * 
	     * <p>
	     * Reduce the bandwidth according to kl and ku, using Householder transformations.
	     * </p>
	     * 
	     * <p>
	     * Method B: Convert the bandwidth-0 (i.e., diagonal) matrix to a bandwidth-1 matrix using Givens rotations,
	     * "chasing" out-of-band elements back, much as in QR; then convert the bandwidth-1 to a bandwidth-2 matrix, etc.
	     * Note that for reasonably samll bandwidths (relative to m and n) this requires less storage, as a dense matrix is
	     * not generated. Also, for symmetric matrices, only, one triangle is generated.
	     * </p>
	     * 
	     * <p>
	     * Method A is chosen if the bandwidth is a large fraction of the order of the matrix, and lda is at least m (so a
	     * dense matrix can be stored.) Method B is chosen if the bandwidth is small ( < 1/2 n for symmetric, < .3 n+m for
	     * non-symmetric), or lda is less than m and not less than the bandwidth.
	     * </p>
	     * 
	     * <p>
	     * Pack the matrix if desired. Options specified by pack are: no packing, zero out upper half (if symmetric), zero
	     * out lower half (if symmetric), store the upper half columnwise (if symmetric or upper triangular), store the
	     * lower half columnwise (if symmetric or lower triangular), store the lower triangle in banded format (if symmetric
	     * or lower triangular), store the upper triangle in banded format (if symmetric or upper triangular), and store the
	     * entire matrix in banded format If method B is chosen, and band format is specified, then the matrix will be
	     * generated in the band format, so no repacking will be necessary.
	     * </p>
	     * 
	     * @param m input int The number of rows of A.
	     * @param n input int The number of columns of A.
	     * @param dist input char On entry, dist specifies the type of distribution to be used to generate the random
	     *            eigen-/singular values. 'U' => uniform(0,1) ('U' for uniform) 'S' => uniform(-1,1) ('S' for symmetric)
	     *            'N' => normal(0,1) ('N' for normal)
	     * @param iseed input/output int[] of dimension 4 On entry iseed specifies the seed of the random number generator.
	     *            They should lie between 0 and 4095 inclusive, and iseed[3] should be odd. The random number generator
	     *            uses a linear congruential sequence limited to small integers, and so should produce machine
	     *            independent random numbers. The values of iseed are changed on exit, and can be used in the next call
	     *            to dlatms to continue the same random number sequence. Changed on exit.
	     * @param sym input char If sym = 'S' or 'H', the generated matrix is symmetric, with eigenvalues specified by D,
	     *            cond, mode, and dmax; they may be positive, negative, or zero. If sym = 'P', the generated matrix is
	     *            symmetric, with eigenvalues (= singular values) specified by D, cond, mode, and dmax; they will not be
	     *            negative. If sym = 'N', the generated matrix is nonsymmetric, with singular values specified by D,
	     *            cond, mode, and dmax; they will not be negative.
	     * @param D input/output double[] of dimension (min(m,n)) This array is used to specify the singular values or
	     *            eigenvalues of A (see sym, above.) If mode = 0, then D is assumed to contain the singular/eigenvalues,
	     *            otherwise they will be computed according to mode, cond, and dmax, and placed in D. Modified if mode
	     *            is nonzero.
	     * @param mode input int On entry this describes how the singular/ eigenvalues are to be specified: = 0 means use D
	     *            as input = 1 sets D[0] = 1 and D[1:n-1] = 1.0/cond = 2 sets D[0:n-2] = 1 and D[n-1] = 1.0/cond = 3
	     *            sets D[i] = cond**(-(i)/(n-1)) = 4 sets D[i] = 1 - (i)/(n-1)*(1 - 1/cond) = 5 sets D to random numbers
	     *            in the range (1/cond, 1) such that their logarithms are uniformly distributed = 6 sets D to random
	     *            numbers from same distribution as the rest of the matrix mode < 0 has the same meaning as abs(mode),
	     *            except that the order of the elements of D is reversed. Thus, if mode is positive, D has entries
	     *            ranging from 1 to 1/cond, if negative, from 1/cond to 1. If sym = 'S' or 'H', and mode is neither 0,
	     *            6, nor -6, then the elements of D will also be multiplied by a random sign (1.e., +1 or -1).
	     * @param cond input double On entry, this is used as described under mode above. If used, it must be >= 1.
	     * @param dmax input double If mode is neither -6, 0, nor 6, the contents of D, as computed according to mode and
	     *            cond, will be scaled by dmax/max(abs(D[i])); thus the maximum absolute eigen- or singular value (which
	     *            is to say the norm) will be abs(dmax). Note that dmax need not be positive: if dmax is negative (or
	     *            zero), D will be scaled by a negative number (or zero).
	     * @param kl input int This specifies the lower bandwidth of the matrix. For example, kl = 0 implies upper
	     *            triangular, kl = 1 implies upper Hessenberg, and kl being at least m-1 means that the matrix has full
	     *            lower bandwidth. kl must equal ku if the matrix is symmetric.
	     * @param ku input int This specifies the upper bandwidth of the matrix. For example, ku = 0 implies lower
	     *            triangular, ku = 1 implies lower Hessenberg, and ku being at least n-1 means that the matrix has full
	     *            upper bandwidth. kl must equal ku if the matrix is symmetric.
	     * @param pack input char This specifies packing of the matrix as follows: 'N' => no packing 'U' => zero out all
	     *            subdiagonal entries (if symmetric) 'L' => zero out all superdiagonal entries (if symmetric) 'C' =>
	     *            store the upper triangle columnwise (only if the matrix is symmetric or upper triangular) 'R' => store
	     *            the lower triangle columnwise (only if the matrix is symmetric or lower triangular) 'B' => store the
	     *            lower triangle in band storage scheme (only if matrix symmetric or lower triangular) 'Q' => store the
	     *            upper triangle in band storage scheme (only if matrix symmetric or upper triangular) 'Z' => store the
	     *            entire matrix in band storage scheme (pivoting can be provided for by using this option to store A in
	     *            the trailing rows of the allocated storage)
	     * 
	     *            Using these options, the various LAPACK packed and banded storage schemes can be obtained: GB - use
	     *            'Z' PB, SB, or TB - use 'B' or 'Q' PP, SP, or TP - use 'C' or 'R' If two calls to dlatms differ only
	     *            in the pack parameter, they will generate mathematically equivalent matrices
	     * @param A input/output double[][] of dimension (lda,n) On exit A is the desired test matrix. A is first generated
	     *            in full (unpacked) form, and then packed, if so specified by pack. Thus, the first m elements of the
	     *            first n columns will always be modified. If pack specifies a packed or banded storage scheme, all lda
	     *            elements of the first n columns will be modified; the elements of the array which do not correspond to
	     *            elements of the generated matrix are set to zero.
	     * @param lda input int lda specifies the first dimension of A as declared in the calling program. If pack = 'N',
	     *            'U', 'L', 'C', or 'R', then lda must be at least m. If pack = 'B' or 'Q', then lda must be at least
	     *            min(kl,m-1) (which is equal to min(ku,n-1)). If pack = 'Z', lda must be large enough to hold the
	     *            packed array: min(ku,n-1) + min(kl,m-1) + 1.
	     * @param work workspace double[] of dimension (3*max(n,m))
	     * @param info output int[] Error code. On exit, info[0] will be set to one of the following values: 0 => normal
	     *            return -1 => m negative or unequal to n and sym = 'S', 'H', or 'P' -2 => n negative -3 => dist illegal
	     *            string -5 => sym illegal string -7 => mode not in range -6 to 6 -8 => cond less than 1.0, and mode
	     *            neither -6, 0, nor 6 -10 => kl negative -11 => ku negative, or sym = 'S' or 'H' and ku not equal to kl
	     *            -12 => pack illegal string, or pack = 'U' or 'L', and sym = 'N'; or pack = 'C' or 'Q' and sym = 'N'
	     *            and kl is not zero; or pack = 'R' or 'B' and sym = 'N' and ku is not zero; or pack = 'U', 'L', 'C',
	     *            'R', 'B', or 'Q' and m != n. -14 => lda is less than m, or pack = 'Z' and lda is less than min(ku,n-1)
	     *            + min(kl,m-1) + 1. 1 => Error return from dlatm1 2 => Cannot scale to dmax (maximum singular value is
	     *            0) 3 => Error return from dlagge or dlagsy
	     */
	    private void dlatms(final int m, final int n, final char dist, final int[] iseed, final char sym, final double[] D,
	            final int mode, final double cond, final double dmax, final int kl, final int ku, final char pack,
	            final double[][] A, final int lda, final double[] work, final int[] info) {
	        boolean givens;
	        boolean ilextr;
	        boolean iltemp;
	        boolean topdwn;
	        int i;
	        int ic;
	        int icol = 0;
	        int idist;
	        int iendch;
	        final int[] iinfo = new int[1];
	        int il;
	        int ilda;
	        int ioffg;
	        int ioffst;
	        int ipack;
	        int ipackg;
	        int ir;
	        int ir1;
	        int ir2;
	        int irow = 0;
	        int irsign = 0;
	        int iskew;
	        int isym;
	        int isympk = 0;
	        int j;
	        int jc;
	        int jch;
	        int jkl;
	        int jku;
	        int jr;
	        int k;
	        int llb;
	        int minlda;
	        int mnmin;
	        int mr;
	        int nc;
	        int uub;
	        double alpha;
	        double angle;
	        final double[] c = new double[1];
	        final double[] dummy = new double[1];
	        final double[] extra = new double[1];
	        final double[] s = new double[1];
	        final double[] temp = new double[1];
	        int length;
	        double[] ap;
	        int index;

	        // Decode and test the input parameters. Initialize flags & seed.
	        info[0] = 0;

	        // Quick return if possible
	        if ( (m == 0) || (n == 0)) {
	            return;
	        }

	        // Decode dist
	        if ( (dist == 'U') || (dist == 'u')) {
	            idist = 1;
	        } else if ( (dist == 'S') || (dist == 's')) {
	            idist = 2;
	        } else if ( (dist == 'N') || (dist == 'n')) {
	            idist = 3;
	        } else {
	            idist = -1;
	        }

	        // Decode sym
	        if ( (sym == 'N') || (sym == 'n')) {
	            isym = 1;
	            irsign = 0;
	        } else if ( (sym == 'P') || (sym == 'p')) {
	            isym = 2;
	            irsign = 0;
	        } else if ( (sym == 'S') || (sym == 's')) {
	            isym = 2;
	            irsign = 1;
	        } else if ( (sym == 'H') || (sym == 'h')) {
	            isym = 2;
	            irsign = 1;
	        } else {
	            isym = -1;
	        }

	        // Decode pack
	        if ( (pack == 'N') || (pack == 'n')) {
	            ipack = 0;
	        } else if ( (pack == 'U') || (pack == 'u')) {
	            ipack = 1;
	            isympk = 1;
	        } else if ( (pack == 'L') || (pack == 'l')) {
	            ipack = 2;
	            isympk = 1;
	        } else if ( (pack == 'C') || (pack == 'c')) {
	            ipack = 3;
	            isympk = 2;
	        } else if ( (pack == 'R') || (pack == 'r')) {
	            ipack = 4;
	            isympk = 3;
	        } else if ( (pack == 'B') || (pack == 'b')) {
	            ipack = 5;
	            isympk = 3;
	        } else if ( (pack == 'Q') || (pack == 'q')) {
	            ipack = 6;
	            isympk = 2;
	        } else if ( (pack == 'Z') || (pack == 'z')) {
	            ipack = 7;
	        } else {
	            ipack = -1;
	        }

	        // Set certain internal parameters
	        mnmin = Math.min(m, n);
	        llb = Math.min(kl, m - 1);
	        uub = Math.min(ku, n - 1);
	        mr = Math.min(m, n + llb);
	        nc = Math.min(n, m + uub);

	        if ( (ipack == 5) || (ipack == 6)) {
	            minlda = uub + 1;
	        } else if (ipack == 7) {
	            minlda = llb + uub + 1;
	        } else {
	            minlda = m;
	        }

	        // Use Givens rotation method if bandwidth small enough, or if lda is
	        // too small to store the matrix unpacked.

	        givens = false;

	        if (isym == 1) {

	            if ( (llb + uub) < (0.3 * Math.max(1, mr + nc))) {
	                givens = true;
	            }
	        } // if (isym == 1)
	        else if ( (2 * llb) < m) {
	            givens = true;
	        }

	        if ( (lda < m) && (lda >= minlda)) {
	            givens = true;
	        }

	        // Set info if an error
	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (m != n) && (isym != 1)) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (idist == -1) {
	            info[0] = -3;
	        } else if (isym == -1) {
	            info[0] = -5;
	        } else if (Math.abs(mode) > 6) {
	            info[0] = -7;
	        } else if ( (mode != 0) && (Math.abs(mode) != 6) && (cond < 1.0)) {
	            info[0] = -8;
	        } else if (kl < 0) {
	            info[0] = -10;
	        } else if ( (ku < 0) || ( (isym != 1) && (kl != ku))) {
	            info[0] = -11;
	        } else if ( (ipack == -1) || ( (isympk == 1) && (isym == 1)) || ( (isympk == 2) && (isym == 1) && (kl > 0))
	                || ( (isympk == 3) && (isym == 1) && (ku > 0)) || ( (isympk != 0) && (m != n))) {
	            info[0] = -12;
	        } else if (lda < Math.max(1, minlda)) {
	            info[0] = -14;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dlatms had info[0] = " + info[0]);

	            return;
	        }

	        // Initialize random number generator
	        for (i = 0; i < 4; i++) {
	            iseed[i] = Math.abs(iseed[i]) % 4096;
	        }

	        if ( (iseed[3] % 2) != 1) {
	            iseed[3] = iseed[3] + 1;
	        }

	        // Setup D if indicated
	        // Compute D according to cond and mode
	        dlatm1(mode, cond, irsign, idist, iseed, D, mnmin, iinfo);

	        if (iinfo[0] != 0) {
	            info[0] = 1;

	            return;
	        }

	        // Choose Top-Down if D is (apparently) increasing,
	        // Bottom-Up if D is (apparently) decreasing
	        if (Math.abs(D[0]) <= Math.abs(D[mnmin - 1])) {
	            topdwn = true;
	        } else {
	            topdwn = false;
	        }

	        if ( (mode != 0) && (Math.abs(mode) != 6)) {

	            // Scale by dmax
	            temp[0] = Math.abs(D[0]);

	            for (i = 1; i < mnmin; i++) {
	                temp[0] = Math.max(temp[0], Math.abs(D[i]));
	            }

	            if (temp[0] > 0.0) {
	                alpha = dmax / temp[0];
	            } else {
	                info[0] = 2;

	                return;
	            }

	            for (i = 0; i < mnmin; i++) {
	                D[i] = alpha * D[i];
	            }
	        } // if ((mode != 0) && (Math.abs(mode) != 6))

	        // Generate Banded Matrix using Givens rotations.
	        // Also the special case of uub = llb = 0

	        // Compute Addressing constants to cover all storage formats. Whether
	        // GE, SY, GB, or SB, upper or lower triangle or both, the (i,j)-th
	        // element is in A[i - iskew*j + ioffst - 1][j - 1];

	        if (ipack > 4) {
	            ilda = lda - 1;
	            iskew = 1;

	            if (ipack > 5) {
	                ioffst = uub + 1;
	            } else {
	                ioffst = 1;
	            }
	        } // if (ipack > 4)
	        else { // ipack <= 4
	            ilda = lda;
	            iskew = 0;
	            ioffst = 0;
	        } // else ipack <= 4

	        // ipackg is the format that the matrix is generated in. If this is
	        // different from ipack, then the matrix must be repacked at the end.
	        // It also signals how to compute the norm, for scaling.
	        ipackg = 0;
	        dlaset('F', lda, n, 0.0, 0.0, A, lda);

	        // Diagonal Matrix -- We are done, unless it is to be stored SP/PP/TP
	        // (pack = 'R' or 'C')
	        if ( (llb == 0) && (uub == 0)) {
	        	
	        	for (i = 0; i < mnmin; i++) {
	                A[ (1-iskew)*i + ioffst][i] = D[i];
	            }

	            if ( (ipack <= 2) || (ipack >= 5)) {
	                ipackg = ipack;
	            }
	        } // if ((llb == 0) && (uub == 0))
	        else if (givens) {

	            // Check whether to use Givens rotations, Householder
	            // transformations, or nothing
	            if (isym == 1) {

	                // Non-symmetric -- A = U D V
	                if (ipack > 4) {
	                    ipackg = ipack;
	                } else {
	                    ipackg = 0;
	                }

	                for (i = 0; i < mnmin; i++) {
	                    A[ (1-iskew)*i + ioffst][i] = D[i];
	                }
	                
	                if (topdwn) {
	                    jkl = 0;

	                    for (jku = 1; jku <= uub; jku++) {
	                        // Transform from bandwidth jkl, jku-1 to jkl, jku
	                        // Last row actually rotated is m-1
	                        // Last column actually rotated is min(m+jku,n)-1

	                        for (jr = 1; jr <= (Math.min(m + jku, n) + jkl - 1); jr++) {
	                            extra[0] = 0.0;
	                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
	                            c[0] = Math.cos(angle);
	                            s[0] = Math.sin(angle);
	                            icol = Math.max(1, jr - jkl);

	                            if (jr < m) {
	                                il = Math.min(n, jr + jku) + 1 - icol;
	                                length = lda - (jr - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][icol - 1];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(true, jr > jkl, false, il, c[0], s[0], ap, ilda, extra, dummy);
	                                index = 0;

	                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                    A[i][icol - 1] = ap[index++];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }
	                            } // if (jr < m)

	                            // Chase "extra" back up
	                            ir = jr;
	                            ic = icol;

	                            for (jch = jr - jkl; jch >= 1; jch -= (jkl + jku)) {

	                                if (ir < m) {
	                                    dlartg(A[ir - (iskew * (ic + 1)) + ioffst][ic], extra[0], c, s, dummy);
	                                } // if (ir < m)

	                                irow = Math.max(1, jch - jku);
	                                il = ir + 2 - irow;
	                                temp[0] = 0.0;
	                                iltemp = jch > jku;
	                                length = lda - (irow - (iskew * ic) + ioffst) + 1 + (lda * (n - ic));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = irow - (iskew * ic) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][ic - 1];
	                                }

	                                for (j = ic; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(false, iltemp, true, il, c[0], -s[0], ap, ilda, temp, extra);
	                                index = 0;

	                                for (i = irow - (iskew * ic) + ioffst - 1; i < lda; i++) {
	                                    A[i][ic - 1] = ap[index++];
	                                }

	                                for (j = ic; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                if (iltemp) {
	                                    dlartg(A[irow - (iskew * (ic + 1)) + ioffst][ic], temp[0], c, s, dummy);
	                                    icol = Math.max(1, jch - jku - jkl);
	                                    il = ic + 2 - icol;
	                                    extra[0] = 0.0;
	                                    length = lda - (irow - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
	                                    ap = new double[length];
	                                    index = 0;

	                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                        ap[index++] = A[i][icol - 1];
	                                    }

	                                    for (j = icol; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            ap[index++] = A[i][j];
	                                        }
	                                    }

	                                    dlarot(true, jch > (jku + jkl), true, il, c[0], -s[0], ap, ilda, extra, temp);
	                                    index = 0;

	                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                        A[i][icol - 1] = ap[index++];
	                                    }

	                                    for (j = icol; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            A[i][j] = ap[index++];
	                                        }
	                                    }

	                                    ic = icol;
	                                    ir = irow;
	                                } // if (iltemp)
	                            } // for (jch = jr - jkl; jch >= 1; jch -= (jkl+jku))
	                        } // for (jr = 1; jr <= Math.min(m+jku,n) + jkl - 1; jr++)
	                    } // for (jku = 1; jku <= uub; jku++)

	                    jku = uub;

	                    for (jkl = 1; jkl <= llb; jkl++) {

	                        // Transform from bandwidth jkl-1, jku to jkl, jku
	                        for (jc = 1; jc <= (Math.min(n + jkl, m) + jku - 1); jc++) {
	                            extra[0] = 0.0;
	                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
	                            c[0] = Math.cos(angle);
	                            s[0] = Math.sin(angle);
	                            irow = Math.max(1, jc - jku);

	                            if (jc < n) {
	                                il = Math.min(m, jc + jkl) + 1 - irow;
	                                length = lda - (irow - (iskew * jc) + ioffst) + 1 + (lda * (n - jc));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][jc - 1];
	                                }

	                                for (j = jc; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(false, jc > jku, false, il, c[0], s[0], ap, ilda, extra, dummy);
	                                index = 0;

	                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
	                                    A[i][jc - 1] = ap[index++];
	                                }

	                                for (j = jc; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }
	                            } // if (jc < n)

	                            // Chase "extra" back up
	                            ic = jc;
	                            ir = irow;

	                            for (jch = jc - jku; jch >= 1; jch -= (jkl + jku)) {

	                                if (ic < n) {
	                                    dlartg(A[ir - (iskew * (ic + 1)) + ioffst][ic], extra[0], c, s, dummy);
	                                } // if (ic < n)

	                                icol = Math.max(1, jch - jkl);
	                                il = ic + 2 - icol;
	                                temp[0] = 0.0;
	                                iltemp = jch > jkl;
	                                length = lda - (ir - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = ir - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][icol - 1];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(true, iltemp, true, il, c[0], -s[0], ap, ilda, temp, extra);
	                                index = 0;

	                                for (i = ir - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                    A[i][icol - 1] = ap[index++];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                if (iltemp) {
	                                    dlartg(A[ir - (iskew * (icol + 1)) + ioffst][icol], temp[0], c, s, dummy);
	                                    irow = Math.max(1, jch - jkl - jku);
	                                    il = ir + 2 - irow;
	                                    extra[0] = 0.0;
	                                    length = lda - (irow - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
	                                    ap = new double[length];
	                                    index = 0;

	                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                        ap[index++] = A[i][icol - 1];
	                                    }

	                                    for (j = icol; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            ap[index++] = A[i][j];
	                                        }
	                                    }

	                                    dlarot(false, jch > (jkl + jku), true, il, c[0], -s[0], ap, ilda, extra, temp);
	                                    index = 0;

	                                    for (i = irow - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                        A[i][icol - 1] = ap[index++];
	                                    }

	                                    for (j = icol; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            A[i][j] = ap[index++];
	                                        }
	                                    }

	                                    ic = icol;
	                                    ir = irow;
	                                } // if (iltemp)
	                            } // for (jch = jc - jku; jch >= 1; jch -= (jkl+jku))
	                        } // for (jc = 1; jc <= Math.min(n+jkl,m)+jku-1; jc++)
	                    } // for (jkl = 1; jkl <= llb; jkl++)
	                } // if (topdwn)
	                else { // !topdwn

	                    // Bottom-Up -- Start at the bottom right.
	                    jkl = 0;

	                    for (jku = 1; jku <= uub; jku++) {

	                        // Transform from bandwidth jkl, jku-1 to jkl, jku
	                        // First row actually rotated is m-1
	                        // First column actually rotated is min(m+jku,n)-1
	                        iendch = Math.min(m, n + jkl) - 1;

	                        for (jc = Math.min(m + jku, n) - 1; jc >= (1 - jkl); jc--) {
	                            extra[0] = 0.0;
	                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
	                            c[0] = Math.cos(angle);
	                            s[0] = Math.sin(angle);
	                            irow = Math.max(1, jc - jku + 1);

	                            if (jc > 0) {
	                                il = Math.min(m, jc + jkl + 1) + 1 - irow;
	                                length = lda - (irow - (iskew * jc) + ioffst) + 1 + (lda * (n - jc));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][jc - 1];
	                                }

	                                for (j = jc; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(false, false, (jc + jkl) < m, il, c[0], s[0], ap, ilda, dummy, extra);
	                                index = 0;

	                                for (i = irow - (iskew * jc) + ioffst - 1; i < lda; i++) {
	                                    A[i][jc - 1] = ap[index++];
	                                }

	                                for (j = jc; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }
	                            } // if (jc > 0)

	                            // Chase "extra" back down
	                            ic = jc;

	                            for (jch = jc + jkl; jch <= iendch; jch += (jkl + jku)) {
	                                ilextr = ic > 0;

	                                if (ilextr) {
	                                    dlartg(A[jch - (iskew * ic) + ioffst - 1][ic - 1], extra[0], c, s, dummy);
	                                } // if (ilextr)

	                                ic = Math.max(1, ic);
	                                icol = Math.min(n - 1, jch + jku);
	                                iltemp = (jch + jku) < n;
	                                temp[0] = 0.0;
	                                length = lda - (jch - (iskew * ic) + ioffst) + 1 + (lda * (n - ic));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = jch - (iskew * ic) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][ic - 1];
	                                }

	                                for (j = ic; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(true, ilextr, iltemp, icol + 2 - ic, c[0], s[0], ap, ilda, extra, temp);
	                                index = 0;

	                                for (i = jch - (iskew * ic) + ioffst - 1; i < lda; i++) {
	                                    A[i][ic - 1] = ap[index++];
	                                }

	                                for (j = ic; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                if (iltemp) {
	                                    dlartg(A[jch - (iskew * icol) + ioffst - 1][icol - 1], temp[0], c, s, dummy);
	                                    il = Math.min(iendch, jch + jkl + jku) + 2 - jch;
	                                    extra[0] = 0.0;
	                                    length = lda - (jch - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
	                                    ap = new double[length];
	                                    index = 0;

	                                    for (i = jch - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                        ap[index++] = A[i][icol - 1];
	                                    }

	                                    for (j = icol; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            ap[index++] = A[i][j];
	                                        }
	                                    }

	                                    dlarot(false, true, (jch + jkl + jku) <= iendch, il, c[0], s[0], ap, ilda, temp,
	                                            extra);
	                                    index = 0;

	                                    for (i = jch - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                        A[i][icol - 1] = ap[index++];
	                                    }

	                                    for (j = icol; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            A[i][j] = ap[index++];
	                                        }
	                                    }

	                                    ic = icol;
	                                } // if (iltemp)
	                            } // for (jch = jc+jkl; jch <= iendch; jch += (jkl+jku))
	                        } // for (jc = Math.min(m+jku,n)-1; jc >= 1 - jkl; jc--)
	                    } // for (jku = 1; jku <= uub; jku++)

	                    jku = uub;

	                    for (jkl = 1; jkl <= llb; jkl++) {

	                        // Transform from bandwidth jkl-1, jku to jkl, jku
	                        // First row actually rotated is min(n+jkl,m)-1
	                        // First column actually rotated is n-1
	                        iendch = Math.min(n, m + jku) - 1;

	                        for (jr = Math.min(n + jkl, m) - 1; jr >= (1 - jku); jr--) {
	                            extra[0] = 0.0;
	                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
	                            c[0] = Math.cos(angle);
	                            s[0] = Math.sin(angle);
	                            icol = Math.max(1, jr - jkl + 1);

	                            if (jr > 0) {
	                                il = Math.min(n, jr + jku + 1) + 1 - icol;
	                                length = lda - (jr - (iskew * icol) + ioffst) + 1 + (lda * (n - icol));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][icol - 1];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(true, false, (jr + jku) < n, il, c[0], s[0], ap, ilda, dummy, extra);
	                                index = 0;

	                                for (i = jr - (iskew * icol) + ioffst - 1; i < lda; i++) {
	                                    A[i][icol - 1] = ap[index++];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }
	                            } // if (jr > 0)

	                            // Chase "extra" back down
	                            ir = jr;

	                            for (jch = jr + jku; jch <= iendch; jch += (jkl + jku)) {
	                                ilextr = ir > 0;

	                                if (ilextr) {
	                                    dlartg(A[ir - (iskew * jch) + ioffst - 1][jch - 1], extra[0], c, s, dummy);
	                                } // if (ilextr)

	                                ir = Math.max(1, ir);
	                                irow = Math.min(m - 1, jch + jkl);
	                                iltemp = (jch + jkl) < m;
	                                temp[0] = 0.0;
	                                length = lda - (ir - (iskew * jch) + ioffst) + 1 + (lda * (n - jch));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = ir - (iskew * jch) + ioffst - 1; i < lda; i++) {
	                                    ap[index++] = A[i][jch - 1];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(false, ilextr, iltemp, irow + 2 - ir, c[0], s[0], ap, ilda, extra, temp);
	                                index = 0;

	                                for (i = ir - (iskew * jch) + ioffst - 1; i < lda; i++) {
	                                    A[i][jch - 1] = ap[index++];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                if (iltemp) {
	                                    dlartg(A[irow - (iskew * jch) + ioffst - 1][jch - 1], temp[0], c, s, dummy);
	                                    il = Math.min(iendch, jch + jkl + jku) + 2 - jch;
	                                    extra[0] = 0.0;
	                                    length = lda - (irow - (iskew * jch) + ioffst) + 1 + (lda * (n - jch));
	                                    ap = new double[length];
	                                    index = 0;

	                                    for (i = irow - (iskew * jch) + ioffst - 1; i < lda; i++) {
	                                        ap[index++] = A[i][jch - 1];
	                                    }

	                                    for (j = jch; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            ap[index++] = A[i][j];
	                                        }
	                                    }

	                                    dlarot(true, true, (jch + jkl + jku) <= iendch, il, c[0], s[0], ap, ilda, temp,
	                                            extra);
	                                    index = 0;

	                                    for (i = irow - (iskew * jch) + ioffst - 1; i < lda; i++) {
	                                        A[i][jch - 1] = ap[index++];
	                                    }

	                                    for (j = jch; j < n; j++) {

	                                        for (i = 0; i < lda; i++) {
	                                            A[i][j] = ap[index++];
	                                        }
	                                    }

	                                    ir = irow;
	                                } // if (iltemp)
	                            } // for (jch = jr + jku; jch <= iendch; jch += (jkl+jku))
	                        } // for (jr = Math.min(n+jkl,m)-1; jr >= 1 - jku; jr--)
	                    } // for (jkl = 1; jkl <= llb; jkl++)
	                } // else !topdwn
	            } // if (isym == 1)
	            else { // isym != 1

	                // Symmetric -- A = U D U'
	                ipackg = ipack;
	                ioffg = ioffst;

	                if (topdwn) {

	                    // Top-Down -- Generate Upper triangle only
	                    if (ipack >= 5) {
	                        ipackg = 6;
	                        ioffg = uub + 1;
	                    } else {
	                        ipackg = 1;
	                    }
	                    
	                    for (i = 0; i < mnmin; i++) {
	                        A[(1-iskew)*i + ioffg][i] = D[i];
	                    }

	                    for (k = 1; k <= uub; k++) {

	                        for (jc = 1; jc <= (n - 1); jc++) {
	                            irow = Math.max(1, jc - k);
	                            il = Math.min(jc + 1, k + 2);
	                            extra[0] = 0.0;
	                            temp[0] = A[jc - (iskew * (jc + 1)) + ioffg - 1][jc];
	                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
	                            c[0] = Math.cos(angle);
	                            s[0] = Math.sin(angle);
	                            length = lda - (irow - (iskew * jc) + ioffg) + 1 + (lda * (n - jc));
	                            ap = new double[length];
	                            index = 0;

	                            for (i = irow - (iskew * jc) + ioffg - 1; i < lda; i++) {
	                                ap[index++] = A[i][jc - 1];
	                            }

	                            for (j = jc; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    ap[index++] = A[i][j];
	                                }
	                            }

	                            dlarot(false, jc > k, true, il, c[0], s[0], ap, ilda, extra, temp);
	                            index = 0;

	                            for (i = irow - (iskew * jc) + ioffg - 1; i < lda; i++) {
	                                A[i][jc - 1] = ap[index++];
	                            }

	                            for (j = jc; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    A[i][j] = ap[index++];
	                                }
	                            }

	                            length = lda - ( ( (1 - iskew) * jc) + ioffg) + 1 + (lda * (n - jc));
	                            ap = new double[length];
	                            index = 0;

	                            for (i = ( (1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
	                                ap[index++] = A[i][jc - 1];
	                            }

	                            for (j = jc; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    ap[index++] = A[i][j];
	                                }
	                            }

	                            dlarot(true, true, false, Math.min(k, n - jc) + 1, c[0], s[0], ap, ilda, temp, dummy);
	                            index = 0;

	                            for (i = ( (1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
	                                A[i][jc - 1] = ap[index++];
	                            }

	                            for (j = jc; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    A[i][j] = ap[index++];
	                                }
	                            }

	                            // Chase extra back up the matrix
	                            icol = jc;

	                            for (jch = jc - k; jch >= 1; jch -= k) {
	                                dlartg(A[jch - (iskew * (icol + 1)) + ioffg][icol], extra[0], c, s, dummy);
	                                temp[0] = A[jch - (iskew * (jch + 1)) + ioffg - 1][jch];
	                                length = lda - ( ( (1 - iskew) * jch) + ioffg) + 1 + (lda * (n - jch));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = ( (1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
	                                    ap[index++] = A[i][jch - 1];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(true, true, true, k + 2, c[0], -s[0], ap, ilda, temp, extra);
	                                index = 0;

	                                for (i = ( (1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
	                                    A[i][jch - 1] = ap[index++];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                irow = Math.max(1, jch - k);
	                                il = Math.min(jch + 1, k + 2);
	                                extra[0] = 0.0;
	                                length = lda - (irow - (iskew * jch) + ioffg) + 1 + (lda * (n - jch));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = irow - (iskew * jch) + ioffg - 1; i < lda; i++) {
	                                    ap[index++] = A[i][jch - 1];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(false, jch > k, true, il, c[0], -s[0], ap, ilda, extra, temp);
	                                index = 0;

	                                for (i = irow - (iskew * jch) + ioffg - 1; i < lda; i++) {
	                                    A[i][jch - 1] = ap[index++];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                icol = jch;
	                            } // for (jch = jc-k; jch >= 1; jch -= k)
	                        } // for (jc = 1; jc <= n-1; jc++)
	                    } // for (k = 1; k <= uub; k++)

	                    // If we need lower triangle, copy from upper. Note that
	                    // the order of copying is chosen to work for 'q' -> 'b'
	                    if ( (ipack != ipackg) && (ipack != 3)) {

	                        for (jc = 1; jc <= n; jc++) {
	                            irow = ioffst - (iskew * jc);

	                            for (jr = jc; jr <= Math.min(n, jc + uub); jr++) {
	                                A[jr + irow - 1][jc - 1] = A[jc - (iskew * jr) + ioffg - 1][jr - 1];
	                            }
	                        } // for (jc = 1; jc <= n; jc++)

	                        if (ipack == 5) {

	                            for (jc = n - uub + 1; jc <= n; jc++) {

	                                for (jr = n + 2 - jc; jr <= (uub + 1); jr++) {
	                                    A[jr - 1][jc - 1] = 0.0;
	                                }
	                            }
	                        } // if (ipack == 5)

	                        if (ipackg == 6) {
	                            ipackg = ipack;
	                        } else {
	                            ipackg = 0;
	                        }
	                    } // if ((ipack != ipackg) && (ipack != 3))
	                } // if (topdwn)
	                else { // !topdwn

	                    // Bottom-Up -- Generate Lower triangle only
	                    if (ipack >= 5) {
	                        ipackg = 5;

	                        if (ipack == 6) {
	                            ioffg = 1;
	                        }
	                    } // if (ipack >= 5)
	                    else { // ipack < 5
	                        ipackg = 2;
	                    } // else ipack < 5
	                    
	                    for (i = 0; i < mnmin; i++) {
	                        A[(1-iskew)*i + ioffg][i] = D[i];
	                    } 

	                    for (k = 1; k <= uub; k++) {

	                        for (jc = n - 1; jc >= 1; jc--) {
	                            il = Math.min(n + 1 - jc, k + 2);
	                            extra[0] = 0.0;
	                            temp[0] = A[ ( (1 - iskew) * jc) + ioffg][jc - 1];
	                            angle = 2.0 * Math.PI * dlarnd(1, iseed);
	                            c[0] = Math.cos(angle);
	                            s[0] = -Math.sin(angle);
	                            length = lda - ( ( (1 - iskew) * jc) + ioffg) + 1 + (lda * (n - jc));
	                            ap = new double[length];
	                            index = 0;

	                            for (i = ( (1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
	                                ap[index++] = A[i][jc - 1];
	                            }

	                            for (j = jc; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    ap[index++] = A[i][j];
	                                }
	                            }

	                            dlarot(false, true, (n - jc) > k, il, c[0], s[0], ap, ilda, temp, extra);
	                            index = 0;

	                            for (i = ( (1 - iskew) * jc) + ioffg - 1; i < lda; i++) {
	                                A[i][jc - 1] = ap[index++];
	                            }

	                            for (j = jc; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    A[i][j] = ap[index++];
	                                }
	                            }

	                            icol = Math.max(1, jc - k + 1);
	                            length = lda - (jc - (iskew * icol) + ioffg) + 1 + (lda * (n - icol));
	                            ap = new double[length];
	                            index = 0;

	                            for (i = jc - (iskew * icol) + ioffg - 1; i < lda; i++) {
	                                ap[index++] = A[i][icol - 1];
	                            }

	                            for (j = icol; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    ap[index++] = A[i][j];
	                                }
	                            }

	                            dlarot(true, false, true, jc + 2 - icol, c[0], s[0], ap, ilda, dummy, temp);
	                            index = 0;

	                            for (i = jc - (iskew * icol) + ioffg - 1; i < lda; i++) {
	                                A[i][icol - 1] = ap[index++];
	                            }

	                            for (j = icol; j < n; j++) {

	                                for (i = 0; i < lda; i++) {
	                                    A[i][j] = ap[index++];
	                                }
	                            }

	                            // Chase extra back down the matrix
	                            icol = jc;

	                            for (jch = jc + k; jch <= (n - 1); jch += k) {
	                                dlartg(A[jch - (iskew * icol) + ioffg - 1][icol - 1], extra[0], c, s, dummy);
	                                temp[0] = A[ ( (1 - iskew) * jch) + ioffg][jch - 1];
	                                length = lda - (jch - (iskew * icol) + ioffg) + 1 + (lda * (n - icol));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = jch - (iskew * icol) + ioffg - 1; i < lda; i++) {
	                                    ap[index++] = A[i][icol - 1];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(true, true, true, k + 2, c[0], s[0], ap, ilda, extra, temp);
	                                index = 0;

	                                for (i = jch - (iskew * icol) + ioffg - 1; i < lda; i++) {
	                                    A[i][icol - 1] = ap[index++];
	                                }

	                                for (j = icol; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                il = Math.min(n + 1 - jch, k + 2);
	                                extra[0] = 0.0;
	                                length = lda - ( ( (1 - iskew) * jch) + ioffg) + 1 + (lda * (n - jch));
	                                ap = new double[length];
	                                index = 0;

	                                for (i = ( (1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
	                                    ap[index++] = A[i][jch - 1];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        ap[index++] = A[i][j];
	                                    }
	                                }

	                                dlarot(false, true, (n - jch) > k, il, c[0], s[0], ap, ilda, temp, extra);
	                                index = 0;

	                                for (i = ( (1 - iskew) * jch) + ioffg - 1; i < lda; i++) {
	                                    A[i][jch - 1] = ap[index++];
	                                }

	                                for (j = jch; j < n; j++) {

	                                    for (i = 0; i < lda; i++) {
	                                        A[i][j] = ap[index++];
	                                    }
	                                }

	                                icol = jch;
	                            } // for (jch = jc+k; jch <= n-1; jch += k)
	                        } // for (jc = n-1; jc >= 1; jc--)
	                    } // for (k = 1; k <= uub; k++)

	                    // If we need upper triangle, copy from lower. Note that the
	                    // order of copying is chosen to work for 'b' -> 'q'
	                    if ( (ipack != ipackg) && (ipack != 4)) {

	                        for (jc = n; jc >= 1; jc--) {
	                            irow = ioffst - (iskew * jc);

	                            for (jr = jc; jr >= Math.max(1, jc - uub); jr--) {
	                                A[jr + irow - 1][jc - 1] = A[jc - (iskew * jr) + ioffg - 1][jr - 1];
	                            }
	                        } // for (jc = n; jc >= 1; jc--)

	                        if (ipack == 6) {

	                            for (jc = 1; jc <= uub; jc++) {

	                                for (jr = 1; jr <= (uub + 1 - jc); jr++) {
	                                    A[jr - 1][jc - 1] = 0.0;
	                                }
	                            }
	                        } // if (ipack == 6)

	                        if (ipackg == 5) {
	                            ipackg = ipack;
	                        } // if (ipackg == 5)
	                        else { // ipackg != 5
	                            ipackg = 0;
	                        } // else ipackg != 5
	                    } // if ((ipack != ipackg) && (ipack != 4))
	                } // else !topdwn
	            } // else isym != 1
	        } // else if (givens)
	        else {

	            // Generate Banded Matrix by first rotating by random Unitary
	            // matrices, then reducing the bandwidth using Householder
	            // transformations.
	            // Note: We should only get here if lda >= n.
	            if (isym == 1) {

	                // Non-symmetric -- A = U D V
	                dlagge(mr, nc, llb, uub, D, A, lda, iseed, work, iinfo);
	            } // if (isym == 1)
	            else { // isym != 1

	                // Symmetric -- A = U D U'
	                dlagsy(m, llb, D, A, lda, iseed, work, iinfo);
	            } // else isym != 1

	            if (iinfo[0] != 0) {
	                info[0] = 3;

	                return;
	            } // if (iinfo[0] != 0)
	        } // else

	        // Pack the matrix
	        if (ipack != ipackg) {

	            if (ipack == 1) {

	                // 'U' -- Upper triangular, not packed
	                for (j = 0; j < m; j++) {

	                    for (i = j + 1; i < m; i++) {
	                        A[i][j] = 0.0;
	                    }
	                }
	            } // if (ipack == 1)
	            else if (ipack == 2) {

	                // 'L' -- Lower triangular, not packed
	                for (j = 1; j < m; j++) {

	                    for (i = 0; i <= (j - 1); i++) {
	                        A[i][j] = 0.0;
	                    }
	                }
	            } // else if (ipack == 2)
	            else if (ipack == 3) {

	                // 'C' -- Upper triangle packed Columnwise.
	                icol = 1;
	                irow = 0;

	                for (j = 0; j < m; j++) {

	                    for (i = 0; i <= j; i++) {
	                        irow = irow + 1;

	                        if (irow > lda) {
	                            irow = 1;
	                            icol = icol + 1;
	                        }

	                        A[irow - 1][icol - 1] = A[i][j];
	                    }
	                }
	            } // else if (ipack == 3)
	            else if (ipack == 4) {

	                // 'R' -- Lower triangle packed columnwise.
	                icol = 1;
	                irow = 0;

	                for (j = 0; j < m; j++) {

	                    for (i = j; i < m; i++) {
	                        irow = irow + 1;

	                        if (irow > lda) {
	                            irow = 1;
	                            icol = icol + 1;
	                        }

	                        A[irow - 1][icol - 1] = A[i][j];
	                    }
	                }
	            } // else if (ipack == 4)
	            else if (ipack >= 5) {
	                // 'B' -- The lower triangle is packed as a band matrix.
	                // 'Q' -- The upper triangle is packed as a band matrix.
	                // 'Z' -- The whole matrix is packed as a band matrix.

	                if (ipack == 5) {
	                    uub = 0;
	                } // if (ipack == 5)

	                if (ipack == 6) {
	                    llb = 0;
	                } // if (ipack == 6)

	                for (j = 1; j <= uub; j++) {

	                    for (i = Math.min(j + llb, m); i >= 1; i--) {
	                        A[i - j + uub][j - 1] = A[i - 1][j - 1];
	                    }
	                }

	                for (j = uub + 2; j <= n; j++) {

	                    for (i = j - uub; i <= Math.min(j + llb, m); i++) {
	                        A[i - j + uub][j - 1] = A[i - 1][j - 1];
	                    }
	                }
	            } // else if (ipack >= 5)

	            // If packed, zero out extraneous elements

	            // Symmetric/Triangular Packed
	            // zero out everything after A[irow-1][icol-1]

	            if ( (ipack == 3) || (ipack == 4)) {

	                for (jc = icol - 1; jc < m; jc++) {

	                    for (jr = irow; jr < lda; jr++) {
	                        A[jr][jc] = 0.0;
	                    }

	                    irow = 0;
	                }
	            } // if ((ipack == 3) || (ipack == 4))
	            else if (ipack >= 5) {

	                // Packed Band
	                // 1st row is now in A[uub+1-j][j-1], zero above it
	                // m-th row is now in A[m-1+uub-j][j-1], zero below it
	                // last non-zero diagonal is now in A[uub+llb][j-1],
	                // zero below it, too.
	                ir1 = uub + llb + 2;
	                ir2 = uub + m + 2;

	                for (jc = 1; jc <= n; jc++) {

	                    for (jr = 1; jr <= (uub + 1 - jc); jr++) {
	                        A[jr - 1][jc - 1] = 0.0;
	                    }

	                    for (jr = Math.max(1, Math.min(ir1, ir2 - jc)); jr <= lda; jr++) {
	                        A[jr - 1][jc - 1] = 0.0;
	                    }
	                } // for (jc = 1; jc <= n; jc++)
	            } // else if (ipack >= 5)
	        } // if (ipack != ipackg)

	        return;
	    } // dlatms

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine DLATRD Original DLATRD created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dlatrd reduces nb rows and columns of a real symmetric
	     * matrix A to symmetric tridiagonal form by an orthogonal similarity transformation Q'*A*Q, and returns the
	     * matrices V and W which are needed to apply the transformation to the unreduced part of A. If uplo = 'U', dlatrd
	     * reduces the last nb rows and columns of a matrix, of which the upper triangle is supplied. If uplo = 'L'. dlatrd
	     * reduces the first nb rows and columns of a matrix, of which the lower triangle is supplied. This is an auxiliary
	     * routine called by dsytrd.
	     * 
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrix A is stored:
	     *            = 'U': Upper triangular = 'L': Lower triangular
	     * @param n input int The order of the matrix A.
	     * @param nb input int The number of rows and columns to be reduced.
	     * @param A input/output double[][] of dimension lda by n. On entry, the symmetric matrix A. If uplo == 'U', the
	     *            leading n-by-n upper triangular part of A contains the upper triangular part of matrix A, and the
	     *            strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
	     *            triangular part of A contains the lower triangular part of the matrix A, and the strictly uper
	     *            triangular part of A is not referenced. On exit: If uplo = 'U', the last nb columns have been reduced
	     *            to tridiagonal form, with the diagonal elements overwriting the diagonal elements of A; the elements
	     *            above the diagonal with the array tau represent the orthogonal matrix Q as a product of elementary
	     *            reflectors. If uplo = 'L', the first nb columns have been reduced to tridiagonal form, with the
	     *            diagonal elements overwriting the diagonal elements of A; the elements below the diagonal with the
	     *            array tau represent the orthogonal matrix Q as a product of elementary reflectors. See Further
	     *            Details.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param e output double[] of dimension n-1. If uplo = 'U', e(n-nb-1:n-2) contains the superdiagonal elements of
	     *            the last nb columns of the reduced matrix. If uplo = 'L', e(0:nb-1) contains the subdiagonal elements
	     *            of the first nb columns of the reduced matrix.
	     * @param tau output double[] of dimension n-1 The scalar factors of the elementary reflectors, stored in
	     *            tau(n-nb-1:n-2) if uplo = 'U', and in tau(0:nb-1) if uplo = 'L'. See Further Details.
	     * @param W output double[][] of dimension ldw by nb. The n-by-nb matrix W required to update the unreduced part of
	     *            A.
	     * @param ldw input int The leading dimension of the array W. ldw >= max(1,n).
	     * 
	     *            <p>
	     *            Further Details: If uplo = 'U', the matrix Q is represented as a product of elementary reflectors Q =
	     *            H[n-1] H[n-2] ... H[n-nb]. Each H[i] has the form H[i] = I - tau * v * v' where tau is a real scalar,
	     *            and v is a real vector with v(i-1:n-1) = 0 and v(i-2) = 1; v(0:i-2) is stored on exit in A(0:i-2,i-1),
	     *            and tau in tau(i-2). If uplo = 'L', the matrix Q is represented as a product of elementary reflectors
	     *            Q = H[0] H[1] ... H[nb-1]. Each H[i] has the form H[i] = I - tau * v * v' where tau is a real scalar,
	     *            and v is a real vector with v(0:i-1) = 0 and v(i) = 1; v(i:n-1) is stored on exit in A(i:n-1,i-1),and
	     *            tau in tau[i-1].
	     *            </p>
	     * 
	     *            <p>
	     *            The elements of the vectors v together form the n-by-nb matrix V which is needed, with W, to apply the
	     *            transformation to the unreduced part of the matrix using a symmetric rank-2k update of the form: A = A
	     *            - V*W' - W*V'
	     *            </p>
	     * 
	     *            <p>
	     *            The contents of A on exit are illustrated by the following examples with n = 5 and nb = 2: If uplo =
	     *            'U': ( a a a v4 v5) ( a a v4 v5) ( a 1 v5) ( d 1) ( d) if uplo = 'L': ( d ) ( 1 d ) (v1 1 a ) (v1 v2 a
	     *            a ) (v1 v2 a a a) where d denotes a diagonal element of the reduced matrix, a denotes an element of
	     *            the original matrix that is unchanged, and vi denotes an element of the vector defining H(i).
	     *            </p>
	     */
	    private void dlatrd(final char uplo, final int n, final int nb, final double[][] A, final int lda,
	            final double[] e, final double[] tau, final double[][] W, final int ldw) {
	        int i;
	        int iw;
	        double alpha;
	        double[][] array1;
	        double[] vector1;
	        double[] vector2;
	        double[] vector3;
	        int j;
	        int k;

	        // Quick return if possible
	        if (n <= 0) {
	            return;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {

	            // Reduce last nb columns of upper triangle
	            for (i = n; i >= (n - nb + 1); i--) {
	                iw = i - n + nb;

	                if (i < n) {

	                    // Update A(0:i-1,i-1)
	                    array1 = new double[i][n - i];

	                    for (j = 0; j < i; j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            array1[j][k] = A[j][k + i];
	                        }
	                    }

	                    vector1 = new double[n - i];

	                    for (j = 0; j < (n - i); j++) {
	                        vector1[j] = W[i - 1][iw + j];
	                    }

	                    vector2 = new double[i];

	                    for (j = 0; j < i; j++) {
	                        vector2[j] = A[j][i - 1];
	                    }

	                    dgemv('N', i, n - i, -1.0, array1, i, vector1, 1, 1.0, vector2, 1);

	                    for (j = 0; j < i; j++) {
	                        A[j][i - 1] = vector2[j];
	                    }

	                    for (j = 0; j < i; j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            array1[j][k] = W[j][k + iw];
	                        }
	                    }

	                    for (j = 0; j < (n - i); j++) {
	                        vector1[j] = A[i - 1][j + i];
	                    }

	                    for (j = 0; j < i; j++) {
	                        vector2[j] = A[j][i - 1];
	                    }

	                    dgemv('N', i, n - i, -1.0, array1, i, vector1, 1, 1.0, vector2, 1);

	                    for (j = 0; j < i; j++) {
	                        A[j][i - 1] = vector2[j];
	                    }
	                } // if (i < n)

	                if (i > 1) {

	                    // Generate elementary reflector H[i-1] to annihilate A(0:i-3;,i-1)
	                    vector1 = new double[1];
	                    vector1[0] = A[i - 2][i - 1];
	                    vector2 = new double[i - 2];

	                    for (j = 0; j < (i - 2); j++) {
	                        vector2[j] = A[j][i - 1];
	                    }

	                    vector3 = new double[1];
	                    dlarfg(i - 1, vector1, vector2, 1, vector3);
	                    A[i - 2][i - 1] = vector1[0];

	                    for (j = 0; j < (i - 2); j++) {
	                        A[j][i - 1] = vector2[j];
	                    }

	                    tau[i - 2] = vector3[0];
	                    e[i - 2] = A[i - 2][i - 1];
	                    A[i - 2][i - 1] = 1.0;

	                    // Compute W(0:i-2,i-1)
	                    vector1 = new double[i - 1];
	                    vector2 = new double[i - 1];

	                    for (j = 0; j < (i - 1); j++) {
	                        vector1[j] = A[j][i - 1];
	                        vector2[j] = W[j][iw - 1];
	                    }

	                    dsymv('U', i - 1, 1.0, A, lda, vector1, 1, 0.0, vector2, 1);

	                    for (j = 0; j < (i - 1); j++) {
	                        W[j][iw - 1] = vector2[j];
	                    }

	                    if (i < n) {
	                        array1 = new double[i - 1][n - i];

	                        for (j = 0; j < (i - 1); j++) {

	                            for (k = 0; k < (n - i); k++) {
	                                array1[j][k] = W[j][k + iw];
	                            }
	                        }

	                        vector1 = new double[i - 1];

	                        for (j = 0; j < (i - 1); j++) {
	                            vector1[j] = A[j][i - 1];
	                        }

	                        vector2 = new double[n - i];

	                        for (j = 0; j < (n - i); j++) {
	                            vector2[j] = W[j + i][iw - 1];
	                        }

	                        dgemv('T', i - 1, n - i, 1.0, array1, i - 1, vector1, 1, 0.0, vector2, 1);

	                        for (j = 0; j < (n - i); j++) {
	                            W[j + i][iw - 1] = vector2[j];
	                        }

	                        for (j = 0; j < (i - 1); j++) {

	                            for (k = 0; k < (n - i); k++) {
	                                array1[j][k] = A[j][k + i];
	                            }
	                        }

	                        for (j = 0; j < (i - 1); j++) {
	                            vector1[j] = W[j][iw - 1];
	                        }

	                        dgemv('N', i - 1, n - i, -1.0, array1, i - 1, vector2, 1, 1.0, vector1, 1);

	                        for (j = 0; j < (i - 1); j++) {
	                            W[j][iw - 1] = vector1[j];
	                            vector1[j] = A[j][i - 1];
	                        }

	                        for (j = 0; j < (n - i); j++) {
	                            vector2[j] = W[j + i][iw - 1];
	                        }

	                        dgemv('T', i - 1, n - i, 1.0, array1, i - 1, vector1, 1, 0.0, vector2, 1);

	                        for (j = 0; j < (n - i); j++) {
	                            W[j + i][iw - 1] = vector2[j];
	                        }

	                        for (j = 0; j < (i - 1); j++) {

	                            for (k = 0; k < (n - i); k++) {
	                                array1[j][k] = W[j][k + iw];
	                            }
	                        }

	                        for (j = 0; j < (i - 1); j++) {
	                            vector1[j] = W[j][iw - 1];
	                        }

	                        dgemv('N', i - 1, n - i, -1.0, array1, i - 1, vector2, 1, 1.0, vector1, 1);

	                        for (j = 0; j < (i - 1); j++) {
	                            W[j][iw - 1] = vector1[j];
	                        }
	                    } // if (i < n)

	                    vector1 = new double[i - 1];

	                    for (j = 0; j < (i - 1); j++) {
	                        vector1[j] = W[j][iw - 1];
	                    }

	                    dscal(i - 1, tau[i - 2], vector1, 1);

	                    for (j = 0; j < (i - 1); j++) {
	                        W[j][iw - 1] = vector1[j];
	                    }

	                    vector2 = new double[i - 1];

	                    for (j = 0; j < (i - 1); j++) {
	                        vector2[j] = A[j][i - 1];
	                    }

	                    alpha = -0.5 * tau[i - 2] * ddot(i - 1, vector1, 1, vector2, 1);
	                    daxpy(i - 1, alpha, vector2, 1, vector1, 1);

	                    for (j = 0; j < (i - 1); j++) {
	                        W[j][iw - 1] = vector1[j];
	                    }
	                } // if (i > 1)
	            } // for (i = n; i >= n-nb+1; i--)
	        } // if ((uplo == 'U') || (uplo == 'u'))
	        else { // ((uplo != 'U') && (uplo != 'u'))

	            // Reduce first nb columns of lower triangle
	            for (i = 1; i <= nb; i++) {

	                // Update A(i-1:n-1,i-1)
	                if (i != 1) {
	                    array1 = new double[n - i + 1][i - 1];

	                    for (j = 0; j < (n - i + 1); j++) {

	                        for (k = 0; k < (i - 1); k++) {
	                            array1[j][k] = A[j + i - 1][k];
	                        }
	                    }

	                    vector1 = new double[i - 1];

	                    for (j = 0; j < (i - 1); j++) {
	                        vector1[j] = W[i - 1][j];
	                    }

	                    vector2 = new double[n - i + 1];

	                    for (j = 0; j < (n - i + 1); j++) {
	                        vector2[j] = A[j + i - 1][i - 1];
	                    }

	                    dgemv('N', n - i + 1, i - 1, -1.0, array1, n - i + 1, vector1, 1, 1.0, vector2, 1);

	                    for (j = 0; j < (n - i + 1); j++) {
	                        A[j + i - 1][i - 1] = vector2[j];
	                    }

	                    for (j = 0; j < (n - i + 1); j++) {

	                        for (k = 0; k < (i - 1); k++) {
	                            array1[j][k] = W[j + i - 1][k];
	                        }
	                    }

	                    for (j = 0; j < (i - 1); j++) {
	                        vector1[j] = A[i - 1][j];
	                    }

	                    for (j = 0; j < (n - i + 1); j++) {
	                        vector2[j] = A[j + i - 1][i - 1];
	                    }

	                    dgemv('N', n - i + 1, i - 1, -1.0, array1, n - i + 1, vector1, 1, 1.0, vector2, 1);

	                    for (j = 0; j < (n - i + 1); j++) {
	                        A[j + i - 1][i - 1] = vector2[j];
	                    }
	                } // if (i != 1)

	                if (i < n) {

	                    // Generate elementary reflector H[i-1] to annihilate A(i+1:n-1,i-1)
	                    vector1 = new double[1];
	                    vector1[0] = A[i][i - 1];
	                    vector2 = new double[n - i - 1];

	                    for (j = 0; j < (n - i - 1); j++) {
	                        vector2[j] = A[j + Math.min(i + 1, n - 1)][i - 1];
	                    }

	                    vector3 = new double[1];
	                    dlarfg(n - i, vector1, vector2, 1, vector3);
	                    A[i][i - 1] = vector1[0];

	                    for (j = 0; j < (n - i - 1); j++) {
	                        A[j + Math.min(i + 1, n - 1)][i - 1] = vector2[j];
	                    }

	                    tau[i - 1] = vector3[0];
	                    e[i - 1] = A[i][i - 1];
	                    A[i][i - 1] = 1.0;

	                    // Compute W(i:n-1,i-1)
	                    array1 = new double[n - i][n - i];

	                    for (j = 0; j < (n - i); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            array1[j][k] = A[j + i][k + i];
	                        }
	                    }

	                    vector1 = new double[n - i];
	                    vector2 = new double[n - i];

	                    for (j = 0; j < (n - i); j++) {
	                        vector1[j] = A[j + i][i - 1];
	                        vector2[j] = W[j + i][i - 1];
	                    }

	                    dsymv('L', n - i, 1.0, array1, n - i, vector1, 1, 0.0, vector2, 1);

	                    for (j = 0; j < (n - i); j++) {
	                        W[j + i][i - 1] = vector2[j];
	                    }

	                    array1 = new double[n - i][i - 1];

	                    for (j = 0; j < (n - i); j++) {

	                        for (k = 0; k < (i - 1); k++) {
	                            array1[j][k] = W[j + i][k];
	                        }
	                    }

	                    vector2 = new double[i - 1];

	                    for (j = 0; j < (i - 1); j++) {
	                        vector2[j] = W[j][i - 1];
	                    }

	                    dgemv('T', n - i, i - 1, 1.0, array1, n - i, vector1, 1, 0.0, vector2, 1);

	                    for (j = 0; j < (i - 1); j++) {
	                        W[j][i - 1] = vector2[j];
	                    }

	                    for (j = 0; j < (n - i); j++) {

	                        for (k = 0; k < (i - 1); k++) {
	                            array1[j][k] = A[j + i][k];
	                        }
	                    }

	                    for (j = 0; j < (n - i); j++) {
	                        vector1[j] = W[j + i][i - 1];
	                    }

	                    dgemv('N', n - i, i - 1, -1.0, array1, n - i, vector2, 1, 1.0, vector1, 1);

	                    for (j = 0; j < (n - i); j++) {
	                        W[j + i][i - 1] = vector1[j];
	                        vector1[j] = A[j + i][i - 1];
	                    }

	                    for (j = 0; j < (i - 1); j++) {
	                        vector2[j] = W[j][i - 1];
	                    }

	                    dgemv('T', n - i, i - 1, 1.0, array1, n - i, vector1, 1, 0.0, vector2, 1);

	                    for (j = 0; j < (i - 1); j++) {
	                        W[j][i - 1] = vector2[j];
	                    }

	                    for (j = 0; j < (n - i); j++) {

	                        for (k = 0; k < (i - 1); k++) {
	                            array1[j][k] = W[j + i][k];
	                        }
	                    }

	                    for (j = 0; j < (n - i); j++) {
	                        vector1[j] = W[j + i][i - 1];
	                    }

	                    dgemv('N', n - i, i - 1, -1.0, array1, n - i, vector2, 1, 1.0, vector1, 1);
	                    dscal(n - i, tau[i - 1], vector1, 1);
	                    vector2 = new double[n - i];

	                    for (j = 0; j < (n - i); j++) {
	                        vector2[j] = A[j + i][i - 1];
	                    }

	                    alpha = -0.5 * tau[i - 1] * ddot(n - i, vector1, 1, vector2, 1);
	                    daxpy(n - i, alpha, vector2, 1, vector1, 1);

	                    for (j = 0; j < (n - i); j++) {
	                        W[j + i][i - 1] = vector1[j];
	                    }
	                } // if (i < n)
	            } // for (i = 1; i <= nb; i++)
	        } // else ((uplo != 'U') && (uplo != 'u'))

	        return;
	    } // dlatrd

	    /**
	     * This is a port of the 10/14/93 DNRM2 function Original code written by Sven Hammarling, Nag Ltd. dnrm2 returns
	     * the euclidean norm of a vector via the function sqrt(x'*x)
	     * 
	     * @param n int
	     * @param x double[]
	     * @param incx int
	     * 
	     * @return double
	     */
	    private double dnrm2(final int n, final double[] x, final int incx) {
	        int ix;
	        double absxi;
	        double norm;
	        double scale;
	        double ssq;
	        double ratio;

	        if ( (n < 1) || (incx < 1)) {
	            norm = 0.0;
	        } else if (n == 1) {
	            norm = Math.abs(x[0]);
	        } else {
	            scale = 0.0;
	            ssq = 1.0;

	            for (ix = 0; ix <= ( (n - 1) * incx); ix += incx) {

	                if (x[ix] != 0.0) {
	                    absxi = Math.abs(x[ix]);

	                    if (scale < absxi) {
	                        ratio = scale / absxi;
	                        ssq = 1.0 + (ssq * ratio * ratio);
	                        scale = absxi;
	                    } else {
	                        ratio = absxi / scale;
	                        ssq = ssq + (ratio * ratio);
	                    }
	                } // if (x[ix] != 0.0)
	            } // for (ix = 0; ix <= (n-1)*incx; ix += incx)

	            norm = scale * Math.sqrt(ssq);
	        }

	        return norm;
	    } // dnrm2

	    /**
	     * This is a port of version 3.1 LAPACK routine DORG2L Original DORG2L created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dorg2l generates an m by n real matrix Q with orthonormal
	     * columns, which is defined as the last n columns of a product of k elementary reflectors of order m Q = H[k-1] ...
	     * H[1] H[0] as returned by dgeqlf
	     * 
	     * @param m input int The number of rows of the matrix Q. m >= 0.
	     * @param n input int The number of columns of the matrix Q. m >= n >= 0.
	     * @param k input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
	     * @param A input/output double[][] of dimension lda by n On entry, the (n-k+i)-th column must the the vector which
	     *            defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqlf in the last k
	     *            columns of its array argument A. On exit, the m by n matrix Q.
	     * @param lda input int The first dimension of the array A. lda >= max(1,m).
	     * @param tau input double[] of dimension k tau[i] must contain the scalar factor of the elementary reflector H[i],
	     *            as returned by dgeqlf.
	     * @param work workspace double[] of dimension n.
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument has an illegal value
	     */
	    private void dorg2l(final int m, final int n, final int k, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int[] info) {
	        int i;
	        int ii;
	        int j;
	        int L;
	        double[] vector1;
	        int p;

	        // Test the input arguments
	        info[0] = 0;

	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (n < 0) || (n > m)) {
	            info[0] = -2;
	        } else if ( (k < 0) || (k > n)) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -5;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dorg2l had info = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n <= 0) {
	            return;
	        }

	        // Initialize columns 0:n-k-1 to columns of the unit matrix
	        for (j = 0; j < (n - k); j++) {

	            for (L = 0; L < m; L++) {
	                A[L][j] = 0.0;
	            }

	            A[m - n + j][j] = 1.0;
	        } // for (j = 0; j < n-k; j++)

	        for (i = 1; i <= k; i++) {
	            ii = n - k + i;

	            // Apply H[i-1] to A(0:m-k+i-1,0:n-k+i-1) from the left
	            A[m - n + ii - 1][ii - 1] = 1.0;
	            vector1 = new double[m - n + ii];

	            for (p = 0; p < (m - n + ii); p++) {
	                vector1[p] = A[p][ii - 1];
	            }

	            dlarf('L', m - n + ii, ii - 1, vector1, 1, tau[i - 1], A, lda, work);
	            vector1 = new double[m - n + ii - 1];

	            for (p = 0; p < (m - n + ii - 1); p++) {
	                vector1[p] = A[p][ii - 1];
	            }

	            dscal(m - n + ii - 1, -tau[i - 1], vector1, 1);

	            for (p = 0; p < (m - n + ii - 1); p++) {
	                A[p][ii - 1] = vector1[p];
	            }

	            A[m - n + ii - 1][ii - 1] = 1.0 - tau[i - 1];

	            // Set A(m-k+i:m-1,n-k+i-1) to zero
	            for (L = m - n + ii; L < m; L++) {
	                A[L][ii - 1] = 0.0;
	            }
	        } // for (i = 1; i <= k; i++)

	        return;
	    } // dorg2l

	    /**
	     * This is a port of version 3.2 LAPACK routine DORG2R Original DORG2R created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dorg2r generates an m by n real
	     * matrix Q with orthonormal columns, which is defined as the first n columns of a product of k elementary
	     * reflectors of order m Q = H[0] H[1] ... H[k-1] as returned by dgeqrf.
	     * 
	     * @param m input int The number of rows of the matrix Q. m >= 0.
	     * @param n input int The number of columns of the matrix Q. m >= n >= 0.
	     * @param k input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
	     * @param A input/output double[][] of dimension lda by n. On entry, the i-th column must contain the vector which
	     *            defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqrf in the first k
	     *            columns of its array argument A. On exit, the m-by-n matrix Q.
	     * @param lda input int The first dimension of the array A. lda >= max(1,m).
	     * @param tau input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector H[i],
	     *            as returned by dgeqrf.
	     * @param work workspace double[] of dimension n.
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument has an illegal value.
	     */
	    private void dorg2r(final int m, final int n, final int k, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int[] info) {
	        int i;
	        int j;
	        int L;
	        double[] vector1;
	        double[][] array1;
	        int p;
	        int q;

	        // Test the input arguments
	        info[0] = 0;

	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (n < 0) || (n > m)) {
	            info[0] = -2;
	        } else if ( (k < 0) || (k > n)) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -5;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dorg2r had info = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n <= 0) {
	            return;
	        }

	        // Initialize columns k:n-1 to columns of the unit matrix
	        for (j = k; j < n; j++) {

	            for (L = 0; L < m; L++) {
	                A[L][j] = 0.0;
	            }

	            A[j][j] = 1.0;
	        } // for (j = k; j < n; j++)

	        for (i = k; i >= 1; i--) {

	            // Apply H[i-1] to A(i-1:m-1,i-1:n-1) from the left
	            if (i < n) {
	                A[i - 1][i - 1] = 1.0;
	                vector1 = new double[m - i + 1];

	                for (p = 0; p < (m - i + 1); p++) {
	                    vector1[p] = A[p + i - 1][i - 1];
	                }

	                array1 = new double[m - i + 1][n - i];

	                for (p = 0; p < (m - i + 1); p++) {

	                    for (q = 0; q < (n - i); q++) {
	                        array1[p][q] = A[p + i - 1][q + i];
	                    }
	                }

	                dlarf('L', m - i + 1, n - i, vector1, 1, tau[i - 1], array1, m - i + 1, work);

	                for (p = 0; p < (m - i + 1); p++) {

	                    for (q = 0; q < (n - i); q++) {
	                        A[p + i - 1][q + i] = array1[p][q];
	                    }
	                }
	            } // if (i < n)

	            if (i < m) {
	                vector1 = new double[m - i];

	                for (p = 0; p < (m - i); p++) {
	                    vector1[p] = A[p + i][i - 1];
	                }

	                dscal(m - i, -tau[i - 1], vector1, 1);

	                for (p = 0; p < (m - i); p++) {
	                    A[p + i][i - 1] = vector1[p];
	                }
	            } // if (i < m)

	            A[i - 1][i - 1] = 1.0 - tau[i - 1];

	            // Set A(0:i-2, i-1) to zero
	            for (L = 1; L <= (i - 1); L++) {
	                A[L - 1][i - 1] = 0.0;
	            }

	        } // for (i = k; i >= 1; i--)

	        return;
	    } // dorg2r

	    /**
	     * This is a port of the version 3.1 LAPACK routine DORGQL Original DORGQL created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dorgql generates the m-by-n real matrix Q with orthonormal
	     * columns, which is defined as the last n columns of a product of k elementary reflectors of order m Q = H[k-1] ...
	     * H[1] H[0] as returned by dgeqlf.
	     * 
	     * @param m input int The number of rows of the matrix Q. m >= 0.
	     * @param n input int The number of columns of the matrix Q. m >= n >= 0.
	     * @param k input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
	     * @param A input/output double[][] of dimension lda by n. On entry, the (n-k+i)-th column must contain the vector
	     *            which defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqlf in the last
	     *            k columns of its array argument A. On exit, the m-by-n matrix Q.
	     * @param lda input int The first dimension of the array A. lda >= max(1,m).
	     * @param tau input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector H[i],
	     *            as returned by dgeqlf.
	     * @param work workspace/output double[] of dimension max(1, lwork). On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= max(1,n). For optimum performance lwork >= n*nb,
	     *            where nb is optimal blocksize. If lwork = -1, then a workspace query is assumed; the routine only
	     *            calculates the optimal size of the work array, returns this value as the first entry of the work
	     *            array, and no error message related to lwork is issued.
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument has an illegal value
	     */
	    private void dorgql(final int m, final int n, final int k, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int lwork, final int[] info) {
	        boolean lquery;
	        int i;
	        int ib;
	        final int[] iinfo = new int[1];
	        int iws;
	        int j;
	        int kk;
	        int L;
	        int ldwork = n;
	        int lwkopt;
	        int nb = 1;
	        int nbmin;
	        int nx;
	        double[][] array1;
	        int row1;
	        double[][] array2;
	        double[][] array3;
	        double[] vector1;
	        int p;
	        int q;

	        // Test the input arguments
	        info[0] = 0;
	        if (lwork == -1) {
	            lquery = true;
	        } else {
	            lquery = false;
	        }
	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (n < 0) || (n > m)) {
	            info[0] = -2;
	        } else if ( (k < 0) || (k > n)) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -5;
	        }

	        if (info[0] == 0) {
	            if (n == 0) {
	                lwkopt = 1;
	            } else {
	                nb = ilaenv(1, "DORGQL", " ", m, n, k, -1);
	                lwkopt = n * nb;
	            }
	            work[0] = lwkopt;
	            if ( (lwork < Math.max(1, n)) && ( !lquery)) {
	                info[0] = -8;
	            }
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dorgql had info = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n <= 0) {
	            return;
	        }

	        nbmin = 2;
	        nx = 0;
	        iws = n;

	        if ( (nb > 1) && (nb < k)) {

	            // Determine when to cross over from blocked to unblocked code
	            nx = Math.max(0, ilaenv(3, "DORGQL", " ", m, n, k, -1));

	            if (nx < k) {

	                // Determine if workspace is large enough for blocked code.
	                ldwork = n;
	                iws = ldwork * nb;

	                if (lwork < iws) {

	                    // Not enough workspace to use optimal nb: reduce nb and determine
	                    // the minimum value of nb.
	                    nb = lwork / ldwork;
	                    nbmin = Math.max(2, ilaenv(2, "DORGQL", " ", m, n, k, -1));
	                } // if (lwork < iws)
	            } // if (nx < k)
	        } // if ((nb > 1) && (nb < k))

	        if ( (nb >= nbmin) && (nb < k) && (nx < k)) {

	            // Use blocked code after the first block.
	            // The last kk columns are handled by the block method
	            kk = Math.min(k, ( (k - nx + nb - 1) / nb) * nb);

	            // Set A(m-kk:m-1,0:n-kk-1) to zero.
	            for (j = 0; j < (n - kk); j++) {

	                for (i = m - kk; i < m; i++) {
	                    A[i][j] = 0.0;
	                }
	            }
	        } // if ((nb >= nbmin) && (nb < k) && (nx < k))
	        else {
	            kk = 0;
	        }

	        // Use unblocked code for the first or only block
	        dorg2l(m - kk, n - kk, k - kk, A, lda, tau, work, iinfo);

	        if (kk > 0) {

	            // Use blocked code
	            for (i = k - kk + 1; i <= k; i += nb) {
	                ib = Math.min(nb, k - i + 1);

	                if ( ( (n - k + i) > 1) && ( (m - k + i + ib - 1) > 0)) {

	                    // Form the triangular factor of the block reflector
	                    // H = H[i+ib-2] ... H[i] H[i-1]
	                    array1 = new double[m - k + i + ib - 1][ib];

	                    for (p = 0; p < (m - k + i + ib - 1); p++) {

	                        for (q = 0; q < ib; q++) {
	                            array1[p][q] = A[p][q + n - k + i - 1];
	                        }
	                    }

	                    vector1 = new double[ib];

	                    for (p = 0; p < ib; p++) {
	                        vector1[p] = tau[p + i - 1];
	                    }

	                    array2 = new double[ib][ib];
	                    dlarft('B', 'C', m - k + i + ib - 1, ib, array1, m - k + i + ib - 1, vector1, array2, ib);

	                    for (p = 0; p < (m - k + i + ib - 1); p++) {

	                        for (q = 0; q < ib; q++) {
	                            A[p][q + n - k + i - 1] = array1[p][q];
	                        }
	                    }

	                    array3 = new double[n - k + i - 1][ib];
	                    dlarfb('L', 'N', 'B', 'C', m - k + i + ib - 1, n - k + i - 1, ib, array1, m - k + i + ib - 1,
	                            array2, ib, A, lda, array3, n - k + i - 1);
	                } // if ((n-k+i > 1) && (m-k+i+ib-1 > 0))

	                // Apply H to rows 0:m-k+i+ib-2 of current block
	                row1 = Math.max(1, m - k + i + ib - 1);
	                array1 = new double[row1][ib];

	                for (p = 0; p < row1; p++) {

	                    for (q = 0; q < ib; q++) {
	                        array1[p][q] = A[p][q + n - k + i - 1];
	                    }
	                }

	                vector1 = new double[ib];

	                for (p = 0; p < ib; p++) {
	                    vector1[p] = tau[p + i - 1];
	                }

	                dorg2l(m - k + i + ib - 1, ib, ib, array1, row1, vector1, work, iinfo);

	                for (p = 0; p < row1; p++) {

	                    for (q = 0; q < ib; q++) {
	                        A[p][q + n - k + i - 1] = array1[p][q];
	                    }
	                }

	                // Set rows m-k+i+ib-1:m-1 of current block to zero
	                for (j = n - k + i - 1; j < (n - k + i + ib - 1); j++) {

	                    for (L = m - k + i + ib - 1; L < m; L++) {
	                        A[L][j] = 0.0;
	                    }
	                }
	            } // for (i = k - kk + 1; i <= k; i+= nb)
	        } // if (kk > 0)

	        work[0] = iws;

	        return;
	    } // dorgql

	    /**
	     * This is a port of version 3.2 LAPACK routine DORGQR Original DORGQR created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dorgqr generates an m-by-n real
	     * matrix Q with orthonormal columns, which is defined as the first n columns of a product of k elementary
	     * reflectors of order m Q = H[0] H[1] ... H[k-1] as returned by dgeqrf.
	     * 
	     * @param m input int The number of rows of the matrix Q. m >= 0.
	     * @param n input int The number of columns of the matrix Q. m >= n >= 0.
	     * @param k input int The number of elementary reflectors whose product defines the matrix Q. n >= k >= 0.
	     * @param A input/output double[][] of dimensions lda by n. On entry, the i-th column must contain the vector which
	     *            defines the elementary reflector H[i], for i = 0, 1, ..., k-1, as returned by dgeqrf in the first k
	     *            columns of its array argument A. On exit, the m-by-n matrix Q.
	     * @param lda input int The first dimension of the array A. lda >= max(1,m).
	     * @param tau input double[] of dimension k. tau[i] must contain the scalar factor of the elementary reflector H[i],
	     *            as returned by dgeqrf.
	     * @param work (worksplace/output) double[] of dimension max(1,lwork). On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= max(1,n). For optimum performance lwork >= n*nb,
	     *            where nb is the optimal blocksize. If lwork = -1, then a workspace query is assumed; the routine only
	     *            calculates the optimal size of the work array, returns this value as the first entry of the work
	     *            array, and no error message related to lwork is issued.
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument has an illegal value
	     */
	    private void dorgqr(final int m, final int n, final int k, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int lwork, final int[] info) {
	        boolean lquery;
	        int i;
	        int ib;
	        final int[] iinfo = new int[1];
	        int iws;
	        int j;
	        int ki = 1;
	        int kk;
	        int L;
	        int ldwork;
	        int lwkopt;
	        int nb;
	        int nbmin;
	        int nx;
	        double[][] array1;
	        double[][] array2;
	        double[][] array3;
	        double[][] array4;
	        double[] vector1;
	        int p;
	        int q;
	        int row1;

	        // Test the input arguments
	        info[0] = 0;
	        nb = ilaenv(1, "DORGQR", " ", m, n, k, -1);
	        lwkopt = Math.max(1, n) * nb;
	        work[0] = lwkopt;

	        lquery = (lwork == -1);

	        if (m < 0) {
	            info[0] = -1;
	        } else if ( (n < 0) || (n > m)) {
	            info[0] = -2;
	        } else if ( (k < 0) || (k > n)) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, m)) {
	            info[0] = -5;
	        } else if ( (lwork < Math.max(1, n)) && ( !lquery)) {
	            info[0] = -8;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dorgqr had info = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n <= 0) {
	            work[0] = 1;

	            return;
	        }

	        nbmin = 2;
	        nx = 0;
	        iws = n;

	        if ( (nb > 1) && (nb < k)) {

	            // Determine when to cross over from blocked to unblocked code
	            nx = Math.max(0, ilaenv(3, "DORGQR", " ", m, n, k, -1));

	            if (nx < k) {

	                // Determine if workspace is large enough for blocked code.
	                ldwork = n;
	                iws = ldwork * nb;

	                if (lwork < iws) {

	                    // Not enough workspace to use optimal nb: reduce nb and determine
	                    // the minimum value of nb.
	                    nb = lwork / ldwork;
	                    nbmin = Math.max(2, ilaenv(2, "DORGQR", " ", m, n, k, -1));
	                } // if (lwork < iws)
	            } // if (nx < k)
	        } // if ((nb > 1) && (nb < k))

	        if ( (nb >= nbmin) && (nb < k) && (nx < k)) {

	            // Use blocked code after the last block.
	            // The first kk columns are handled by the block method
	            ki = ( (k - nx - 1) / nb) * nb;
	            kk = Math.min(k, ki + nb);

	            // Set A(0:kk-1,kk:n-1) to zero.

	            for (j = kk; j < n; j++) {

	                for (i = 0; i < kk; i++) {
	                    A[i][j] = 0.0;
	                }
	            }
	        } // if ((nb >= nbmin) && (nb < k) && (nx < k))
	        else {
	            kk = 0;
	        }

	        // Use unblocked code for the last or only block
	        if (kk < n) {
	            row1 = Math.max(1, m - kk);
	            array1 = new double[row1][n - kk];

	            for (p = 0; p < row1; p++) {

	                for (q = 0; q < (n - kk); q++) {
	                    array1[p][q] = A[p + kk][q + kk];
	                }
	            }

	            vector1 = new double[k - kk];

	            for (p = 0; p < (k - kk); p++) {
	                vector1[p] = tau[p + kk];
	            }

	            dorg2r(m - kk, n - kk, k - kk, array1, row1, vector1, work, iinfo);

	            for (p = 0; p < row1; p++) {

	                for (q = 0; q < (n - kk); q++) {
	                    A[p + kk][q + kk] = array1[p][q];
	                }
	            }
	        } // if (kk < n)

	        if (kk > 0) {

	            // Use blocked code
	            for (i = ki + 1; i >= 1; i -= nb) {
	                ib = Math.min(nb, k - i + 1);

	                if ( (i + ib) <= n) {

	                    // Form the triangular factor of the block reflector
	                    // H = H[i-1] H[i] ... H[i+ib-2]
	                    array1 = new double[m - i + 1][ib];

	                    for (p = 0; p < (m - i + 1); p++) {

	                        for (q = 0; q < ib; q++) {
	                            array1[p][q] = A[p + i - 1][q + i - 1];
	                        }
	                    }

	                    vector1 = new double[ib];

	                    for (p = 0; p < ib; p++) {
	                        vector1[p] = tau[p + i - 1];
	                    }

	                    array2 = new double[ib][ib];
	                    dlarft('F', 'C', m - i + 1, ib, array1, m - i + 1, vector1, array2, ib);

	                    for (p = 0; p < (m - i + 1); p++) {

	                        for (q = 0; q < ib; q++) {
	                            A[p + i - 1][q + i - 1] = array1[p][q];
	                        }
	                    }

	                    // Apply H to A(i-1:m-1, i+ib-1:n-1) from the left
	                    array3 = new double[m - i + 1][n - i - ib + 1];

	                    for (p = 0; p < (m - i + 1); p++) {

	                        for (q = 0; q < (n - i - ib + 1); q++) {
	                            array3[p][q] = A[p + i - 1][q + i + ib - 1];
	                        }
	                    }

	                    array4 = new double[n - i - ib + 1][ib];
	                    dlarfb('L', 'N', 'F', 'C', m - i + 1, n - i - ib + 1, ib, array1, m - i + 1, array2, ib, array3, m
	                            - i + 1, array4, n - i - ib + 1);

	                    for (p = 0; p < (m - i + 1); p++) {

	                        for (q = 0; q < (n - i - ib + 1); q++) {
	                            A[p + i - 1][q + i + ib - 1] = array3[p][q];
	                        }
	                    }
	                } // if ((i+ib) <= n)

	                // Apply H to rows i-1:m-1 of current block
	                array1 = new double[m - i + 1][ib];

	                for (p = 0; p < (m - i + 1); p++) {

	                    for (q = 0; q < ib; q++) {
	                        array1[p][q] = A[p + i - 1][q + i - 1];
	                    }
	                }

	                vector1 = new double[ib];

	                for (p = 0; p < ib; p++) {
	                    vector1[p] = tau[p + i - 1];
	                }

	                dorg2r(m - i + 1, ib, ib, array1, m - i + 1, vector1, work, iinfo);

	                for (p = 0; p < (m - i + 1); p++) {

	                    for (q = 0; q < ib; q++) {
	                        A[p + i - 1][q + i - 1] = array1[p][q];
	                    }
	                }

	                // Set rows 0:i-2 of current block to zero
	                for (j = i; j <= (i + ib - 1); j++) {

	                    for (L = 1; L <= (i - 1); L++) {
	                        A[L - 1][j - 1] = 0.0;
	                    }
	                }
	            } // for (i = ki+1; i >= 1; i -= nb)
	        } // if (kk > 0)

	        work[0] = iws;

	        return;
	    } // dorgqr

	    /**
	     * This is a port of version 3.1 LAPACK routine DORGTR Original DORGTR created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dorgtr generates a real orthogonal matrix Q which is defined as
	     * the product of n-1 elementary reflectors of order N, as returned by dsytrd: If uplo = 'U', Q = H[n-2] ... H[1]
	     * H[0] If uplo = 'L', Q = H[0] H[1] ... H[n-2]
	     * 
	     * @param uplo input char \ = 'U': Upper triangle of A contains elementary reflectors from dsytrd = 'L': Lower
	     *            triangle of A contains elementary reflectors from dsytrd
	     * @param n input int The order of the matrix Q. n >= 0.
	     * @param A input/output double[][] of dimension lda by n On entry, the vectors which define the elementary
	     *            reflectors, as returned by dsytrd. On exit, the n-by-n orthogonal matrix Q.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param tau input double[] of dimension n-1. tau[i] must contain the scalar factor of the elementary reflector
	     *            H[i], as returned by dsytrd.
	     * @param work workspace/output double[] of dimension max(1, lwork). On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= max(1,n-1). For optimum performance, lwork >=
	     *            (n-1)*nb, where nb is the optimal blocksize. If lwork = -1, then a workspace query is assumed; the
	     *            routine only caclulates the optimal size of the work array, returns this value as the first entry of
	     *            the work array, and no error message related to lwork is issued.
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     */
	    private void dorgtr(final char uplo, final int n, final double[][] A, final int lda, final double[] tau,
	            final double[] work, final int lwork, final int[] info) {
	        boolean lquery;
	        boolean upper;
	        int i;
	        final int[] iinfo = new int[1];
	        int j;
	        int lwkopt = 1;
	        int nb;
	        double[][] array1;

	        // Test the input arguments
	        info[0] = 0;

	        if (lwork == -1) {
	            lquery = true;
	        } else {
	            lquery = false;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -4;
	        } else if ( (lwork < Math.max(1, n - 1)) && ( !lquery)) {
	            info[0] = -7;
	        }

	        if (info[0] == 0) {

	            if (upper) {
	                nb = ilaenv(1, "DORGQL", " ", n - 1, n - 1, n - 1, -1);
	            } else {
	                nb = ilaenv(1, "DORGQR", " ", n - 1, n - 1, n - 1, -1);
	            }

	            lwkopt = Math.max(1, n - 1) * nb;
	            work[0] = lwkopt;
	        } // if (info[0] == 0)

	        if (info[0] != 0) {
	            System.err.println("Error dorgtr had info = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            work[0] = 1;

	            return;
	        }

	        if (upper) {
	            // Q was determined by a call to dsytrd with uplo == 'U'

	            // Shift the vectors which define the elementary reflectors one column
	            // to the left, and set the last row and column of Q to those of the
	            // unit matrix

	            for (j = 0; j < (n - 1); j++) {

	                for (i = 0; i <= (j - 1); i++) {
	                    A[i][j] = A[i][j + 1];
	                }

	                A[n - 1][j] = 0.0;
	            } // for (j = 0; j < n-1; j++)

	            for (i = 0; i < (n - 1); i++) {
	                A[i][n - 1] = 0.0;
	            }

	            A[n - 1][n - 1] = 1.0;

	            // Generate Q(0:n-2,0:n-2)
	            dorgql(n - 1, n - 1, n - 1, A, lda, tau, work, lwork, iinfo);
	        } // if (upper)
	        else { // lower

	            // Q was determined by a call to dsytrd with uplo == 'L'

	            // Shift the vectors which define the elementary reflectors one column
	            // to the right, and set the first row and column of Q to those of the
	            // unit matrix

	            for (j = n - 1; j >= 1; j--) {
	                A[0][j] = 0.0;

	                for (i = j + 1; i < n; i++) {
	                    A[i][j] = A[i][j - 1];
	                }
	            } // for (j = n-1; j >=1; j--)

	            A[0][0] = 1.0;

	            for (i = 1; i < n; i++) {
	                A[i][0] = 0.0;
	            }

	            if (n > 1) {

	                // Generate Q(1:n-1,1:n-1)
	                array1 = new double[n - 1][n - 1];

	                for (i = 0; i < (n - 1); i++) {

	                    for (j = 0; j < (n - 1); j++) {
	                        array1[i][j] = A[i + 1][j + 1];
	                    }
	                }

	                dorgqr(n - 1, n - 1, n - 1, array1, n - 1, tau, work, lwork, iinfo);

	                for (i = 0; i < (n - 1); i++) {

	                    for (j = 0; j < (n - 1); j++) {
	                        A[i + 1][j + 1] = array1[i][j];
	                    }
	                }
	            } // if (n > 1)
	        } // else lower

	        work[0] = lwkopt;

	        return;
	    } // dorgtr

	    /**
	     * This is a port of the version 3.1 LAPACK routine DORM2L Original DORM2L created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dorm2l overwrites the general real m by n matrix C with Q * C
	     * if side == 'L' and trans == 'N', or Q' * C if side == 'L' and trans == 'T', or C * Q if side == 'R' and trans ==
	     * 'N', or C * Q' if side == 'R' and trans == 'T' where Q is a real orthogonal matrix defined as a product of k
	     * elementary reflectors Q = H[k-1] ... H[1] H[0] as retunred by dgeqlf. Q is of order m if side == 'L' and of order
	     * n if side == 'R'.
	     * 
	     * @param side (input) char = 'L': Apply Q or Q' from the left = 'R': Apply Q or Q' from the right
	     * @param trans (input) char = 'N': apply Q (no transpose) = 'T': apply Q' (Transpose)
	     * @param m (input) int The number of rows of the matrix C. m >= 0.
	     * @param n (input) int The number of columns of the matrix C. n >= 0.
	     * @param k (input) int The number of elementary reflectors whose product defines the matrix Q. If side == 'L', m >=
	     *            k >= 0. If side == 'R', n >= k >= 0.
	     * @param A (input) double[][] of dimension (lda,k) The i-th column must contain the vector which defines the
	     *            elementary reflector H(i), for i = 0, 1,...,k-1, as returned by dgeqlf in the last k column of its
	     *            array argument A. A is modified by the routine but restored on exit.
	     * @param lda (input) int The leading dimension of the array A. If side == 'L', lda >= max(1,m). If side == 'R', lda
	     *            >= max(1,n).
	     * @param tau (input) double[] of dimension (k) tau[i] must contain the scalar factor of the elementary reflector
	     *            H[i], as returned by dgeqlf.
	     * @param C (input/output) double[][]of dimension (ldc, n) On entry, the m by n matrix C. On exit, C is overwritten
	     *            by Q*C or Q'*C or C*Q' or C*Q.
	     * @param ldc (input) int The leading dimension of the array C. ldc >= max(1,m).
	     * @param work (workspace) double[] of dimension (n) if side == 'L', (m) if side == 'R'.
	     * @param info (output) int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value.
	     */
	    private void dorm2l(final char side, final char trans, final int m, final int n, final int k, final double[][] A,
	            final int lda, final double[] tau, final double[][] C, final int ldc, final double[] work, final int[] info) {
	        boolean left;
	        boolean notran;
	        int i;
	        int i1;
	        int i2;
	        int i3;
	        int mi = 0;
	        int ni = 0;
	        int nq;
	        double aii;
	        double[] v;
	        int j;

	        // Test the input arguments
	        info[0] = 0;
	        left = ( (side == 'L') || (side == 'l'));
	        notran = ( (trans == 'N') || (trans == 'n'));

	        // nq is the order of Q
	        if (left) {
	            nq = m;
	        } else {
	            nq = n;
	        }

	        if ( ( !left) && (side != 'R') && (side != 'r')) {
	            info[0] = -1;
	        } else if ( ( !notran) && (trans != 'T') && (trans != 't')) {
	            info[0] = -2;
	        } else if (m < 0) {
	            info[0] = -3;
	        } else if (n < 0) {
	            info[0] = -4;
	        } else if ( (k < 0) || (k > nq)) {
	            info[0] = -5;
	        } else if (lda < Math.max(1, nq)) {
	            info[0] = -7;
	        } else if (ldc < Math.max(1, m)) {
	            info[0] = -10;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dorm2l had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || (k == 0)) {
	            return;
	        }

	        if ( (left && notran) || ( ( !left) && ( !notran))) {
	            i1 = 1;
	            i2 = k;
	            i3 = 1;
	        } else {
	            i1 = k;
	            i2 = 1;
	            i3 = -1;
	        }

	        if (left) {
	            ni = n;
	        } else {
	            mi = m;
	        }

	        if (i3 == 1) {

	            for (i = i1; i <= i2; i++) {

	                if (left) {

	                    // H[i-1] is applied to C(0:m-k+i-1,0:n-1)
	                    mi = m - k + i;
	                    v = new double[mi];
	                } // if (left)
	                else { // !left

	                    // H[i-1] is applied to C(0:m-1,0:n-k+i-1)
	                    ni = n - k + i;
	                    v = new double[ni];
	                } // else !left

	                // Apply H[i-1]
	                aii = A[nq - k + i - 1][i - 1];
	                A[nq - k + i - 1][i - 1] = 1.0;

	                if (left) {

	                    for (j = 0; j < mi; j++) {
	                        v[j] = A[j][i - 1];
	                    }
	                } else {

	                    for (j = 0; j < ni; j++) {
	                        v[j] = A[j][i - 1];
	                    }
	                }

	                dlarf(side, mi, ni, v, 1, tau[i - 1], C, ldc, work);
	                A[nq - k + i - 1][i - 1] = aii;
	            } // for (i = i1; i <= i2; i++)
	        } // if (i3 == 1)
	        else { // i3 == -1

	            for (i = i1; i >= i2; i--) {

	                if (left) {

	                    // H[i-1] is applied to C(0:m-k+i-1,0:n-1)
	                    mi = m - k + i;
	                    v = new double[mi];
	                } // if (left)
	                else { // !left

	                    // H[i-1] is applied to C(0:m-1,0:n-k+i-1)
	                    ni = n - k + i;
	                    v = new double[ni];
	                } // else !left

	                // Apply H[i-1]
	                aii = A[nq - k + i - 1][i - 1];
	                A[nq - k + i - 1][i - 1] = 1.0;

	                if (left) {

	                    for (j = 0; j < mi; j++) {
	                        v[j] = A[j][i - 1];
	                    }
	                } else {

	                    for (j = 0; j < ni; j++) {
	                        v[j] = A[j][i - 1];
	                    }
	                }

	                dlarf(side, mi, ni, v, 1, tau[i - 1], C, ldc, work);
	                A[nq - k + i - 1][i - 1] = aii;
	            } // for (i = i1; i >= i2; i--)
	        } // else i3 == -1

	        return;
	    } // dorm2l

	    /**
	     * This is a port of the version 3.2 LAPACK routine DORM2R Original DORM2R created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dorm2r overwrites the general real m
	     * by n matrix C with Q * C if side = 'L' and trans = 'N', or Q'* C if side = 'L' and trans = 'T', or C * Q if side
	     * = 'R' and trans = 'N', or C * Q' if side = 'R' and trans = 'T', where Q is a real orthogonal matrix defined as
	     * the product of k elementary reflectors Q = H(0) H(1) . . . H(k-1) as returned by dgeqrf. Q is of order m if side
	     * = 'L' and of order n if side = 'R'.
	     * 
	     * @param side input char = 'L': apply Q or Q' from the left = 'R': apply Q or Q' from the right
	     * @param trans input char = 'N': apply Q (no transpose) = 'T': apply Q' (transpose)
	     * @param m input int The number of rows of the matrix C. m >= 0.
	     * @param n input int The number of columns of the matrix C. n >= 0.
	     * @param k input int The number of elementary reflectors whose product defines the matrix Q. If side = 'L', m >= k
	     *            >= 0 If side = 'R', n >= k >= 0
	     * @param A input double[][] of dimension (lda, k) The i-th column must contain the vector which defines the
	     *            elementary reflector H(i), for i = 0,1,...,k-1, as returned by dgeqrf in the first k columns of its
	     *            array argument A. A is modified by the routine but restored on exit.
	     * @param lda input int The leading dimension of the array A. If side = 'L', lda >= max(1,m) If side = 'R', lda >=
	     *            max(1,n)
	     * @param tau input double[] of dimension (k) tau[i] must contain the scalar factor of the elementary reflector
	     *            H(i), as returned by dgeqrf.
	     * @param C (input/output) double[][] of dimension (ldc,n) On entry, the m by n matrix C. On exit, C is overwritten
	     *            by Q*C or Q'*C or C*Q' or C*Q.
	     * @param ldc input int The leading dimension of the array C. ldc >= max(1,m).
	     * @param work (workspace) double[] of dimension (n) if side = 'L' (m) if side = 'R'
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value.
	     */
	    private void dorm2r(final char side, final char trans, final int m, final int n, final int k, final double[][] A,
	            final int lda, final double[] tau, final double[][] C, final int ldc, final double[] work, final int[] info) {
	        boolean left;
	        boolean notran;
	        int i;
	        int i1;
	        int i2;
	        int i3;
	        int ic = 1;
	        int jc = 1;
	        int mi = 1;
	        int ni = 1;
	        int nq;
	        double aii;
	        int j;
	        int p;
	        double[] x;
	        double[][] array1;
	        int row1;

	        // Test the input arguments
	        info[0] = 0;
	        left = ( (side == 'L') || (side == 'l'));
	        notran = ( (trans == 'N') || (trans == 'n'));

	        // nq is the order of Q
	        if (left) {
	            nq = m;
	        } else {
	            nq = n;
	        }

	        if ( ( !left) && (side != 'R') && (side != 'r')) {
	            info[0] = -1;
	        } else if ( ( !notran) && (trans != 'T') && (trans != 't')) {
	            info[0] = -2;
	        } else if (m < 0) {
	            info[0] = -3;
	        } else if (n < 0) {
	            info[0] = -4;
	        } else if ( (k < 0) || (k > nq)) {
	            info[0] = -5;
	        } else if (lda < Math.max(1, nq)) {
	            info[0] = -7;
	        } else if (ldc < Math.max(1, m)) {
	            info[0] = -10;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dorm2r had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || (k == 0)) {
	            return;
	        }

	        if ( (left && ( !notran)) || ( ( !left) && notran)) {
	            i1 = 1;
	            i2 = k;
	            i3 = 1;
	        } else {
	            i1 = k;
	            i2 = 1;
	            i3 = -1;
	        }

	        if (left) {
	            ni = n;
	            jc = 1;
	        } else {
	            mi = m;
	            ic = 1;
	        }

	        if (i3 == 1) {

	            for (i = i1; i <= i2; i++) {

	                if (left) {

	                    // H(i-1) is applied to C(i-1:m-1,0:n-1)
	                    mi = m - i + 1;
	                    ic = i;
	                } else {

	                    // H(i-1) is applied to C(0:m-1,i-1:n-1)
	                    ni = n - i + 1;
	                    jc = i;
	                }

	                // Apply H(i-1)
	                aii = A[i - 1][i - 1];
	                A[i - 1][i - 1] = 1.0;

	                if (left) {
	                    x = new double[mi];

	                    for (j = 0; j < mi; j++) {
	                        x[j] = A[i - 1 + j][i - 1];
	                    }
	                } // if (left)
	                else {
	                    x = new double[ni];

	                    for (j = 0; j < ni; j++) {
	                        x[j] = A[i - 1 + j][i - 1];
	                    }
	                }

	                row1 = Math.max(1, mi);
	                array1 = new double[row1][ni];

	                for (j = 0; j < row1; j++) {

	                    for (p = 0; p < ni; p++) {
	                        array1[j][p] = C[ic - 1 + j][jc - 1 + p];
	                    }
	                }

	                dlarf(side, mi, ni, x, 1, tau[i - 1], array1, row1, work);

	                for (j = 0; j < row1; j++) {

	                    for (p = 0; p < ni; p++) {
	                        C[ic - 1 + j][jc - 1 + p] = array1[j][p];
	                    }
	                }

	                A[i - 1][i - 1] = aii;
	            } // for (i = i1; i <= i2; i++)
	        } // if (i3 == 1)
	        else { // i3 == -1

	            for (i = i1; i >= i2; i--) {

	                if (left) {

	                    // H(i-1) is applied to C(i-1:m-1,0:n-1)
	                    mi = m - i + 1;
	                    ic = i;
	                } else {

	                    // H(i-1) is applied to C(0:m-1,i-1:n-1)
	                    ni = n - i + 1;
	                    jc = i;
	                }

	                // Apply H(i-1)
	                aii = A[i - 1][i - 1];
	                A[i - 1][i - 1] = 1.0;

	                if (left) {
	                    x = new double[mi];

	                    for (j = 0; j < mi; j++) {
	                        x[j] = A[i - 1 + j][i - 1];
	                    }
	                } // if (left)
	                else {
	                    x = new double[ni];

	                    for (j = 0; j < ni; j++) {
	                        x[j] = A[i - 1 + j][i - 1];
	                    }
	                }

	                row1 = Math.max(1, mi);
	                array1 = new double[row1][ni];

	                for (j = 0; j < row1; j++) {

	                    for (p = 0; p < ni; p++) {
	                        array1[j][p] = C[ic - 1 + j][jc - 1 + p];
	                    }
	                }

	                dlarf(side, mi, ni, x, 1, tau[i - 1], array1, row1, work);

	                for (j = 0; j < row1; j++) {

	                    for (p = 0; p < ni; p++) {
	                        C[ic - 1 + j][jc - 1 + p] = array1[j][p];
	                    }
	                }

	                A[i - 1][i - 1] = aii;
	            } // for (i = i1; i >= i2; i--)
	        } // else i3 == -1

	        return;
	    } // dorm2r

	    /**
	     * This is a port of version 3.2 LAPACK routine DORMQR Original DORMQR created by Univ. of Tennessee, Univ. of
	     * California Berkeley, Univ. of Colorado Denver, and NAG Ltd., November, 2006 dormqr overwrites the general real m
	     * by n matrix C with side = 'L' side = 'R' trans = 'N': Q * C C * Q trans = 'T': Q**T * C C * Q**T where Q is a
	     * real orthogonal matrix defined as the product of k elementary reflectors Q = H(0) H(1) . . . H(k-1) as returned
	     * by dgeqrf. Q is of order m if side = 'L' and of order n if side = 'R'.
	     * 
	     * @param side input char = 'L': apply Q or Q**T from the left = 'R': apply Q or Q**T from the right
	     * @param trans trans char = 'N': No transpose, apply Q = 'T': Transpose, apply Q**T
	     * @param m input int The number of rows of matrix C. m >= 0.
	     * @param n input int The number of columns of matrix C. n >= 0.
	     * @param k input int The number of elementary reflectors whose product defines the matrix Q. If side = 'L', m >= k
	     *            >= 0 If side = 'R', n >= k >= 0
	     * @param A input double[][] of dimension (lda,k) The i-th column must contain the vector which defines the
	     *            elementary reflector H(i), for i = 0,1,...,k-1, as returned by dgeqrf in the first k columns of its
	     *            array argument A. A is modified by the routine but restored on exit.
	     * @param lda input int The leading dimension of the array A. If side = 'L', lda >= max(1,m) If side = 'R', lda >=
	     *            max(1,n)
	     * @param tau input double[] of dimension k tau[i] must contain the scalar factor of the elementary reflector H(i),
	     *            as returned by dgeqrf
	     * @param C (input/output) double[][] of dimension (ldc,n) On entry, the m by n matrix C. On exit, C is overwritten
	     *            by Q*C or Q**T*C or C*Q**T or C*Q.
	     * @param ldc input int The leading dimension of the array C. ldc >= max(1,m).
	     * @param work (workspace/output) double[] of dimension max(1, lwork). On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. If side = 'L', work >= max(1,n). If side = 'R', work >=
	     *            max(1,m). For optimum performance lwork >= n*nb if side = 'L', and lwork >= m*nb if side = 'R', where
	     *            nb is optimal blocksize. If lwork = -1, then a workspace query is assumed; the routine only calculates
	     *            the optimal size of the work array, returns this value as the first entry of the work array, and no
	     *            error message related to lwork is output.
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value
	     */
	    private void dormqr(final char side, final char trans, final int m, final int n, final int k, final double[][] A,
	            final int lda, final double[] tau, final double[][] C, final int ldc, final double[] work, final int lwork,
	            final int[] info) {
	        final int nbmax = 64;
	        final int ldt = nbmax + 1;
	        boolean left;
	        boolean lquery;
	        boolean notran;
	        int i;
	        int i1;
	        int i2;
	        int i3;
	        int ib;
	        int ic = 1;
	        final int[] iinfo = new int[1];
	        int iws;
	        int jc = 1;
	        int ldwork;
	        int lwkopt = 1;
	        int mi = 1;
	        int nb = 1;
	        int nbmin;
	        int ni = 1;
	        int nq;
	        int nw;
	        final double[][] T = new double[ldt][nbmax];
	        String name = null;
	        String opts = null;
	        final char[] optsC = new char[2];
	        double[][] array1;
	        int p;
	        int q;
	        int row1;
	        int row2;
	        double[] x;
	        double[][] array2;
	        double[][] work2d;

	        // Test the input arguments
	        info[0] = 0;

	        left = ( (side == 'L') || (side == 'l'));
	        notran = ( (trans == 'N') || (trans == 'n'));
	        lquery = (lwork == -1);

	        // nq is the order of Q and nw is the minimum dimension of work
	        if (left) {
	            nq = m;
	            nw = n;
	        } else {
	            nq = n;
	            nw = m;
	        }

	        if ( ( !left) && (side != 'R') && (side != 'r')) {
	            info[0] = -1;
	        } else if ( ( !notran) && (trans != 'T') && (trans != 't')) {
	            info[0] = -2;
	        } else if (m < 0) {
	            info[0] = -3;
	        } else if (n < 0) {
	            info[0] = -4;
	        } else if ( (k < 0) || (k > nq)) {
	            info[0] = -5;
	        } else if (lda < Math.max(1, nq)) {
	            info[0] = -7;
	        } else if (ldc < Math.max(1, m)) {
	            info[0] = -10;
	        } else if ( (lwork < Math.max(1, nw)) && ( !lquery)) {
	            info[0] = -12;
	        }

	        if (info[0] == 0) {

	            // Determine the block size. nb may be at most nbmax, where nbmax
	            // is used to define the local array T.
	            name = new String("DORMQR");
	            optsC[0] = side;
	            optsC[1] = trans;
	            opts = new String(optsC);
	            nb = Math.min(nbmax, ilaenv(1, name, opts, m, n, k, -1));
	            lwkopt = Math.max(1, nw) * nb;
	            work[0] = lwkopt;
	        } // if (info[0] == 0)

	        if (info[0] != 0) {
	            System.err.println("Error dormqr had info[0] = " + info[0]);

	            return;
	        } else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || (k == 0)) {
	            work[0] = 1;

	            return;
	        }

	        nbmin = 2;
	        ldwork = nw;

	        if ( (nb > 1) && (nb < k)) {
	            iws = nw * nb;

	            if (lwork < iws) {
	                nb = lwork / ldwork;
	                nbmin = Math.max(2, ilaenv(2, name, opts, m, n, k, -1));
	            } // if (lwork < iws)
	        } // if ((nb > 1) && (nb < k))
	        else {
	            iws = nw;
	        }

	        if ( (nb < nbmin) || (nb >= k)) {

	            // use unblocked code
	            dorm2r(side, trans, m, n, k, A, lda, tau, C, ldc, work, iinfo);
	        } // if ((nb < nbmin) || (nb >= k))
	        else {

	            // Use blocked code
	            if ( (left && ( !notran)) || ( ( !left) && notran)) {
	                i1 = 1;
	                i2 = k;
	                i3 = nb;
	            } else {
	                i1 = ( ( (k - 1) / nb) * nb) + 1;
	                i2 = 1;
	                i3 = -nb;
	            }

	            if (left) {
	                ni = n;
	                jc = 1;
	            } else {
	                mi = m;
	                ic = 1;
	            }

	            if (i3 == nb) {

	                for (i = i1; i <= i2; i += nb) {
	                    ib = Math.min(nb, k - i + 1);

	                    // Form the triangular factor of the block reflector
	                    // H = H(i-1) H(i) . . . H(i+ib-2)
	                    row1 = Math.max(1, nq - i + 1);
	                    array1 = new double[row1][ib];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            array1[p][q] = A[i - 1 + p][i - 1 + q];
	                        }
	                    }

	                    x = new double[ib];

	                    for (p = 0; p < ib; p++) {
	                        x[p] = tau[i - 1 + p];
	                    }

	                    dlarft('F', 'C', nq - i + 1, ib, array1, row1, x, T, ldt);

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            A[i - 1 + p][i - 1 + q] = array1[p][q];
	                        }
	                    }

	                    if (left) {

	                        // H or H' is applied to C(i-1:m-1,0:n-1)
	                        mi = m - i + 1;
	                        ic = i;
	                    } else {

	                        // H or H' is applied to C(0:m-1,i-1:n-1)
	                        ni = n - i + 1;
	                        jc = i;
	                    }

	                    // Apply H or H'
	                    if (left) {
	                        row1 = Math.max(1, mi);
	                    } else {
	                        row1 = Math.max(1, ni);
	                    }

	                    array1 = new double[row1][ib];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            array1[p][q] = A[i - 1 + p][i - 1 + q];
	                        }
	                    }

	                    row2 = Math.max(1, mi);
	                    array2 = new double[row2][ni];

	                    for (p = 0; p < row2; p++) {

	                        for (q = 0; q < ni; q++) {
	                            array2[p][q] = C[ic - 1 + p][jc - 1 + q];
	                        }
	                    }

	                    work2d = new double[ldwork][ib];
	                    dlarfb(side, trans, 'F', 'C', mi, ni, ib, array1, row1, T, ldt, array2, row2, work2d, ldwork);

	                    for (p = 0; p < row2; p++) {

	                        for (q = 0; q < ni; q++) {
	                            C[ic - 1 + p][jc - 1 + q] = array2[p][q];
	                        }
	                    }
	                } // for (i = i1; i <= i2; i += nb)
	            } // if (i3 == nb)
	            else { // i3 == -nb

	                for (i = i1; i >= i2; i -= nb) {
	                    ib = Math.min(nb, k - i + 1);

	                    // Form the triangular factor of the block reflector
	                    // H = H(i-1) H(i) . . . H(i+ib-2)
	                    row1 = Math.max(1, nq - i + 1);
	                    array1 = new double[row1][ib];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            array1[p][q] = A[i - 1 + p][i - 1 + q];
	                        }
	                    }

	                    x = new double[ib];

	                    for (p = 0; p < ib; p++) {
	                        x[p] = tau[i - 1 + p];
	                    }

	                    dlarft('F', 'C', nq - i + 1, ib, array1, row1, x, T, ldt);

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            A[i - 1 + p][i - 1 + q] = array1[p][q];
	                        }
	                    }

	                    if (left) {

	                        // H or H' is applied to C(i-1:m-1,0:n-1)
	                        mi = m - i + 1;
	                        ic = i;
	                    } else {

	                        // H or H' is applied to C(0:m-1,i-1:n-1)
	                        ni = n - i + 1;
	                        jc = i;
	                    }

	                    // Apply H or H'
	                    if (left) {
	                        row1 = Math.max(1, mi);
	                    } else {
	                        row1 = Math.max(1, ni);
	                    }

	                    array1 = new double[row1][ib];

	                    for (p = 0; p < row1; p++) {

	                        for (q = 0; q < ib; q++) {
	                            array1[p][q] = A[i - 1 + p][i - 1 + q];
	                        }
	                    }

	                    row2 = Math.max(1, mi);
	                    array2 = new double[row2][ni];

	                    for (p = 0; p < row2; p++) {

	                        for (q = 0; q < ni; q++) {
	                            array2[p][q] = C[ic - 1 + p][jc - 1 + q];
	                        }
	                    }

	                    work2d = new double[ldwork][ib];
	                    dlarfb(side, trans, 'F', 'C', mi, ni, ib, array1, row1, T, ldt, array2, row2, work2d, ldwork);

	                    for (p = 0; p < row2; p++) {

	                        for (q = 0; q < ni; q++) {
	                            C[ic - 1 + p][jc - 1 + q] = array2[p][q];
	                        }
	                    }
	                } // for (i = i1; i >= i2; i -= nb)
	            } // else i3 == -nb
	        }

	        work[0] = lwkopt;

	        return;
	    } // dormqr

	    /**
	     * This is a port of the version 3.1 LAPACK routine DPOTF2 Original DPOTF2 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dpotf2 computes the Cholesky factorization of a real symmetric
	     * positive definite matrix A.
	     * 
	     * <p>
	     * The factorization has the form A = U' * U, if UPLO = 'U', or A = L * L', if UPLO = 'L', where U is an upper
	     * triangular matrix and L is lower triangular
	     * </p>
	     * 
	     * <p>
	     * This is the unblocked version of the algorithm, calling Level 2 BLAS.
	     * </p>
	     * 
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrix A is stored.
	     *            = 'U': Upper triangular = 'L': Lower triangular
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param A input/output double[][] dimension lda by n On entry, the symmetric matrix A. If UPLO = 'U', the leading
	     *            n by n upper triangular part of A contains the upper triangular part of the matrix A, and the strictly
	     *            lower triangular part of A is not referenced. If uplo = 'L', the leading n by n lower triangular part
	     *            of A contains the lower triangular part of the matrix A, and the strictly upper triangular part of A
	     *            is not referenced.
	     * 
	     *            <p>
	     *            On exit, if info[0] = 0, the factor U or L from the Cholesky factorization A = U'*U or A = L*L'.
	     *            </p>
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -k, the k-th argument had an illegal value > 0:
	     *            If info[0] = k, the leading minor of order k is not positive definite, and the factorization could not
	     *            be completed.
	     */
	    private void dpotf2(final char uplo, final int n, final double[][] A, final int lda, final int[] info) {
	        boolean upper;
	        int j;
	        double[] dx;
	        double ajj;
	        int i;
	        double[] x;
	        double[] y;
	        double[][] array1;
	        int m;
	        int p;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -4;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error in dpotf2 with info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if (upper) {

	            // Compute the Cholesky factorization A = U'*U
	            for (j = 1; j <= n; j++) {

	                // Compute U(j-1,j-1) and test for non-positive-definiteness.
	                if (j != 1) {
	                    dx = new double[j - 1];

	                    for (i = 0; i < (j - 1); i++) {
	                        dx[i] = A[i][j - 1];
	                    }

	                    ajj = A[j - 1][j - 1] - ddot(j - 1, dx, 1, dx, 1);
	                } // if (j != 1)
	                else {
	                    ajj = A[0][0];
	                }

	                if (ajj <= 0.0) {
	                    A[j - 1][j - 1] = ajj;
	                    info[0] = j;

	                    return;
	                } // if (ajj <= 0.0)

	                ajj = Math.sqrt(ajj);
	                A[j - 1][j - 1] = ajj;

	                // Compute elements j:n-1 of row j-1
	                if (j < n) {
	                    y = new double[n - j];

	                    for (i = 0; i < (n - j); i++) {
	                        y[i] = A[j - 1][j + i];
	                    }

	                    if (j != 1) {
	                        array1 = new double[j - 1][n - j];

	                        for (m = 0; m < (j - 1); m++) {

	                            for (p = 0; p < (n - j); p++) {
	                                array1[m][p] = A[m][p + j];
	                            }
	                        }

	                        x = new double[j - 1];

	                        for (i = 0; i < (j - 1); i++) {
	                            x[i] = A[i][j - 1];
	                        }

	                        dgemv('T', j - 1, n - j, -1.0, array1, j - 1, x, 1, 1.0, y, 1);
	                    } // if (j != 1)

	                    dscal(n - j, 1.0 / ajj, y, 1);

	                    for (i = 0; i < (n - j); i++) {
	                        A[j - 1][j + i] = y[i];
	                    }
	                } // if (j < n)
	            } // for (j = 1; j <= n; j++)
	        } // if (upper)
	        else { // lower

	            // Compute the Cholesky factorization A = L*L'
	            for (j = 1; j <= n; j++) {

	                // Compute L(j-1,j-1) and test for non-positive-definiteness
	                if (j != 1) {
	                    dx = new double[j - 1];

	                    for (i = 0; i < (j - 1); i++) {
	                        dx[i] = A[j - 1][i];
	                    }

	                    ajj = A[j - 1][j - 1] - ddot(j - 1, dx, 1, dx, 1);
	                } // if (j != 1)
	                else {
	                    ajj = A[0][0];
	                }

	                if (ajj <= 0.0) {
	                    A[j - 1][j - 1] = ajj;
	                    info[0] = j;

	                    return;
	                } // if (ajj <= 0.0)

	                ajj = Math.sqrt(ajj);
	                A[j - 1][j - 1] = ajj;

	                // Compute elements j:n-1 of column j-1
	                if (j < n) {
	                    y = new double[n - j];

	                    for (i = 0; i < (n - j); i++) {
	                        y[i] = A[j + i][j - 1];
	                    }

	                    if (j != 1) {
	                        array1 = new double[n - j][j - 1];

	                        for (m = 0; m < (n - j); m++) {

	                            for (p = 0; p < (j - 1); p++) {
	                                array1[m][p] = A[m + j][p];
	                            }
	                        }

	                        x = new double[j - 1];

	                        for (i = 0; i < (j - 1); i++) {
	                            x[i] = A[j - 1][i];
	                        }

	                        dgemv('N', n - j, j - 1, -1.0, array1, n - j, x, 1, 1.0, y, 1);
	                    } // if (j != 1)

	                    dscal(n - j, 1.0 / ajj, y, 1);

	                    for (i = 0; i < (n - j); i++) {
	                        A[j + i][j - 1] = y[i];
	                    }
	                } // if (j < n)
	            } // for (j = 1; j <= n; j++)
	        } // else lower

	        return;
	    } // dpotf2

	    /**
	     * This is a port of the DPOTRF version 3.1 LAPACK routine Original DPOTRF created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dpotrf computes the Cholesky factorization of a real symmetric
	     * positive definite matrix A
	     * 
	     * <p>
	     * The factorization has the form A = U'*U, if uplo = 'U', or A = L * L', if uplo = 'L', where U is an upper
	     * triangular matrix and L is lower triangular
	     * </p>
	     * 
	     * <p>
	     * This is the block version of the algorithm, calling Level 3 BLAS.
	     * </p>
	     * 
	     * @param uplo input char = 'U': Upper triangle of A is stored. = 'L': Lower triangle of A is stored.
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param A (input/output) double[][] dimension (lda, n) On entry, the symmetric matrix A. If uplo == 'U', the
	     *            leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and the
	     *            strictly lower triangular part of A is not referenced. If uplo == 'L', the leading n-by-n lower
	     *            triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
	     *            triangular part of A is not referenced.
	     * 
	     *            <p>
	     *            On exit, if info[0] = 0, the factor U or L from the Cholesky factorization A = U'*U or A = L*L'.
	     *            </p>
	     * @param lda input int The leading dimension of array A. lda >= max(1,n)
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value > 0:
	     *            If info[0] = i, the leading minor of order i is not positive definite, and the factorization could not
	     *            be completed.
	     */
	    private void dpotrf(final char uplo, final int n, final double[][] A, final int lda, final int[] info) {
	        boolean upper;
	        String name;
	        int nb;
	        final char[] chArray = new char[1];
	        String opts;
	        int j;
	        int jb;
	        int m, p;
	        double[][] array1;
	        double[][] array2;
	        double[][] array3;
	        int row1;
	        int row2;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } // if ((uplo == 'U') || (uplo == 'u'))
	        else {
	            upper = false;
	        }

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -1;
	        } // if ((!upper) && (uplo != 'L') && (uplo != 'l'))
	        else if (n < 0) {
	            info[0] = -2;
	        } // else if (n < 0)
	        else if (lda < Math.max(1, n)) {
	            info[0] = -4;
	        } // else if (lda < Math.max(1,n))

	        if (info[0] != 0) {
	            System.err.println("Error in dpotrf with info[0] = " + info[0]);

	            return;
	        } // if (info[0] != 0)

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        } // if (n == 0)

	        name = new String("DPOTRF");
	        chArray[0] = uplo;
	        opts = new String(chArray);

	        // Determine the block size for this environment
	        nb = ilaenv(1, name, opts, n, -1, -1, -1);

	        if ( (nb <= 1) || (nb >= n)) {

	            // Use unblocked code
	            dpotf2(uplo, n, A, lda, info);
	        } // if ((nb <= 1) || (nb >= n))
	        else { // Use blocked code

	            if (upper) {

	                // Compute the Cholesky factorization A = U' * U.
	                for (j = 1; j <= n; j += nb) {

	                    // Update and factorize the current diagonal block and test for
	                    // non-positive-definiteness.
	                    jb = Math.min(nb, n - j + 1);
	                    row1 = Math.max(1, j - 1);
	                    array1 = new double[row1][jb];

	                    for (m = 0; m < row1; m++) {

	                        for (p = 0; p < jb; p++) {
	                            array1[m][p] = A[m][p + j - 1];
	                        }
	                    }

	                    array2 = new double[jb][jb];

	                    for (m = 0; m < jb; m++) {

	                        for (p = 0; p < jb; p++) {
	                            array2[m][p] = A[m + j - 1][p + j - 1];
	                        }
	                    }

	                    dsyrk('U', 'T', jb, j - 1, -1.0, array1, row1, 1.0, array2, jb);
	                    dpotf2('U', jb, array2, jb, info);

	                    for (m = 0; m < jb; m++) {

	                        for (p = 0; p < jb; p++) {
	                            A[m + j - 1][p + j - 1] = array2[m][p];
	                        }
	                    }

	                    if (info[0] != 0) {
	                        info[0] = info[0] + j - 1;

	                        return;
	                    }

	                    if ( (j + jb) <= n) {

	                        // Compute the current row block
	                        for (m = 0; m < row1; m++) {

	                            for (p = 0; p < jb; p++) {
	                                array1[m][p] = A[m][p + j - 1];
	                            }
	                        }

	                        row2 = Math.max(1, j - 1);
	                        array2 = new double[row2][n - j - jb + 1];

	                        for (m = 0; m < row2; m++) {

	                            for (p = 0; p < (n - j - jb + 1); p++) {
	                                array2[m][p] = A[m][p + j + jb - 1];
	                            }
	                        }

	                        array3 = new double[jb][n - j - jb + 1];

	                        for (m = 0; m < jb; m++) {

	                            for (p = 0; p < (n - j - jb + 1); p++) {
	                                array3[m][p] = A[m + j - 1][p + j + jb - 1];
	                            }
	                        }

	                        dgemm('T', 'N', jb, n - j - jb + 1, j - 1, -1.0, array1, row1, array2, row2, 1.0, array3, jb);

	                        for (m = 0; m < jb; m++) {

	                            for (p = 0; p < (n - j - jb + 1); p++) {
	                                A[m + j - 1][p + j + jb - 1] = array3[m][p];
	                            }
	                        }

	                        array1 = new double[jb][jb];

	                        for (m = 0; m < jb; m++) {

	                            for (p = 0; p < jb; p++) {
	                                array1[m][p] = A[m + j - 1][p + j - 1];
	                            }
	                        }

	                        dtrsm('L', 'U', 'T', 'N', jb, n - j - jb + 1, 1.0, array1, jb, array3, jb);

	                        for (m = 0; m < jb; m++) {

	                            for (p = 0; p < (n - j - jb + 1); p++) {
	                                A[m + j - 1][p + j + jb - 1] = array3[m][p];
	                            }
	                        }
	                    } // if ((j + jb) <= n)
	                } // for (j = 1; j <= n; j+= nb);
	            } // if (upper)
	            else { // lower

	                // Compute the Cholesky factorization A = L*L'
	                for (j = 1; j <= n; j += nb) {

	                    // Update and factorize the current diagonal block and test for
	                    // non-positive-definiteness.
	                    jb = Math.min(nb, n - j + 1);
	                    array2 = new double[jb][jb];

	                    for (m = 0; m < jb; m++) {

	                        for (p = 0; p < jb; p++) {
	                            array2[m][p] = A[m + j - 1][p + j - 1];
	                        }
	                    }

	                    if (j != 1) {
	                        array1 = new double[jb][j - 1];

	                        for (m = 0; m < jb; m++) {

	                            for (p = 0; p < (j - 1); p++) {
	                                array1[m][p] = A[m + j - 1][p];
	                            }
	                        }

	                        dsyrk('L', 'N', jb, j - 1, -1.0, array1, jb, 1.0, array2, jb);
	                    } // if (j != 1)

	                    dpotf2('L', jb, array2, jb, info);

	                    for (m = 0; m < jb; m++) {

	                        for (p = 0; p < jb; p++) {
	                            A[m + j - 1][p + j - 1] = array2[m][p];
	                        }
	                    }

	                    if (info[0] != 0) {
	                        info[0] = info[0] + j - 1;

	                        return;
	                    } // if (info[0] != 0)

	                    if ( (j + jb) <= n) {

	                        // Compute the current block column
	                        array3 = new double[n - j - jb + 1][jb];

	                        for (m = 0; m < (n - j - jb + 1); m++) {

	                            for (p = 0; p < jb; p++) {
	                                array3[m][p] = A[m + j + jb - 1][p + j - 1];
	                            }
	                        }

	                        if (j != 1) {
	                            array1 = new double[n - j - jb + 1][j - 1];

	                            for (m = 0; m < (n - j - jb + 1); m++) {

	                                for (p = 0; p < (j - 1); p++) {
	                                    array1[m][p] = A[m + j + jb - 1][p];
	                                }
	                            }

	                            array2 = new double[jb][j - 1];

	                            for (m = 0; m < jb; m++) {

	                                for (p = 0; p < (j - 1); p++) {
	                                    array2[m][p] = A[m + j - 1][p];
	                                }
	                            }

	                            dgemm('N', 'T', n - j - jb + 1, jb, j - 1, -1.0, array1, n - j - jb + 1, array2, jb, 1.0,
	                                    array3, n - j - jb + 1);

	                            for (m = 0; m < (n - j - jb + 1); m++) {

	                                for (p = 0; p < jb; p++) {
	                                    A[m + j + jb - 1][p + j - 1] = array3[m][p];
	                                }
	                            }
	                        } // if (j != 1)

	                        array1 = new double[jb][jb];

	                        for (m = 0; m < jb; m++) {

	                            for (p = 0; p < jb; p++) {
	                                array1[m][p] = A[m + j - 1][p + j - 1];
	                            }
	                        }

	                        dtrsm('R', 'L', 'T', 'N', n - j - jb + 1, jb, 1.0, array1, jb, array3, n - j - jb + 1);

	                        for (m = 0; m < (n - j - jb + 1); m++) {

	                            for (p = 0; p < jb; p++) {
	                                A[m + j + jb - 1][p + j - 1] = array3[m][p];
	                            }
	                        }
	                    } // if ((j + jb) <= n)
	                } // for (j = 1; j <= n; j+= nb)
	            } // else lower
	        } // else use blocked code

	        return;
	    } // dpotrf

	    /**
	     * This is a port of version 3.1 LAPACK test routine DQRT01. Univ. of Tennessee, Univ. of California Berkeley and
	     * NAG Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. INTEGER LDA, LWORK, M, N .. .. Array Arguments .. DOUBLE PRECISION A( LDA, * ), AF( LDA, *
	     * ), Q( LDA, * ), $ R( LDA, * ), RESULT( * ), RWORK( * ), TAU( * ), $ WORK( LWORK ) ..
	     * 
	     * Purpose =======
	     * 
	     * DQRT01 tests DGEQRF, which computes the QR factorization of an m-by-n matrix A, and partially tests DORGQR which
	     * forms the m-by-m orthogonal matrix Q.
	     * 
	     * DQRT01 compares R with Q'*A, and checks that Q is orthogonal.
	     * 
	     * Arguments =========
	     * 
	     * M (input) INTEGER The number of rows of the matrix A. M >= 0.
	     * 
	     * N (input) INTEGER The number of columns of the matrix A. N >= 0.
	     * 
	     * A (input) DOUBLE PRECISION array, dimension (LDA,N) The m-by-n matrix A.
	     * 
	     * AF (output) DOUBLE PRECISION array, dimension (LDA,N) Details of the QR factorization of A, as returned by
	     * DGEQRF. See DGEQRF for further details.
	     * 
	     * Q (output) DOUBLE PRECISION array, dimension (LDA,M) The m-by-m orthogonal matrix Q.
	     * 
	     * R (workspace) DOUBLE PRECISION array, dimension (LDA,max(M,N))
	     * 
	     * LDA (input) INTEGER The leading dimension of the arrays A, AF, Q and R. LDA >= max(M,N).
	     * 
	     * TAU (output) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors, as
	     * returned by DGEQRF.
	     * 
	     * WORK (workspace) DOUBLE PRECISION array, dimension (LWORK)
	     * 
	     * LWORK (input) INTEGER The dimension of the array WORK.
	     * 
	     * RWORK (workspace) DOUBLE PRECISION array, dimension (M)
	     * 
	     * RESULT (output) DOUBLE PRECISION array, dimension (2) The test ratios: RESULT(1) = norm( R - Q'*A ) / ( M *
	     * norm(A) * EPS ) RESULT(2) = norm( I - Q'*Q ) / ( M * EPS )
	     */
	    private void dqrt01(final int m, final int n, final double[][] A, final double[][] AF, final double[][] Q,
	            final double[][] R, final int lda, final double[] tau, final double[] work, final int lwork,
	            final double[] rwork, final double[] result) {
	        final double rogue = -1.0E10;
	        final int info[] = new int[1];
	        int minmn;
	        double anorm;
	        double eps;
	        double resid;
	        double array1[][];
	        double array2[][];
	        int row1;
	        int p;
	        int q;

	        minmn = Math.min(m, n);
	        eps = dlamch('E'); // Epsilon

	        // Copy the matrix A to the array AF.
	        dlacpy('F', m, n, A, lda, AF, lda);

	        // Factorize the matrix A in the array AF.
	        dgeqrf(m, n, AF, lda, tau, work, lwork, info);

	        // Copy details of Q
	        dlaset('F', m, m, rogue, rogue, Q, lda);
	        row1 = Math.max(1, m - 1);
	        array1 = new double[row1][n];
	        array2 = new double[row1][n];
	        for (p = 0; p < row1; p++) {
	            for (q = 0; q < n; q++) {
	                array1[p][q] = AF[1 + p][q];
	            }
	        }
	        dlacpy('L', m - 1, n, array1, row1, array2, row1);
	        for (p = 0; p < row1; p++) {
	            for (q = 0; q < n; q++) {
	                Q[1 + p][q] = array2[p][q];
	            }
	        }

	        // Generate the m-by-m matrix Q
	        dorgqr(m, m, minmn, Q, lda, tau, work, lwork, info);

	        // Copy R
	        dlaset('F', m, n, 0.0, 0.0, R, lda);
	        dlacpy('U', m, n, AF, lda, R, lda);

	        // Compute R - Q'*A
	        dgemm('T', 'N', m, n, m, -1.0, Q, lda, A, lda, 1.0, R, lda);

	        // Compute norm(R - Q'*A)/(M * norm(A) * eps).
	        anorm = dlange('1', m, n, A, lda, rwork);
	        resid = dlange('1', m, n, R, lda, rwork);
	        if (anorm > 0.0) {
	            result[0] = ( (resid / (double) Math.max(1, m)) / anorm) / eps;
	        } else {
	            result[0] = 0;
	        }

	        // Compute I - Q'*Q
	        dlaset('F', m, m, 0.0, 1.0, R, lda);
	        dsyrk('U', 'T', m, m, -1.0, Q, lda, 1.0, R, lda);

	        // Compute norm(I - Q'*Q)/(M * eps)
	        resid = dlansy('1', 'U', m, R, lda, rwork);
	        result[1] = (resid / (double) Math.max(1, m)) / eps;
	        return;
	    } // dqrt01

	    /**
	     * This is a port of version 3.1 LAPACK test routine DQRT02. Univ. of Tennessee, Univ. of California Berkeley and
	     * NAG Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. INTEGER K, LDA, LWORK, M, N .. .. Array Arguments .. DOUBLE PRECISION A( LDA, * ), AF(
	     * LDA, * ), Q( LDA, * ), $ R( LDA, * ), RESULT( * ), RWORK( * ), TAU( * ), $ WORK( LWORK ) ..
	     * 
	     * Purpose =======
	     * 
	     * DQRT02 tests DORGQR, which generates an m-by-n matrix Q with orthonornmal columns that is defined as the product
	     * of k elementary reflectors.
	     * 
	     * Given the QR factorization of an m-by-n matrix A, DQRT02 generates the orthogonal matrix Q defined by the
	     * factorization of the first k columns of A; it compares R(1:n,1:k) with Q(1:m,1:n)'*A(1:m,1:k), and checks that
	     * the columns of Q are orthonormal.
	     * 
	     * Arguments =========
	     * 
	     * M (input) INTEGER The number of rows of the matrix Q to be generated. M >= 0.
	     * 
	     * N (input) INTEGER The number of columns of the matrix Q to be generated. M >= N >= 0.
	     * 
	     * K (input) INTEGER The number of elementary reflectors whose product defines the matrix Q. N >= K >= 0.
	     * 
	     * A (input) DOUBLE PRECISION array, dimension (LDA,N) The m-by-n matrix A which was factorized by DQRT01.
	     * 
	     * AF (input) DOUBLE PRECISION array, dimension (LDA,N) Details of the QR factorization of A, as returned by DGEQRF.
	     * See DGEQRF for further details.
	     * 
	     * Q (workspace) DOUBLE PRECISION array, dimension (LDA,N)
	     * 
	     * R (workspace) DOUBLE PRECISION array, dimension (LDA,N)
	     * 
	     * LDA (input) INTEGER The leading dimension of the arrays A, AF, Q and R. LDA >= M.
	     * 
	     * TAU (input) DOUBLE PRECISION array, dimension (N) The scalar factors of the elementary reflectors corresponding
	     * to the QR factorization in AF.
	     * 
	     * WORK (workspace) DOUBLE PRECISION array, dimension (LWORK)
	     * 
	     * LWORK (input) INTEGER The dimension of the array WORK.
	     * 
	     * RWORK (workspace) DOUBLE PRECISION array, dimension (M)
	     * 
	     * RESULT (output) DOUBLE PRECISION array, dimension (2) The test ratios: RESULT(1) = norm( R - Q'*A ) / ( M *
	     * norm(A) * EPS ) RESULT(2) = norm( I - Q'*Q ) / ( M * EPS )
	     */
	    private void dqrt02(final int m, final int n, final int k, final double[][] A, final double[][] AF,
	            final double[][] Q, final double[][] R, final int lda, final double[] tau, final double[] work,
	            final int lwork, final double[] rwork, final double[] result) {
	        final double rogue = -1.0E10;
	        final int info[] = new int[1];
	        double anorm;
	        double eps;
	        double resid;
	        int row1;
	        int p;
	        int q;
	        double array1[][];
	        double array2[][];

	        eps = dlamch('E'); // Epsilon

	        // Copy trhe first k columns of the factorization to the array Q
	        dlaset('F', m, n, rogue, rogue, Q, lda);
	        row1 = Math.max(1, m - 1);
	        array1 = new double[row1][k];
	        for (p = 0; p < row1; p++) {
	            for (q = 0; q < k; q++) {
	                array1[p][q] = AF[p + 1][q];
	            }
	        }
	        array2 = new double[row1][k];
	        dlacpy('L', m - 1, k, array1, row1, array2, row1);
	        for (p = 0; p < row1; p++) {
	            for (q = 0; q < k; q++) {
	                Q[p + 1][q] = array2[p][q];
	            }
	        }

	        // Generate the first n column of the matrix Q
	        dorgqr(m, n, k, Q, lda, tau, work, lwork, info);

	        // Copy R(1:n,1:k)
	        dlaset('F', n, k, 0.0, 0.0, R, lda);
	        dlacpy('U', n, k, AF, lda, R, lda);

	        // Compute R(1:n,1:k) - Q(1:m,1:n)' * A(1:m,1:k)
	        dgemm('T', 'N', n, k, m, -1.0, Q, lda, A, lda, 1.0, R, lda);

	        // Compute norm(R - Q'*A)/(m * norm(A) * eps).
	        anorm = dlange('1', m, k, A, lda, rwork);
	        resid = dlange('1', n, k, R, lda, rwork);
	        if (anorm > 0) {
	            result[0] = ( (resid / (double) Math.max(1, m)) / anorm) / eps;
	        } else {
	            result[0] = 0;
	        }

	        // Compute I - Q'*Q
	        dlaset('F', n, n, 0.0, 1.0, R, lda);
	        dsyrk('U', 'T', n, m, -1.0, Q, lda, 1.0, R, lda);

	        // Compute norm(I - Q'*Q)/(m * eps).
	        resid = dlansy('1', 'U', n, R, lda, rwork);
	        result[1] = (resid / (double) Math.max(1, m)) / eps;
	        return;
	    } // dqrt02

	    /**
	     * This is a port of version 3.1 LAPACK test routine DQRT03. Univ. of Tennessee, Univ. of California Berkeley and
	     * NAG Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. INTEGER K, LDA, LWORK, M, N .. .. Array Arguments .. DOUBLE PRECISION AF( LDA, * ), C(
	     * LDA, * ), CC( LDA, * ), $ Q( LDA, * ), RESULT( * ), RWORK( * ), TAU( * ), $ WORK( LWORK ) ..
	     * 
	     * Purpose =======
	     * 
	     * DQRT03 tests DORMQR, which computes Q*C, Q'*C, C*Q or C*Q'.
	     * 
	     * DQRT03 compares the results of a call to DORMQR with the results of forming Q explicitly by a call to DORGQR and
	     * then performing matrix multiplication by a call to DGEMM.
	     * 
	     * Arguments =========
	     * 
	     * M (input) INTEGER The order of the orthogonal matrix Q. M >= 0.
	     * 
	     * N (input) INTEGER The number of rows or columns of the matrix C; C is m-by-n if Q is applied from the left, or
	     * n-by-m if Q is applied from the right. N >= 0.
	     * 
	     * K (input) INTEGER The number of elementary reflectors whose product defines the orthogonal matrix Q. M >= K >= 0.
	     * 
	     * AF (input) DOUBLE PRECISION array, dimension (LDA,N) Details of the QR factorization of an m-by-n matrix, as
	     * returnedby DGEQRF. See SGEQRF for further details.
	     * 
	     * C (workspace) DOUBLE PRECISION array, dimension (LDA,N)
	     * 
	     * CC (workspace) DOUBLE PRECISION array, dimension (LDA,N)
	     * 
	     * Q (workspace) DOUBLE PRECISION array, dimension (LDA,M)
	     * 
	     * LDA (input) INTEGER The leading dimension of the arrays AF, C, CC, and Q.
	     * 
	     * TAU (input) DOUBLE PRECISION array, dimension (min(M,N)) The scalar factors of the elementary reflectors
	     * corresponding to the QR factorization in AF.
	     * 
	     * WORK (workspace) DOUBLE PRECISION array, dimension (LWORK)
	     * 
	     * LWORK (input) INTEGER The length of WORK. LWORK must be at least M, and should be M*NB, where NB is the blocksize
	     * for this environment.
	     * 
	     * RWORK (workspace) DOUBLE PRECISION array, dimension (M)
	     * 
	     * RESULT (output) DOUBLE PRECISION array, dimension (4) The test ratios compare two techniques for multiplying a
	     * random matrix C by an m-by-m orthogonal matrix Q. RESULT(1) = norm( Q*C - Q*C ) / ( M * norm(C) * EPS ) RESULT(2)
	     * = norm( C*Q - C*Q ) / ( M * norm(C) * EPS ) RESULT(3) = norm( Q'*C - Q'*C )/ ( M * norm(C) * EPS ) RESULT(4) =
	     * norm( C*Q' - C*Q' )/ ( M * norm(C) * EPS )
	     */
	    private void dqrt03(final int m, final int n, final int k, final double[][] AF, final double[][] C,
	            final double[][] CC, final double[][] Q, final int lda, final double[] tau, final double[] work,
	            final int lwork, final double[] rwork, final double[] result) {
	        final double rogue = -1.0E10;
	        char side;
	        char trans;
	        final int info[] = new int[1];
	        int iside;
	        int itrans;
	        int j;
	        int mc;
	        int nc;
	        double cnorm;
	        double eps;
	        double resid;
	        final int iseed[] = new int[] {1988, 1989, 1990, 1991};
	        int row1;
	        int p;
	        int q;
	        double array1[][];
	        double array2[][];
	        double vec1[];

	        eps = dlamch('E'); // epsilon

	        // Copy the first k columns of the factorization to the array Q
	        dlaset('F', m, m, rogue, rogue, Q, lda);
	        row1 = Math.max(1, m - 1);
	        array1 = new double[row1][k];
	        for (p = 0; p < row1; p++) {
	            for (q = 0; q < k; q++) {
	                array1[p][q] = AF[p + 1][q];
	            }
	        }
	        array2 = new double[row1][k];
	        dlacpy('L', m - 1, k, array1, row1, array2, row1);
	        for (p = 0; p < row1; p++) {
	            for (q = 0; q < k; q++) {
	                Q[p + 1][q] = array2[p][q];
	            }
	        }

	        // Generate the m by m matrix Q
	        dorgqr(m, m, k, Q, lda, tau, work, lwork, info);

	        for (iside = 1; iside <= 2; iside++) {
	            if (iside == 1) {
	                side = 'L';
	                mc = m;
	                nc = n;
	            } else {
	                side = 'R';
	                mc = n;
	                nc = m;
	            }

	            // Generate mc by nc matrix C
	            vec1 = new double[mc];
	            for (j = 1; j <= nc; j++) {
	                dlarnv(2, iseed, mc, vec1);
	                for (p = 0; p < mc; p++) {
	                    C[p][j - 1] = vec1[p];
	                }
	            } // for (j = 1; j <= nc; j++)
	            cnorm = dlange('1', mc, nc, C, lda, rwork);
	            if (cnorm == 0.0) {
	                cnorm = 1.0;
	            }

	            for (itrans = 1; itrans <= 2; itrans++) {
	                if (itrans == 1) {
	                    trans = 'N';
	                } else {
	                    trans = 'T';
	                }

	                // Copy C
	                dlacpy('F', mc, nc, C, lda, CC, lda);

	                // Apply Q or Q' to C
	                dormqr(side, trans, mc, nc, k, AF, lda, tau, CC, lda, work, lwork, info);

	                // Form explicit product and subtract
	                if ( (side == 'L') || (side == 'l')) {
	                    dgemm(trans, 'N', mc, nc, mc, -1.0, Q, lda, C, lda, 1.0, CC, lda);
	                } else {
	                    dgemm('N', trans, mc, nc, nc, -1.0, C, lda, Q, lda, 1.0, CC, lda);
	                }

	                // Compute error in the difference
	                resid = dlange('1', mc, nc, CC, lda, rwork);
	                result[ (iside - 1) * 2 + itrans - 1] = resid / (Math.max(1, m) * cnorm * eps);
	            } // for (itrans = 1; itrans <= 2; itrans++)
	        } // for (iside = 1; iside <= 2; iside++)
	        return;
	    } // dqrt03

	    /**
	     * This is a port of the 3/11/78 linpack routine drot Original code written by Jack Dongarra.
	     * 
	     * @param n int
	     * @param dx double[]
	     * @param incx int
	     * @param dy double[]
	     * @param incy int
	     * @param c double
	     * @param s double
	     */
	    private void drot(final int n, final double[] dx, final int incx, final double[] dy, final int incy,
	            final double c, final double s) {
	        double dtemp;
	        int i;
	        int ix;
	        int iy;

	        if (n <= 0) {
	            return;
	        }

	        if ( (incx != 1) || (incy != 1)) {

	            // Code for unequal increments or equal increments not equal to 1
	            ix = 0;
	            iy = 0;

	            if (incx < 0) {
	                ix = ( -n + 1) * incx;
	            }

	            if (incy < 0) {
	                iy = ( -n + 1) * incy;
	            }

	            for (i = 1; i <= n; i++) {
	                dtemp = (c * dx[ix]) + (s * dy[iy]);
	                dy[iy] = (c * dy[iy]) - (s * dx[ix]);
	                dx[ix] = dtemp;
	                ix = ix + incx;
	                iy = iy + incy;
	            } // for (i = 1; i <= n; i++)

	            return;
	        } // if ((incx != 1) || (incy != 1))

	        // Code for both increments equal to 1
	        for (i = 0; i < n; i++) {
	            dtemp = (c * dx[i]) + (s * dy[i]);
	            dy[i] = (c * dy[i]) - (s * dx[i]);
	            dx[i] = dtemp;
	        } // for (i = 0; i < n; i++)

	        return;
	    } // drot

	    /**
	     * Routine ported from 12/3/93 linpack dscal Original version written by Jack Dongarra Scales a vector by a
	     * constant.
	     * 
	     * @param n int
	     * @param da double
	     * @param dx double[]
	     * @param incx int
	     */
	    private void dscal(final int n, final double da, final double[] dx, final int incx) {
	        int nincx;
	        int i;
	        int m;
	        int mp1;

	        if ( (n <= 0) || (incx <= 0)) {
	            return;
	        }

	        if (incx != 1) {

	            // Code for increment not equal to 1
	            nincx = n * incx;

	            for (i = 0; i < nincx; i += incx) {
	                dx[i] = da * dx[i];
	            } // for (i = 0; i < nincx; i += incx)

	            return;
	        } // if (incx != 1)

	        // Code for increment equal to 1
	        m = n % 5;

	        if (m != 0) {

	            for (i = 0; i < m; i++) {
	                dx[i] = da * dx[i];
	            }

	            if (n < 5) {
	                return;
	            }
	        } // if (m != 0)

	        mp1 = m + 1;

	        for (i = mp1; i <= n; i += 5) {
	            dx[i - 1] = da * dx[i - 1];
	            dx[i] = da * dx[i];
	            dx[i + 1] = da * dx[i + 1];
	            dx[i + 2] = da * dx[i + 2];
	            dx[i + 3] = da * dx[i + 3];
	        } // for (i = mp1; i <= n; i+= 5)

	        return;
	    } // dscal

	    /**
	     * This is a port of the version 3.1 LAPACK test routine DSGT01 Original DSGT01 created by Univ. of Tennessee, Univ.
	     * of California Berkeley, and NAG Ltd., November, 2006 dsgt01 checks a decomposition of the form A Z = B Z D or A B
	     * Z = Z D or B A Z = Z D where A is a symmetric matrix, B is symmetric positive definite, Z is orthogonal, and D is
	     * diagonal. One of the following test ratios is computed: itype = 1: result[0] = | A Z - B Z D | / ( |A| |Z| n ulp
	     * ) itype = 2: result[0] = | A B Z - Z D | / ( |A| |Z| n ulp ) itype = 3: result[0] = | B A Z - Z D | / ( |A| |Z| n
	     * ulp )
	     * 
	     * @param itype input int The form of the symmetric generalized eigenproblem. = 1: A*Z = (lambda)*B*Z = 2: A*B*Z =
	     *            (lambda)*Z = 3: B*A*Z = (lambda)*Z
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrices A and B is
	     *            stored. = 'U': Upper triangular = 'L': Lower triangular
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param m input int The number of eigenvalues found. 0 <= m <= n.
	     * @param A input double[][] of dimension (lda,n). The original symmetric matrix A.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param B input double[][] of dimension (ldb,n). The original symmetric positive definite matrix B.
	     * @param ldb input int The leading dimension of the array B. ldb >= max(1,n).
	     * @param Z input double[][] of dimension (ldz,m). The computed eigenvectors of the generalized eigenproblem.
	     * @param ldz input int The leading dimension of the array Z. ldz >= max(1,n).
	     * @param D input double[] of dimension m. The computed eigenvalues of the generalized eigenproblem.
	     * @param work workspace double[] of dimension n*n.
	     * @param result output double[] of dimension 1. The test ratio as described above.
	     */
	    private void dsgt01(final int itype, final char uplo, final int n, final int m, final double[][] A, final int lda,
	            final double[][] B, final int ldb, final double[][] Z, final int ldz, final double[] D,
	            final double[] work, final double[] result) {
	        int i;
	        int j;
	        double anorm;
	        double ulp;
	        final double[][] work2D = new double[n][n];

	        result[0] = 0.0;

	        if (n <= 0) {
	            return;
	        }

	        ulp = dlamch('E');

	        // Compute product of 1-norms of A and Z.
	        anorm = dlansy('1', uplo, n, A, lda, work) * dlange('1', n, m, Z, ldz, work);

	        if (anorm == 0.0) {
	            anorm = 1.0;
	        }

	        if (itype == 1) {

	            // Norm of AZ - BZD
	            dsymm('L', uplo, n, m, 1.0, A, lda, Z, ldz, 0.0, work2D, n);

	            for (i = 0; i < m; i++) {

	                for (j = 0; j < n; j++) {
	                    Z[j][i] = D[i] * Z[j][i];
	                }
	            }

	            dsymm('L', uplo, n, m, 1.0, B, ldb, Z, ldz, -1.0, work2D, n);

	            for (i = 0; i < n; i++) {

	                for (j = 0; j < n; j++) {
	                    work[i + (n * j)] = work2D[i][j];
	                }
	            }

	            result[0] = (dlange('1', n, m, work2D, n, work) / anorm) / (n * ulp);
	        } // if (itype == 1)
	        else if (itype == 2) {

	            // Norm of ABZ - ZD
	            dsymm('L', uplo, n, m, 1.0, B, ldb, Z, ldz, 0.0, work2D, n);

	            for (i = 0; i < m; i++) {

	                for (j = 0; j < n; j++) {
	                    Z[j][i] = D[i] * Z[j][i];
	                }
	            }

	            dsymm('L', uplo, n, m, 1.0, A, lda, work2D, n, -1.0, Z, ldz);

	            for (i = 0; i < n; i++) {

	                for (j = 0; j < n; j++) {
	                    work[i + (n * j)] = work2D[i][j];
	                }
	            }

	            result[0] = (dlange('1', n, m, Z, ldz, work) / anorm) / (n * ulp);
	        } // else if (itype == 2)
	        else { // itype == 3

	            // Norm of BAZ - ZD
	            dsymm('L', uplo, n, m, 1.0, A, lda, Z, ldz, 0.0, work2D, n);

	            for (i = 0; i < m; i++) {

	                for (j = 0; j < n; j++) {
	                    Z[j][i] = D[i] * Z[j][i];
	                }
	            }

	            dsymm('L', uplo, n, m, 1.0, B, ldb, work2D, n, -1.0, Z, ldz);

	            for (i = 0; i < n; i++) {

	                for (j = 0; j < n; j++) {
	                    work[i + (n * j)] = work2D[i][j];
	                }
	            }

	            result[0] = (dlange('1', n, m, Z, ldz, work) / anorm) / (n * ulp);
	        } // else itype == 3

	        return;
	    } // dsgt01
	    
	   



	    /**
	     * This is a port of version 3.1 LAPACK test routine DSTECH Original DSTECH created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 Let T be the tridiagonal matrix with diagonal entries A[0]
	     * ,..., A[n-1] and offdiagonal entries B[0] ,..., B[n-2]). dstech checks to see if eig[0], ..., eig[n-1] are indeed
	     * accurate eigenvalues of T. It does this by expanding each eig[i] into an interval [svd[i] - eps, svd[i] + eps],
	     * merging overlapping intervals if any, and using Sturm sequences to count and verify whether each resulting
	     * interval has the correct number of eigenvalues (using dstect). Here eps = tol * mazheps * maxeig, where macheps
	     * is the machine precision and maxeig is the absolute value of the largest eigenvalue. If each interval contains
	     * the correct number of eigenvalues, info[0] = 0 is returned, otherwise info is the index of the first eigenvalue
	     * in the first bad interval.
	     * 
	     * @param n (input) int The dimension of the tridiagonal matrix T.
	     * @param A (input) double[] of dimension (n) The diagonal entries of the tridiagonal matrix T.
	     * @param B (input) double[] of dimension (n-1) The offdiagonal entries of the tridiagonal matrix T.
	     * @param eig (input) double[] of dimension (n) The purported eigenvalues to be checked.
	     * @param tol double Error tolerance for checking, a multiple of the machine precision.
	     * @param work (workspace) double[] of dimension (n)
	     * @param info (output) int[] 0 if the eigenvalues are all correct (to within 1 +- tol*mazheps*maxeig >0 if the
	     *            interval containing the info-th eigenvalue contains the incorrect number of eigenvalues.
	     */
	    private void dstech(final int n, final double[] A, final double[] B, final double[] eig, final double tol,
	            final double[] work, final int[] info) {
	        int bpnt;
	        int count;
	        int i;
	        int isub;
	        int j;
	        final int[] numl = new int[1];
	        final int[] numu = new int[1];
	        int tpnt;
	        double emin;
	        double eps;
	        double lower;
	        double mx;
	        double tuppr;
	        double unflep;
	        double upper;

	        // Check input parameters
	        info[0] = 0;

	        if (n == 0) {
	            return;
	        }

	        if (n < 0) {
	            info[0] = -1;

	            return;
	        }

	        if (tol < 0) {
	            info[0] = -5;

	            return;
	        }

	        // Get machine constants
	        eps = dlamch('E') * dlamch('B');
	        unflep = dlamch('S') / eps;
	        eps = tol * eps;

	        // Compute maximum absolute eigenvalue, error tolerance
	        mx = Math.abs(eig[0]);

	        for (i = 1; i < n; i++) {
	            mx = Math.max(mx, Math.abs(eig[i]));
	        }

	        eps = Math.max(eps * mx, unflep);

	        // Sort eigenvalues from eig into work
	        for (i = 0; i < n; i++) {
	            work[i] = eig[i];
	        }

	        for (i = 1; i <= (n - 1); i++) {
	            isub = 1;
	            emin = work[0];

	            for (j = 2; j <= (n + 1 - i); j++) {

	                if (work[j - 1] < emin) {
	                    isub = j;
	                    emin = work[j - 1];
	                } // if (work[j-1] < emin)
	            } // for (j = 2; j <= n+1-i; j++)

	            if (isub != (n + 1 - i)) {
	                work[isub - 1] = work[n - i];
	                work[n - i] = emin;
	            } // if (isub != (n+1-i))
	        } // for (i = 1; i <= n-1; i++)

	        // tpnt points to singular value at right endpoint of interval
	        // bpnt points to singular value at left endpoint of interval
	        tpnt = 1;
	        bpnt = 1;

	        // Begin loop over all intervals
	        do {
	            upper = work[tpnt - 1] + eps;
	            lower = work[bpnt - 1] - eps;

	            // Begin loop merging overlapping intervals
	            do {

	                if (bpnt == n) {
	                    break;
	                }

	                tuppr = work[bpnt] + eps;

	                if (tuppr < lower) {
	                    break;
	                }

	                // Merge
	                bpnt = bpnt + 1;
	                lower = work[bpnt - 1] - eps;
	            } while (true);

	            // Count singular values in interval [lower, upper]
	            dstect(n, A, B, lower, numl);
	            dstect(n, A, B, upper, numu);
	            count = numu[0] - numl[0];

	            if (count != (bpnt - tpnt + 1)) {

	                // Wrong number of singular values in interval
	                info[0] = tpnt;

	                return;
	            } // if (count != (bpnt - tpnt + 1))

	            tpnt = bpnt + 1;
	            bpnt = tpnt;
	        } while (tpnt <= n);

	        return;
	    } // dstech

	    /**
	     * This is a port of version 3.1 LAPACK test routine DSTECT Original DSTECT created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dstect counts the number num of eigenvalues of a tridiagonal
	     * matrix T which are less than or equal to shift. T has diagonal entries A[0], ... , A[n-1], and offdiagonal
	     * entries B[0], ..., B[n-1]. See W. Kahan "Accurate Eigenvalues of a Symmetric TriDiagonal Matrix", Report CS41,
	     * Computer Science Department, Stanford University, July 21, 1966
	     * 
	     * @param n (input) int The dimension of the tridiagonal matrix T.
	     * @param A (input) double[] of dimension (n) The diagonal entries of the tridiagonal matrix T.
	     * @param B (input) double[] of dimension (n-1) The offdiagonal entries of the tridiagonal matrix T.
	     * @param shift (input) double The shift used.
	     * @param num (output) int[] The number of eigenvalues of T less than or equal to shift.
	     */
	    private void dstect(final int n, final double[] A, final double[] B, final double shift, final int[] num) {
	        int i;
	        double m1;
	        double m2;
	        double mx;
	        double ovfl;
	        double sov;
	        double sshift;
	        double ssun;
	        double sun;
	        double tmp;
	        double tom;
	        double u;
	        double unfl;

	        // Get machine constants
	        unfl = dlamch('S');
	        ovfl = dlamch('O');

	        // Find largest entry
	        mx = Math.abs(A[0]);

	        for (i = 0; i < (n - 1); i++) {
	            mx = Math.max(mx, Math.abs(A[i + 1]));
	            mx = Math.max(mx, Math.abs(B[i]));
	        } // for (i = 0; i < n-1; i++)

	        // Handle easy cases, including zero matrix
	        if (shift >= (3.0 * mx)) {
	            num[0] = n;

	            return;
	        }

	        if (shift < ( -3.0 * mx)) {
	            num[0] = 0;

	            return;
	        }

	        // Compute scale factors as in Kahan's report
	        // At this point, mx != 0 so we can divide by it
	        sun = Math.sqrt(unfl);
	        ssun = Math.sqrt(sun);
	        sov = Math.sqrt(ovfl);
	        tom = ssun * sov;

	        if (mx <= 1.0) {
	            m1 = 1.0 / mx;
	            m2 = tom;
	        } else {
	            m1 = 1.0;
	            m2 = tom / mx;
	        }

	        // Begin counting
	        num[0] = 0;
	        sshift = (shift * m1) * m2;
	        u = ( (A[0] * m1) * m2) - sshift;

	        if (u <= sun) {

	            if (u <= 0.0) {
	                num[0] = num[0] + 1;

	                if (u > -sun) {
	                    u = -sun;
	                }
	            } // if (u <= 0.0)
	            else { // u > 0.0
	                u = sun;
	            } // else u > 0.0
	        } // if (u <= sun)

	        for (i = 1; i < n; i++) {
	            tmp = (B[i - 1] * m1) * m2;
	            u = ( ( (A[i] * m1) * m2) - (tmp * (tmp / u))) - sshift;

	            if (u <= sun) {

	                if (u <= 0.0) {
	                    num[0] = num[0] + 1;

	                    if (u > -sun) {
	                        u = -sun;
	                    }
	                } // if (u <= 0.0)
	                else { // u > 0.0
	                    u = sun;
	                } // else u > 0.0
	            } // if (u <= sun)
	        } // for (i = 1; i < n; i++)

	        return;
	    } // dstect

	    /**
	     * This is a port of version 3.1 LAPACK routine DSTEQR Original DSTEQR created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dsteqr computes all eigenvalues and, optionally, eigenvectors
	     * of a symmetric tridiagonal matrix using the implicit QL or QR method. The eigenvectors of a full or band
	     * symmetric matrix can also be found if dsytrd or dsptrd or dsbtrd has been used to reduce this matrix to
	     * tridiagonal form.
	     * 
	     * @param compz input char = 'N': Compute eigenvalues only. = 'V': Compute eigenvalues and eigenvectors of the
	     *            original symmetric matrix. On entry, Z must contain the orthogonal matrix used to reduce the original
	     *            matrix to tridiagonal form. = 'I': Compute eigenvalues and eigenvectors of the tridiagonal matrix. Z
	     *            is initialized to the identity matrix.
	     * @param n input int The order of the matrix. n >= 0.
	     * @param d input/output double[] of dimension n. On entry, the diagonal elements of the tridiagonal matrix. On
	     *            exit, if info = 0, the eigenvalues in ascending order.
	     * @param e input/output double[] of dimension n-1 On entry, the (n-1) subdiagonal elements of the tridiagonal
	     *            matrix. On exit, e has been destroyed.
	     * @param Z input/output double[][] of dimension ldz by n. On entry, if compz = 'V', then Z contains the orthogonal
	     *            matrix used in reduction to tridiagonal form. On exit, if info[0] = 0, then if compz = 'V', Z contains
	     *            the orthonormal eigenvectors of the original symmetric matrix. and if compz = 'I', Z contains the
	     *            orthonormal eigenvectors of the symmetric tridiagonal matrix. If compz = 'N', then Z is not
	     *            referenced.
	     * @param ldz input int The leading dimension of the array Z. ldz >= 1, and if eigenvectors are desired, then ldz >=
	     *            max(1,n).
	     * @param work workspace double[] of dimension max(1,2*n-2). If compz = 'N', then work is not referenced.
	     * @param info output int[] = 0: successful exit. < 0: If info[0] = -i, then the i-th argument had an illegal value
	     *            > 0: The algorithm failed to find all the eigenvalues in a total of 30*n iterations; if info[0]= i,
	     *            then i elements of e have not converged to zero; on exit, d and e contain the elements of a symmetric
	     *            tridiagonal matrix which is orthogonally similar to the original matrix.
	     */
	    private void dsteqr(final char compz, final int n, final double[] d, final double[] e, final double[][] Z,
	            final int ldz, final double[] work, final int[] info) {
	        final int maxit = 30;
	        int i;
	        int icompz;
	        int ii;
	        int iscale;
	        int j;
	        int jtot;
	        int k;
	        int L;
	        int L1;
	        int lend;
	        int lendm1;
	        int lendp1;
	        int lendsv;
	        int lm1;
	        int lsv;
	        int m;
	        int mm;
	        int mm1;
	        int nm1;
	        int nmaxit;
	        int ptr1;
	        int ptr2;
	        double anorm;
	        double b;
	        final double[] c = new double[1];
	        double eps;
	        double eps2;
	        double f;
	        double g;
	        double p;
	        final double[] r = new double[1];
	        final double[] rt1 = new double[1];
	        ;

	        final double[] rt2 = new double[1];
	        final double[] s = new double[1];
	        double safmax;
	        double safmin;
	        double ssfmax;
	        double ssfmin;
	        double tst;
	        double[] vector1;
	        double[] vector2;
	        double[][] array1;
	        double val;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (compz == 'N') || (compz == 'n')) {
	            icompz = 0;
	        } else if ( (compz == 'V') || (compz == 'v')) {
	            icompz = 1;
	        } else if ( (compz == 'I') || (compz == 'i')) {
	            icompz = 2;
	        } else {
	            icompz = -1;
	        }

	        if (icompz < 0) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if ( (ldz < 1) || ( (icompz > 0) && (ldz < Math.max(1, n)))) {
	            info[0] = -6;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dsteqr had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if (n == 1) {

	            if (icompz == 2) {
	                Z[0][0] = 1.0;
	            }

	            return;
	        } // if (n == 1)

	        // Determine the unit roundoff and over/underflow thresholds.
	        eps = dlamch('E');
	        eps2 = eps * eps;
	        safmin = dlamch('S');
	        safmax = 1.0 / safmin;
	        ssfmax = Math.sqrt(safmax) / 3.0;
	        ssfmin = Math.sqrt(safmin) / eps2;

	        // Compute the eigenvalues and eigenvectors of the tridiagonal matrix.
	        if (icompz == 2) {
	            dlaset('F', n, n, 0.0, 1.0, Z, ldz);
	        }

	        nmaxit = n * maxit;
	        jtot = 0;

	        // Determine where the matrix splits and choose QL or QR iteration for
	        // each block, according to whether top or bottom diagonal element is
	        // smaller.
	        L1 = 1;
	        nm1 = n - 1;

	        primary: {

	            // loop1:
	            do {

	                // loop2:
	                do {

	                    // loop3:
	                    do {

	                        if (L1 > n) {
	                            break primary;
	                        } // if (L1 > n)

	                        if (L1 > 1) {
	                            e[L1 - 2] = 0.0;
	                        } // if (L1 > 1)

	                        set4: {

	                            if (L1 <= nm1) {

	                                for (m = L1; m <= nm1; m++) {
	                                    tst = Math.abs(e[m - 1]);

	                                    if (tst == 0.0) {
	                                        break set4;
	                                    } // if (test == 0.0)

	                                    if (tst <= (Math.sqrt(Math.abs(d[m - 1])) * Math.sqrt(Math.abs(d[m])) * eps)) {
	                                        e[m - 1] = 0.0;

	                                        break set4;
	                                    } // if (tst <= (Math.sqrt(Math.abs(d[m-1])) *
	                                } // for (m = L1; m <= nm1; m++)
	                            } // if (L1 <= nm1)

	                            m = n;
	                        } // set4

	                        L = L1;
	                        lsv = L;
	                        lend = m;
	                        lendsv = lend;
	                        L1 = m + 1;
	                    } // loop3
	                    while (lend == L);

	                    // Scale submatrix in rows and columns L-1 to lend-1.
	                    vector1 = new double[lend - L + 1];

	                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
	                        vector1[ptr1] = d[ptr1 + L - 1];
	                    }

	                    vector2 = new double[lend - L];

	                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
	                        vector2[ptr1] = e[ptr1 + L - 1];
	                    }

	                    anorm = dlanst('I', lend - L + 1, vector1, vector2);
	                    iscale = 0;
	                } // loop2
	                while (anorm == 0.0);

	                if (anorm > ssfmax) {
	                    iscale = 1;
	                    array1 = new double[lend - L + 1][1];

	                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
	                        array1[ptr1][0] = d[ptr1 + L - 1];
	                    }

	                    dlascl('G', 0, 0, anorm, ssfmax, lend - L + 1, 1, array1, lend - L + 1, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #1 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
	                        d[ptr1 + L - 1] = array1[ptr1][0];
	                    }

	                    array1 = new double[lend - L][1];

	                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
	                        array1[ptr1][0] = e[ptr1 + L - 1];
	                    }

	                    dlascl('G', 0, 0, anorm, ssfmax, lend - L, 1, array1, lend - L, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #2 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
	                        e[ptr1 + L - 1] = array1[ptr1][0];
	                    }
	                } // if (anorm > ssfmax)
	                else if (anorm < ssfmin) {
	                    iscale = 2;
	                    array1 = new double[lend - L + 1][1];

	                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
	                        array1[ptr1][0] = d[ptr1 + L - 1];
	                    }

	                    dlascl('G', 0, 0, anorm, ssfmin, lend - L + 1, 1, array1, lend - L + 1, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #3 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lend - L + 1); ptr1++) {
	                        d[ptr1 + L - 1] = array1[ptr1][0];
	                    }

	                    array1 = new double[lend - L][1];

	                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
	                        array1[ptr1][0] = e[ptr1 + L - 1];
	                    }

	                    dlascl('G', 0, 0, anorm, ssfmin, lend - L, 1, array1, lend - L, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #4 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lend - L); ptr1++) {
	                        e[ptr1 + L - 1] = array1[ptr1][0];
	                    }
	                } // else if (anorm < ssfmin)

	                // Choose between QL and QR iteration
	                if (Math.abs(d[lend - 1]) < Math.abs(d[L - 1])) {
	                    lend = lsv;
	                    L = lendsv;
	                } // if (Math.abs(d[lend-1]) < Math.abs(d[L-1]))

	                set5: {

	                    if (lend > L) {

	                        // QL iteration
	                        // Look for small subdiagonal element
	                        // loop6:
	                        do {

	                            loop7: do {

	                                set8: {

	                                    if (L != lend) {
	                                        lendm1 = lend - 1;

	                                        for (m = L; m <= lendm1; m++) {
	                                            tst = e[m - 1] * e[m - 1];

	                                            if (tst <= ( (eps2 * Math.abs(d[m - 1]) * Math.abs(d[m])) + safmin)) {
	                                                break set8;
	                                            } // if (tst <= (eps2 * Math.abs(d[m-1]) *
	                                        } // for (m = L; m <= lendm1; m++)
	                                    } // if (L != lend)

	                                    m = lend;
	                                } // set8

	                                if (m < lend) {
	                                    e[m - 1] = 0.0;
	                                } // if (m < lend)

	                                p = d[L - 1];

	                                if (m == L) {
	                                    break loop7;
	                                } // if (m == L)

	                                // If the remaining matrix is 2-by-2, use dlae2 or dlaev2
	                                // to compute its eigensystem.
	                                if (m == (L + 1)) {

	                                    if (icompz > 0) {
	                                        dlaev2(d[L - 1], e[L - 1], d[L], rt1, rt2, c, s);
	                                        array1 = new double[n][2];

	                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
	                                                array1[ptr1][ptr2] = Z[ptr1][ptr2 + L - 1];
	                                            }
	                                        }

	                                        dlasr('R', 'V', 'B', n, 2, c, s, array1, n);

	                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
	                                                Z[ptr1][ptr2 + L - 1] = array1[ptr1][ptr2];
	                                            }
	                                        }
	                                    } // if (icompz > 0)
	                                    else {
	                                        dlae2(d[L - 1], e[L - 1], d[L], rt1, rt2);
	                                    }

	                                    d[L - 1] = rt1[0];
	                                    d[L] = rt2[0];
	                                    e[L - 1] = 0.0;
	                                    L = L + 2;

	                                    if (L <= lend) {
	                                        continue loop7;
	                                    }

	                                    break set5;
	                                } // if (m == (L+1))

	                                if (jtot == nmaxit) {
	                                    break set5;
	                                } // if (jtot == nmaxit)

	                                jtot = jtot + 1;

	                                // Form shift
	                                g = (d[L] - p) / (2.0 * e[L - 1]);
	                                r[0] = dlapy2(g, 1.0);

	                                if (g >= 0) {
	                                    val = Math.abs(r[0]);
	                                } else {
	                                    val = -Math.abs(r[0]);
	                                }

	                                g = d[m - 1] - p + (e[L - 1] / (g + val));
	                                s[0] = 1.0;
	                                c[0] = 1.0;
	                                p = 0.0;

	                                // Inner loop
	                                mm1 = m - 1;
	                                vector1 = new double[m - L];
	                                vector2 = new double[m - L];

	                                for (i = mm1; i >= L; i--) {
	                                    f = s[0] * e[i - 1];
	                                    b = c[0] * e[i - 1];
	                                    dlartg(g, f, c, s, r);

	                                    if (i != (m - 1)) {
	                                        e[i] = r[0];
	                                    } // if (i != (m-1))

	                                    g = d[i] - p;
	                                    r[0] = ( (d[i - 1] - g) * s[0]) + (2.0 * c[0] * b);
	                                    p = s[0] * r[0];
	                                    d[i] = g + p;
	                                    g = (c[0] * r[0]) - b;

	                                    // If eigenvectors are desired, then save rotations
	                                    if (icompz > 0) {
	                                        vector1[i - L] = c[0];
	                                        vector2[i - L] = -s[0];
	                                    } // if (icompz > 0)
	                                } // for (i = mm1; i >= L; i--)

	                                // If eigenvectors are desired, then apply saved rotations.
	                                if (icompz > 0) {
	                                    mm = m - L + 1;
	                                    array1 = new double[n][mm];

	                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
	                                            array1[ptr1][ptr2] = Z[ptr1][ptr2 + L - 1];
	                                        }
	                                    }

	                                    dlasr('R', 'V', 'B', n, mm, vector1, vector2, array1, n);

	                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
	                                            Z[ptr1][ptr2 + L - 1] = array1[ptr1][ptr2];
	                                        }
	                                    }
	                                } // if (icompz > 0)

	                                d[L - 1] = d[L - 1] - p;
	                                e[L - 1] = g;
	                            } // loop7
	                            while (true);

	                            // Eigenvalue found
	                            d[L - 1] = p;
	                            L = L + 1;
	                        } // loop6
	                        while (L <= lend);
	                    } // if (lend > L)
	                    else {

	                        // QR iteration
	                        // Look for small superdiagonal element
	                        // loop9:
	                        do {

	                            loop10: do {

	                                set11: {

	                                    if (L != lend) {
	                                        lendp1 = lend + 1;

	                                        for (m = L; m >= lendp1; m--) {
	                                            tst = e[m - 2] * e[m - 2];

	                                            if (tst <= ( (eps2 * Math.abs(d[m - 1]) * Math.abs(d[m - 2])) + safmin)) {
	                                                break set11;
	                                            } // if (tst <= (eps2 * Math.abs(d[m-1]) *
	                                        } // for (m = L; m >= lendp1; m--)
	                                    } // if (L != lend)

	                                    m = lend;
	                                } // set11

	                                if (m > lend) {
	                                    e[m - 2] = 0.0;
	                                } // if (m > lend)

	                                p = d[L - 1];

	                                if (m == L) {
	                                    break loop10;
	                                } // if (m == L)

	                                // If the remaining matrix is 2-by-2, use dlae2 or dlaev2
	                                // to compute its eigensystem.
	                                if (m == (L - 1)) {

	                                    if (icompz > 0) {
	                                        dlaev2(d[L - 2], e[L - 2], d[L - 1], rt1, rt2, c, s);
	                                        array1 = new double[n][2];

	                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
	                                                array1[ptr1][ptr2] = Z[ptr1][ptr2 + L - 2];
	                                            }
	                                        }

	                                        dlasr('R', 'V', 'F', n, 2, c, s, array1, n);

	                                        for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                            for (ptr2 = 0; ptr2 < 2; ptr2++) {
	                                                Z[ptr1][ptr2 + L - 2] = array1[ptr1][ptr2];
	                                            }
	                                        }
	                                    } // if (icompz > 0)
	                                    else {
	                                        dlae2(d[L - 2], e[L - 2], d[L - 1], rt1, rt2);
	                                    }

	                                    d[L - 2] = rt1[0];
	                                    d[L - 1] = rt2[0];
	                                    e[L - 2] = 0.0;
	                                    L = L - 2;

	                                    if (L >= lend) {
	                                        continue loop10;
	                                    } // if (L >= lend)

	                                    break set5;
	                                } // if (m == (L-1))

	                                if (jtot == nmaxit) {
	                                    break set5;
	                                } // if (jtot == nmaxit)

	                                jtot = jtot + 1;

	                                // Form shift.
	                                g = (d[L - 2] - p) / (2.0 * e[L - 2]);
	                                r[0] = dlapy2(g, 1.0);

	                                if (g >= 0.0) {
	                                    val = Math.abs(r[0]);
	                                } else {
	                                    val = -Math.abs(r[0]);
	                                }

	                                g = d[m - 1] - p + (e[L - 2] / (g + val));

	                                s[0] = 1.0;
	                                c[0] = 1.0;
	                                p = 0.0;

	                                // Inner loop
	                                lm1 = L - 1;
	                                vector1 = new double[L - m];
	                                vector2 = new double[L - m];

	                                for (i = m; i <= lm1; i++) {
	                                    f = s[0] * e[i - 1];
	                                    b = c[0] * e[i - 1];
	                                    dlartg(g, f, c, s, r);

	                                    if (i != m) {
	                                        e[i - 2] = r[0];
	                                    } // if (i != m)

	                                    g = d[i - 1] - p;
	                                    r[0] = ( (d[i] - g) * s[0]) + (2.0 * c[0] * b);
	                                    p = s[0] * r[0];
	                                    d[i - 1] = g + p;
	                                    g = (c[0] * r[0]) - b;

	                                    // If eigenvalues are desired, then save rotations
	                                    if (icompz > 0) {
	                                        vector1[i - m] = c[0];
	                                        vector2[i - m] = s[0];
	                                    } // if (icompz > 0)
	                                } // for (i = m; i <= lm1; i++)

	                                // If eigenvectors are desired, then apply saved rotations
	                                if (icompz > 0) {
	                                    mm = L - m + 1;
	                                    array1 = new double[n][mm];

	                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
	                                            array1[ptr1][ptr2] = Z[ptr1][ptr2 + m - 1];
	                                        }
	                                    }

	                                    dlasr('R', 'V', 'F', n, mm, vector1, vector2, array1, n);

	                                    for (ptr1 = 0; ptr1 < n; ptr1++) {

	                                        for (ptr2 = 0; ptr2 < mm; ptr2++) {
	                                            Z[ptr1][ptr2 + m - 1] = array1[ptr1][ptr2];
	                                        }
	                                    }
	                                } // if (icompz > 0)

	                                d[L - 1] = d[L - 1] - p;
	                                e[lm1 - 1] = g;
	                            } // loop10
	                            while (true);

	                            // Eigenvalue found.
	                            d[L - 1] = p;
	                            L = L - 1;
	                        } // loop9
	                        while (L >= lend);
	                    } // else QR iteration
	                } // set5

	                // Undo scaling if necessary
	                if (iscale == 1) {
	                    array1 = new double[lendsv - lsv + 1][1];

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
	                        array1[ptr1][0] = d[ptr1 + lsv - 1];
	                    }

	                    dlascl('G', 0, 0, ssfmax, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #5 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
	                        d[ptr1 + lsv - 1] = array1[ptr1][0];
	                    }

	                    array1 = new double[lendsv - lsv][1];

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
	                        array1[ptr1][0] = e[ptr1 + lsv - 1];
	                    }

	                    dlascl('G', 0, 0, ssfmax, anorm, lendsv - lsv, 1, array1, lendsv - lsv, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #6 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
	                        e[ptr1 + lsv - 1] = array1[ptr1][0];
	                    }
	                } // if (iscale == 1)
	                else if (iscale == 2) {
	                    array1 = new double[lendsv - lsv + 1][1];

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
	                        array1[ptr1][0] = d[ptr1 + lsv - 1];
	                    }

	                    dlascl('G', 0, 0, ssfmin, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #7 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv + 1); ptr1++) {
	                        d[ptr1 + lsv - 1] = array1[ptr1][0];
	                    }

	                    array1 = new double[lendsv - lsv][1];

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
	                        array1[ptr1][0] = e[ptr1 + lsv - 1];
	                    }

	                    dlascl('G', 0, 0, ssfmin, anorm, lendsv - lsv, 1, array1, lendsv - lsv, info);

	                    if (info[0] != 0) {
	                        System.out.println("dsteqr call to dlascl #8 had info[0] = " + info[0] + "\n");
	                    }

	                    for (ptr1 = 0; ptr1 < (lendsv - lsv); ptr1++) {
	                        e[ptr1 + lsv - 1] = array1[ptr1][0];
	                    }
	                } // else if (iscale == 2)

	                // Check for no convergence to an eigenvalue after a total of
	                // n*maxit iterations
	            } // loop1
	            while (jtot < nmaxit);

	            for (i = 0; i < (n - 1); i++) {

	                if (e[i] != 0.0) {
	                    info[0] = info[0] + 1;
	                }
	            } // for (i = 0; i < n-1; i++)

	            if (info[0] != 0) {
	                System.out.println("dsteqr nonzero e produced info[0] = " + info[0] + "\n");
	            }

	            return;
	        } // primary

	        // Order eigenvalues and eigenvectors.
	        if (icompz == 0) {

	            // Use quick sort
	            dlasrt('I', n, d, info);

	            if (info[0] != 0) {
	                System.out.println("dsteqr call to dlasrt produced info[0] = " + info[0] + "\n");
	            }
	        } // if (icompz == 0)
	        else { // icompz != 0

	            // Use selection sort to minimize swaps of eigenvectors
	            for (ii = 2; ii <= n; ii++) {
	                i = ii - 1;
	                k = i;
	                p = d[i - 1];

	                for (j = ii; j <= n; j++) {

	                    if (d[j - 1] < p) {
	                        k = j;
	                        p = d[j - 1];
	                    } // if (d[j-1] < p)
	                } // for (j == ii; j <= n; j++)

	                if (k != i) {
	                    d[k - 1] = d[i - 1];
	                    d[i - 1] = p;

	                    for (ptr1 = 0; ptr1 < n; ptr1++) {
	                        val = Z[ptr1][i - 1];
	                        Z[ptr1][i - 1] = Z[ptr1][k - 1];
	                        Z[ptr1][k - 1] = val;
	                    } // for (ptr1 = 0; ptr1 < n; ptr1++)
	                } // if (k != i)
	            } // for (ii = 2; ii <= n; ii++)
	        } // else icompz != 0

	        return;
	    } // dsteqr

	    /**
	     * This is a port of version 3.1 LAPACK routine DSTERF Original DSTERF created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dsterf computes all the eigenvalues of a symmetric tridiagonal
	     * matrix using the Pal-Walker-Kahan variant of the QL or QR algorithm.
	     * 
	     * @param n input int The order of the matrix. n >= 0.
	     * @param d input/output double[] of dimension n. On entry, the n diagonal elements of the tridiagonal matrix. On
	     *            exit, if info[0] = 0, the eigenvalues in ascending order
	     * @param e input/order double[] of dimension n-1 On entry, the (n-1) subdiagonal elements in the tridiagonal
	     *            matrix. On exit, e has been destroyed.
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value > 0:
	     *            The algorithm failed to find all of the eigenvalues in a total of 30*n iterations; if info = i, then i
	     *            elements of e have not converged to zero.
	     */
	    private void dsterf(final int n, final double[] d, final double[] e, final int[] info) {
	        final int maxit = 30;
	        int i;
	        int iscale;
	        int jtot;
	        int L;
	        int L1;
	        int lend;
	        int lendsv;
	        int lsv;
	        int m;
	        int nmaxit;
	        double alpha;
	        double anorm;
	        double bb;
	        double c;
	        double eps;
	        double eps2;
	        double gamma;
	        double oldc;
	        double oldgam;
	        double p;
	        double r;
	        final double[] rt1 = new double[1];
	        final double[] rt2 = new double[2];
	        double rte;
	        double s;
	        double safmax;
	        double safmin;
	        double sigma;
	        double ssfmax;
	        double ssfmin;
	        double[] vector1;
	        double[] vector2;
	        double[][] array1;

	        info[0] = 0;

	        // Test the input parameters
	        if (n < 0) {
	            info[0] = -1;
	            System.err.println("Error dsterf had n < 0");

	            return;
	        }

	        // Quick return if possible
	        if (n <= 1) {
	            return;
	        }

	        // Determine the unit roundoff for this environment
	        eps = dlamch('E');
	        eps2 = eps * eps;
	        safmin = dlamch('S');
	        safmax = 1.0 / safmin;
	        ssfmax = Math.sqrt(safmax) / 3.0;
	        ssfmin = Math.sqrt(safmin) / eps2;

	        // Compute the eigenvalues of the tridiagonal matrix
	        nmaxit = n * maxit;
	        sigma = 0.0;
	        jtot = 0;

	        // Determine where the matrix splits and choose QL or QR iteration for
	        // each block, according to whether top or bottom diagonal element is
	        // smaller
	        L1 = 1;

	        primary: do {

	            if (L1 > n) {
	                dlasrt('I', n, d, info);

	                return;
	            } // if (L1 > n)

	            if (L1 > 1) {
	                e[L1 - 2] = 0.0;
	            } // if (L1 > 1)

	            loop1: {

	                for (m = L1; m <= (n - 1); m++) {

	                    if (Math.abs(e[m - 1]) <= ( (Math.sqrt(Math.abs(d[m - 1])) * Math.sqrt(Math.abs(d[m]))) * eps)) {
	                        e[m - 1] = 0.0;

	                        break loop1;
	                    }
	                } // for (m = L1; m <= n-1; m++)

	                m = n;
	            } // loop1

	            L = L1;
	            lsv = L;
	            lend = m;
	            lendsv = lend;
	            L1 = m + 1;

	            if (lend == L) {
	                continue primary;
	            }

	            // Scale submatrix in rows and columns L-1 to lend - 1
	            vector1 = new double[lend - L + 1];

	            for (i = 0; i < (lend - L + 1); i++) {
	                vector1[i] = d[i + L - 1];
	            }

	            vector2 = new double[lend - L];

	            for (i = 0; i < (lend - L); i++) {
	                vector2[i] = e[i + L - 1];
	            }

	            anorm = dlanst('I', lend - L + 1, vector1, vector2);
	            iscale = 0;

	            if (anorm > ssfmax) {
	                iscale = 1;
	                array1 = new double[lend - L + 1][1];

	                for (i = 0; i < (lend - L + 1); i++) {
	                    array1[i][0] = d[i + L - 1];
	                }

	                dlascl('G', 0, 0, anorm, ssfmax, lend - L + 1, 1, array1, lend - L + 1, info);

	                for (i = 0; i < (lend - L + 1); i++) {
	                    d[i + L - 1] = array1[i][0];
	                }

	                array1 = new double[lend - L][1];

	                for (i = 0; i < (lend - L); i++) {
	                    array1[i][0] = e[i + L - 1];
	                }

	                dlascl('G', 0, 0, anorm, ssfmax, lend - L, 1, array1, lend - L, info);

	                for (i = 0; i < (lend - L); i++) {
	                    e[i + L - 1] = array1[i][0];
	                }
	            } // if (anorm > ssfmax)
	            else if (anorm < ssfmin) {
	                iscale = 2;
	                array1 = new double[lend - L + 1][1];

	                for (i = 0; i < (lend - L + 1); i++) {
	                    array1[i][0] = d[i + L - 1];
	                }

	                dlascl('G', 0, 0, anorm, ssfmin, lend - L + 1, 1, array1, lend - L + 1, info);

	                for (i = 0; i < (lend - L + 1); i++) {
	                    d[i + L - 1] = array1[i][0];
	                }

	                array1 = new double[lend - L][1];

	                for (i = 0; i < (lend - L); i++) {
	                    array1[i][0] = e[i + L - 1];
	                }

	                dlascl('G', 0, 0, anorm, ssfmin, lend - L, 1, array1, lend - L, info);

	                for (i = 0; i < (lend - L); i++) {
	                    e[i + L - 1] = array1[i][0];
	                }
	            } // else if (anorm < ssfmin)

	            for (i = L - 1; i <= (lend - 2); i++) {
	                e[i] = e[i] * e[i];
	            }

	            // Choose between QR and QL iteration
	            if (Math.abs(d[lend - 1]) < Math.abs(d[L - 1])) {
	                lend = lsv;
	                L = lendsv;
	            }

	            loop2: {

	                if (lend >= L) {

	                    // QL iteration
	                    // Look for small subdiagonal element
	                    loop3: do {

	                        loop4: {

	                            if (L != lend) {

	                                for (m = L; m <= (lend - 1); m++) {

	                                    if (Math.abs(e[m - 1]) <= (eps2 * Math.abs(d[m - 1] * d[m]))) {
	                                        break loop4;
	                                    }
	                                } // for (m = L; m <= lend-1; m++)
	                            } // if (L != lend)

	                            m = lend;
	                        } // loop4

	                        if (m < lend) {
	                            e[m - 1] = 0.0;
	                        }

	                        p = d[L - 1];

	                        if (m != L) {

	                            // If remaining matrix is 2 by 2, use dlae2 to compute its
	                            // eigenvalues
	                            if (m == (L + 1)) {
	                                rte = Math.sqrt(e[L - 1]);
	                                dlae2(d[L - 1], rte, d[L], rt1, rt2);
	                                d[L - 1] = rt1[0];
	                                d[L] = rt2[0];
	                                e[L - 1] = 0.0;
	                                L = L + 2;

	                                if (L <= lend) {
	                                    continue loop3;
	                                } // if (L <= lend)

	                                break loop2;
	                            } // if (m == (L+1))

	                            if (jtot == nmaxit) {
	                                break loop2;
	                            }

	                            jtot = jtot + 1;

	                            // Form shift
	                            rte = Math.sqrt(e[L - 1]);
	                            sigma = (d[L] - p) / (2.0 * rte);
	                            r = dlapy2(sigma, 1.0);

	                            if (sigma >= 0) {
	                                sigma = p - (rte / (sigma + Math.abs(r)));
	                            } else {
	                                sigma = p - (rte / (sigma - Math.abs(r)));
	                            }

	                            c = 1.0;
	                            s = 0.0;
	                            gamma = d[m - 1] - sigma;
	                            p = gamma * gamma;

	                            // Inner loop
	                            for (i = m - 1; i >= L; i--) {
	                                bb = e[i - 1];
	                                r = p + bb;

	                                if (i != (m - 1)) {
	                                    e[i] = s * r;
	                                }

	                                oldc = c;
	                                c = p / r;
	                                s = bb / r;
	                                oldgam = gamma;
	                                alpha = d[i - 1];
	                                gamma = (c * (alpha - sigma)) - (s * oldgam);
	                                d[i] = oldgam + (alpha - gamma);

	                                if (c != 0.0) {
	                                    p = (gamma * gamma) / c;
	                                } else {
	                                    p = oldc * bb;
	                                }
	                            } // for (i = m-1; i >= L; i--)

	                            e[L - 1] = s * p;
	                            d[L - 1] = sigma + gamma;

	                            continue loop3;
	                        } // if (m != L)

	                        // Eigenvalue found
	                        d[L - 1] = p;

	                        L = L + 1;

	                        if (L <= lend) {
	                            continue loop3;
	                        }

	                        break loop2;
	                    } // loop3
	                    while (true);
	                } // if (lend >= L)
	                else { // (lend < L)

	                    // QR integration
	                    // Look for small superdiagonal element
	                    loop5: do {

	                        loop6: {

	                            for (m = L; m >= (lend + 1); m--) {

	                                if (Math.abs(e[m - 2]) <= (eps2 * Math.abs(d[m - 1] * d[m - 2]))) {
	                                    break loop6;
	                                }
	                            } // for (m = L; m >= lend+1; m--)

	                            m = lend;
	                        } // loop6

	                        if (m > lend) {
	                            e[m - 2] = 0.0;
	                        }

	                        p = d[L - 1];

	                        if (m != L) {
	                            // If remaining matrix is 2 by 2, use dlae2 to compute its
	                            // eigenvalues

	                            if (m == (L - 1)) {
	                                rte = Math.sqrt(e[L - 2]);
	                                dlae2(d[L - 1], rte, d[L - 2], rt1, rt2);
	                                d[L - 1] = rt1[0];
	                                d[L - 2] = rt2[0];
	                                e[L - 2] = 0.0;
	                                L = L - 2;

	                                if (L >= lend) {
	                                    continue loop5;
	                                }

	                                break loop2;
	                            } // if (m == (L-1))

	                            if (jtot == nmaxit) {
	                                break loop2;
	                            }

	                            jtot = jtot + 1;

	                            // Form shift
	                            rte = Math.sqrt(e[L - 2]);
	                            sigma = (d[L - 2] - p) / (2.0 * rte);
	                            r = dlapy2(sigma, 1.0);

	                            if (sigma >= 0) {
	                                sigma = p - (rte / (sigma + Math.abs(r)));
	                            } else {
	                                sigma = p - (rte / (sigma - Math.abs(r)));
	                            }

	                            c = 1.0;
	                            s = 0.0;
	                            gamma = d[m - 1] - sigma;
	                            p = gamma * gamma;

	                            // Inner loop
	                            for (i = m; i <= (L - 1); i++) {
	                                bb = e[i - 1];
	                                r = p + bb;

	                                if (i != m) {
	                                    e[i - 2] = s * r;
	                                }

	                                oldc = c;
	                                c = p / r;
	                                s = bb / r;
	                                oldgam = gamma;
	                                alpha = d[i];
	                                gamma = (c * (alpha - sigma)) - (s * oldgam);
	                                d[i - 1] = oldgam + (alpha - gamma);

	                                if (c != 0.0) {
	                                    p = (gamma * gamma) / c;
	                                } else {
	                                    p = oldc * bb;
	                                }
	                            } // for (i = m; i <= L-1; i++)

	                            e[L - 2] = s * p;
	                            d[L - 1] = sigma + gamma;

	                            continue loop5;
	                        } // if (m != L)

	                        // Eigenvalue found
	                        d[L - 1] = p;

	                        L = L - 1;

	                        if (L >= lend) {
	                            continue loop5;
	                        }

	                        break loop2;
	                    } // loop5
	                    while (true);
	                } // else (lend < L)
	            } // loop2

	            // Undo scaling if necessary
	            if (iscale == 1) {
	                array1 = new double[lendsv - lsv + 1][1];

	                for (i = 0; i < (lendsv - lsv + 1); i++) {
	                    array1[i][0] = d[i + lsv - 1];
	                }

	                dlascl('G', 0, 0, ssfmax, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

	                for (i = 0; i < (lendsv - lsv + 1); i++) {
	                    d[i + lsv - 1] = array1[i][0];
	                }
	            } // if (iscale == 1)

	            if (iscale == 2) {
	                array1 = new double[lendsv - lsv + 1][1];

	                for (i = 0; i < (lendsv - lsv + 1); i++) {
	                    array1[i][0] = d[i + lsv - 1];
	                }

	                dlascl('G', 0, 0, ssfmin, anorm, lendsv - lsv + 1, 1, array1, lendsv - lsv + 1, info);

	                for (i = 0; i < (lendsv - lsv + 1); i++) {
	                    d[i + lsv - 1] = array1[i][0];
	                }
	            } // if (iscale == 2)

	            // Check for no convergence to an eigenvalue after a total of n*maxit
	            // iterations

	            if (jtot < nmaxit) {
	                continue primary;
	            }

	            for (i = 0; i <= (n - 2); i++) {

	                if (e[i] != 0.0) {
	                    info[0] = info[0] + 1;
	                }
	            } // for (i = 0; i <= n-2; i++)

	            return;
	        } while (true); // primary
	    } // dsterf

	    /**
	     * This is a port of version 3.1 LAPACK test routine DSTT21 Original DSTT21 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dstt21 checks a decomposition of the form A = U S U' where '
	     * means transpose, A is symmetric tridiagonal, U is orthogonal, and S is diagonal (if kband == 0) or symmetric
	     * tridagonal (if kband == 1). Two tests are performed: result[0] = | A - U S U' | / ( |A| n ulp ) result[1] = | I -
	     * UU' | / ( n ulp )
	     * 
	     * @param n (input) int The size of the matrix. If it is zero, dstt21 does nothing. It must be at least zero.
	     * @param kband (input) int The bandwidth of the matrix S. It may only be zero or one. If zero, then S is diagonal,
	     *            and SE is not referenced. If one, then S is symmetric tri-diagonal.
	     * @param AD (input) double[] of dimension (n) The diagonal of the original (unfactored) matrix A. A is assumed to
	     *            be symmetric tridiagonal.
	     * @param AE (input) double[] of dimension (n-1) The off-diagonal of the original (unfactored) matrix A. A is
	     *            assumed to be symmetric tridiagonal. AE[0] is the [0][1] and [1][0] element, AE[1] is the [1][2] and
	     *            [2][1] element, etc.
	     * @param SD (input) double[] of dimension (n) The diagonal of the (symmetric tri-) diagonal matrix S.
	     * @param SE (input) double[] of dimension (n-1) The off-diagonal of the (symmetric tri-) diagonal matrix S. Not
	     *            referenced if kband == 0. If kband == 1, then SE[0] is the [0][1] and [1][0] element, SE[1] is the
	     *            [1][2] and [2][1] element, etc.
	     * @param U (input) double[][] of dimension (ldu, n) The orthogonal matrix in the decomposition.
	     * @param ldu (input) int The leading dimension of U. ldu must be at least n.
	     * @param work (workspace) double[] of dimension (n*(n+1))
	     * @param result (output) double[] of dimension (2) The values computed by the two tests described above. The values
	     *            are currently limited to 1/ulp, to avoid overflow. result[0] is always modified.
	     */
	    private void dstt21(final int n, final int kband, final double[] AD, final double[] AE, final double[] SD,
	            final double[] SE, final double[][] U, final int ldu, final double[] work, final double[] result) {
	        int j;
	        double anorm;
	        double temp1;
	        double temp2;
	        double ulp;
	        double unfl;
	        double wnorm;
	        double[][] array1;
	        int index1;
	        int index2;
	        double[] x;
	        double[] y;
	        int i;

	        // Constants
	        result[0] = 0.0;
	        result[1] = 0.0;

	        if (n <= 0) {
	            return;
	        }

	        unfl = dlamch('S');
	        ulp = dlamch('P');

	        // DO Test 1
	        // Copy A & Compute its 1-Norm
	        array1 = new double[n][n];
	        dlaset('F', n, n, 0.0, 0.0, array1, n);
	        index1 = 0;
	        index2 = 0;

	        for (j = 0; j < (n * n); j++) {
	            work[j] = array1[index1][index2];
	            index1++;

	            if (index1 == n) {
	                index1 = 0;
	                index2++;
	            }
	        }

	        anorm = 0.0;
	        temp1 = 0.0;

	        for (j = 1; j <= (n - 1); j++) {
	            work[ (n + 1) * (j - 1)] = AD[j - 1];
	            work[ ( (n + 1) * (j - 1)) + 1] = AE[j - 1];
	            temp2 = Math.abs(AE[j - 1]);
	            anorm = Math.max(anorm, Math.abs(AD[j - 1]) + temp1 + temp2);
	            temp1 = temp2;
	        } // for (j = 1; j <= n-1; j++)

	        work[ (n * n) - 1] = AD[n - 1];
	        anorm = Math.max(anorm, Math.abs(AD[n - 1]) + temp1);
	        anorm = Math.max(anorm, unfl);

	        // Norm of A - USU'
	        x = new double[n];
	        index1 = 0;
	        index2 = 0;

	        for (j = 0; j < (n * n); j++) {
	            array1[index1][index2] = work[j];
	            index1++;

	            if (index1 == n) {
	                index1 = 0;
	                index2++;
	            }
	        }

	        for (j = 0; j < n; j++) {

	            for (i = 0; i < n; i++) {
	                x[i] = U[i][j];
	            }

	            dsyr('L', n, -SD[j], x, 1, array1, n);
	        } // for (j = 0; j < n; j++)

	        if ( (n > 1) && (kband == 1)) {
	            y = new double[n];

	            for (j = 0; j < (n - 1); j++) {

	                for (i = 0; i < n; i++) {
	                    x[i] = U[i][j];
	                    y[i] = U[i][j + 1];
	                }

	                dsyr2('L', n, -SE[j], x, 1, y, 1, array1, n);
	            }
	        } // if ((n > 1) && (kband == 1))

	        wnorm = dlansy('1', 'L', n, array1, n, work);

	        if (anorm > wnorm) {
	            result[0] = (wnorm / anorm) / (n * ulp);
	        } else if (anorm < 1.0) {
	            result[0] = (Math.min(wnorm, n * anorm) / anorm) / (n * ulp);
	        } else {
	            result[0] = Math.min(wnorm / anorm, (double) n) / (n * ulp);
	        }

	        // Do Test 2
	        // Compute UU' - I
	        dgemm('N', 'C', n, n, n, 1.0, U, ldu, U, ldu, 0.0, array1, n);
	        index1 = 0;
	        index2 = 0;

	        for (j = 0; j < (n * n); j++) {
	            work[j] = array1[index1][index2];
	            index1++;

	            if (index1 == n) {
	                index1 = 0;
	                index2++;
	            }
	        }

	        for (j = 1; j <= n; j++) {
	            work[ (n + 1) * (j - 1)] = work[ (n + 1) * (j - 1)] - 1.0;
	        }

	        index1 = 0;
	        index2 = 0;

	        for (j = 0; j < (n * n); j++) {
	            array1[index1][index2] = work[j];
	            index1++;

	            if (index1 == n) {
	                index1 = 0;
	                index2++;
	            }
	        }

	        result[1] = Math.min((double) n, dlange('1', n, n, array1, n, work)) / (n * ulp);

	        return;
	    } // dstt21

	    /**
	     * This is a port of the LAPACK version 3.1 DSYGS2 routine Original DSYGS2 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 DSYGS2 reduces a real symmetric-definite generalized
	     * eigenproblem to standard form.
	     * 
	     * <p>
	     * If itype = 1, the problem is A*x = lambda*B*x, and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
	     * </p>
	     * 
	     * <p>
	     * if itype = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U' or L'*A*L.
	     * </p>
	     * 
	     * <p>
	     * B must have been previously factorized as U'*U or L*L' by dpotrf.
	     * </p>
	     * 
	     * @param itype input int = 1: Compute inv(U')*A*inv(U) or inv(L)*A*inv(L') = 2 or 3: Compute U*A*U' or L'*A*L
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrix A is stored,
	     *            and how B has been factorized. = 'U': Upper triangular = 'L': Lower triangular
	     * @param n input int The order of matrices A and B. n >= 0.
	     * @param A input/output double[][] dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the leading
	     *            n by n upper triangular part of A contains the upper triangular part of the matrix A, and the strictly
	     *            lower triangular part of A is not referenced. If uplo = 'L', the leading n by n lower triangular part
	     *            of A contains the lower triangular part of the matrix A and the strictly upper triangular part of A is
	     *            not referenced.
	     * 
	     *            <p>
	     *            On exit, if info[0] = 0, the transformed matrix is stored in the same format as A.
	     *            </p>
	     * @param lda input int The leading dimension of array A. lda >= max(1,n).
	     * @param B input double[][] dimension ldb by n. The triangular factor from the Cholesky factorization of B, as
	     *            returned by dpotrf.
	     * @param ldb input int The leading dimension of array B. ldb >= max(1,n).
	     * @param info output int[] = 0: successful exit < 0: If info[0] = -i, the i-th argument had an illegal value
	     */
	    private void dsygs2(final int itype, final char uplo, final int n, final double[][] A, final int lda,
	            final double[][] B, final int ldb, final int[] info) {
	        boolean upper;
	        int k;
	        double akk;
	        double bkk;
	        double ct;
	        double[] vector1;
	        double[] vector2;
	        double[][] array1;
	        int i;
	        int j;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if ( (itype < 1) || (itype > 3)) {
	            info[0] = -1;
	        } else if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -5;
	        } else if (ldb < Math.max(1, n)) {
	            info[0] = -7;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dsygs2 had info[0] = " + info[0]);

	            return;
	        }

	        if (itype == 1) {

	            if (upper) {

	                // Compute inv(U')*A*inv(U)
	                for (k = 1; k <= n; k++) {

	                    // Update the upper triangle of A(k-1:n-1,k-1:n-1)
	                    akk = A[k - 1][k - 1];
	                    bkk = B[k - 1][k - 1];
	                    akk = akk / (bkk * bkk);
	                    A[k - 1][k - 1] = akk;

	                    if (k < n) {
	                        vector1 = new double[n - k];

	                        for (i = 0; i < (n - k); i++) {
	                            vector1[i] = A[k - 1][k + i];
	                        }

	                        dscal(n - k, 1.0 / bkk, vector1, 1);
	                        ct = -0.5 * akk;
	                        vector2 = new double[n - k];

	                        for (i = 0; i < (n - k); i++) {
	                            vector2[i] = B[k - 1][k + i];
	                        }

	                        daxpy(n - k, ct, vector2, 1, vector1, 1);

	                        for (i = 0; i < (n - k); i++) {
	                            A[k - 1][k + i] = vector1[i];
	                        }

	                        array1 = new double[n - k][n - k];

	                        for (i = 0; i < (n - k); i++) {

	                            for (j = 0; j < (n - k); j++) {
	                                array1[i][j] = A[i + k][j + k];
	                            }
	                        }

	                        dsyr2(uplo, n - k, -1.0, vector1, 1, vector2, 1, array1, n - k);

	                        for (i = 0; i < (n - k); i++) {

	                            for (j = 0; j < (n - k); j++) {
	                                A[i + k][j + k] = array1[i][j];
	                            }
	                        }

	                        for (i = 0; i < (n - k); i++) {
	                            vector1[i] = A[k - 1][k + i];
	                        }

	                        daxpy(n - k, ct, vector2, 1, vector1, 1);

	                        for (i = 0; i < (n - k); i++) {

	                            for (j = 0; j < (n - k); j++) {
	                                array1[i][j] = B[i + k][j + k];
	                            }
	                        }

	                        dtrsv(uplo, 'T', 'N', n - k, array1, n - k, vector1, 1);

	                        for (i = 0; i < (n - k); i++) {
	                            A[k - 1][k + i] = vector1[i];
	                        }
	                    } // if (k < n)
	                } // for (k = 1; k <= n; k++)
	            } // if (upper)
	            else { // lower

	                // Compute inv(L)*A*inv(L')
	                for (k = 1; k <= n; k++) {

	                    // update the lower triangle A(k-1:n-1,k-1:n-1)
	                    akk = A[k - 1][k - 1];
	                    bkk = B[k - 1][k - 1];
	                    akk = akk / (bkk * bkk);
	                    A[k - 1][k - 1] = akk;

	                    if (k < n) {
	                        vector1 = new double[n - k];

	                        for (i = 0; i < (n - k); i++) {
	                            vector1[i] = A[k + i][k - 1];
	                        }

	                        dscal(n - k, 1.0 / bkk, vector1, 1);
	                        ct = -0.5 * akk;
	                        vector2 = new double[n - k];

	                        for (i = 0; i < (n - k); i++) {
	                            vector2[i] = B[k + i][k - 1];
	                        }

	                        daxpy(n - k, ct, vector2, 1, vector1, 1);

	                        for (i = 0; i < (n - k); i++) {
	                            A[k + i][k - 1] = vector1[i];
	                        }

	                        array1 = new double[n - k][n - k];

	                        for (i = 0; i < (n - k); i++) {

	                            for (j = 0; j < (n - k); j++) {
	                                array1[i][j] = A[i + k][j + k];
	                            }
	                        }

	                        dsyr2(uplo, n - k, -1.0, vector1, 1, vector2, 1, array1, n - k);

	                        for (i = 0; i < (n - k); i++) {

	                            for (j = 0; j < (n - k); j++) {
	                                A[i + k][j + k] = array1[i][j];
	                            }
	                        }

	                        for (i = 0; i < (n - k); i++) {
	                            vector1[i] = A[k + i][k - 1];
	                        }

	                        daxpy(n - k, ct, vector2, 1, vector1, 1);

	                        for (i = 0; i < (n - k); i++) {

	                            for (j = 0; j < (n - k); j++) {
	                                array1[i][j] = B[i + k][j + k];
	                            }
	                        }

	                        dtrsv(uplo, 'N', 'N', n - k, array1, n - k, vector1, 1);

	                        for (i = 0; i < (n - k); i++) {
	                            A[k + i][k - 1] = vector1[i];
	                        }
	                    } // if (k < n)
	                } // for (k = 1; k <= n; k++)
	            } // else lower
	        } // if (itype == 1)
	        else { // itype == 2 or 3

	            if (upper) {

	                // Compute U*A*U'
	                for (k = 1; k <= n; k++) {

	                    // Update the upper triangle of A(0:k-1,0:k-1)
	                    akk = A[k - 1][k - 1];
	                    bkk = B[k - 1][k - 1];

	                    if (k != 1) {
	                        vector1 = new double[k - 1];

	                        for (i = 0; i < (k - 1); i++) {
	                            vector1[i] = A[i][k - 1];
	                        }

	                        dtrmv(uplo, 'N', 'N', k - 1, B, ldb, vector1, 1);
	                        ct = 0.5 * akk;
	                        vector2 = new double[k - 1];

	                        for (i = 0; i < (k - 1); i++) {
	                            vector2[i] = B[i][k - 1];
	                        }

	                        daxpy(k - 1, ct, vector2, 1, vector1, 1);

	                        for (i = 0; i < (k - 1); i++) {
	                            A[i][k - 1] = vector1[i];
	                        }

	                        dsyr2(uplo, k - 1, 1.0, vector1, 1, vector2, 1, A, lda);

	                        for (i = 0; i < (k - 1); i++) {
	                            vector1[i] = A[i][k - 1];
	                        }

	                        daxpy(k - 1, ct, vector2, 1, vector1, 1);
	                        dscal(k - 1, bkk, vector1, 1);

	                        for (i = 0; i < (k - 1); i++) {
	                            A[i][k - 1] = vector1[i];
	                        }
	                    } // if (k != 1)

	                    A[k - 1][k - 1] = akk * bkk * bkk;
	                } // for (k = 1; k <= n; k++)
	            } // if (upper)
	            else { // lower

	                // Compute L'*A*L
	                for (k = 1; k <= n; k++) {

	                    // Update the lower triangle of A(0:k-1,0:k-1)
	                    akk = A[k - 1][k - 1];
	                    bkk = B[k - 1][k - 1];

	                    if (k != 1) {
	                        vector1 = new double[k - 1];

	                        for (i = 0; i < (k - 1); i++) {
	                            vector1[i] = A[k - 1][i];
	                        }

	                        dtrmv(uplo, 'T', 'N', k - 1, B, ldb, vector1, 1);
	                        ct = 0.5 * akk;
	                        vector2 = new double[k - 1];

	                        for (i = 0; i < (k - 1); i++) {
	                            vector2[i] = B[k - 1][i];
	                        }

	                        daxpy(k - 1, ct, vector2, 1, vector1, 1);

	                        for (i = 0; i < (k - 1); i++) {
	                            A[k - 1][i] = vector1[i];
	                        }

	                        dsyr2(uplo, k - 1, 1.0, vector1, 1, vector2, 1, A, lda);

	                        for (i = 0; i < (k - 1); i++) {
	                            vector1[i] = A[k - 1][i];
	                        }

	                        daxpy(k - 1, ct, vector2, 1, vector1, 1);
	                        dscal(k - 1, bkk, vector1, 1);

	                        for (i = 0; i < (k - 1); i++) {
	                            A[k - 1][i] = vector1[i];
	                        }
	                    } // if (k != 1)

	                    A[k - 1][k - 1] = akk * bkk * bkk;
	                } // for (k = 1; k <= n; k++)
	            } // else lower
	        } // else itype == 2 or 3

	        return;
	    } // dsygs2

	    /**
	     * This routine is a port of the version 3.1 LAPACK routine DSYGST Original DSYGST created by Univ. of Tennessee,
	     * Univ. of California Berkeley, and NAG Ltd., November, 2006 dsygst reduces a real symmetric-definite generalized
	     * eigenproblem to standard form.
	     * 
	     * <p>
	     * If itype = 1, the problem is A*x = lambda*B*x and A is overwritten by inv(U')*A*inv(U) or inv(L)*A*inv(L')
	     * </p>
	     * 
	     * <p>
	     * if itype = 2 or 3, the problem is A*B*x = lambda*x or B*A*x = lambda*x, and A is overwritten by U*A*U' or L'*A*L
	     * </p>
	     * 
	     * <p>
	     * B must have been previously factorized as U'*U or L*L' by dpotrf
	     * </p>
	     * 
	     * @param itype input int = 1: compute inv(U')*A*inv(U) or inv(L)*A*inv(L') = 2 or 3: compute U*A*U' or L'*A*L
	     * @param uplo input char = 'U': Upper triangle of A is stored and B is factored as U'*U = 'L': Lower triangle of A
	     *            is stored and B is factored as L*L'
	     * @param n input int The order of matrices A and B. n >= 0.
	     * @param A input/output double[][] dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the leading
	     *            n-by-n upper triangular part of A contains the upper triangular part of matrix A, and the strictly
	     *            lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower triangular part
	     *            of A contains the lower triangular part of matrix A, and the strictly upper triangular part of A is
	     *            not referenced.
	     * 
	     *            <p>
	     *            On exit, if info[0] = 0, the transformed matrix, stored in the same format as A.
	     *            </p>
	     * @param lda input int The leading dimension of array A. lda >= max(1,n).
	     * @param B input double[][] dimension ldb by n. The triangular factor from the Cholesky factorization of B, as
	     *            returned by dpotrf
	     * @param ldb input int The leading dimension of array B. ldb >= max(1,n).
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     */
	    private void dsygst(final int itype, final char uplo, final int n, final double[][] A, final int lda,
	            final double[][] B, final int ldb, final int[] info) {
	        boolean upper;
	        int k;
	        int kb;
	        int nb;
	        final char[] ch = new char[1];
	        String opts;
	        int i;
	        int j;
	        double[][] array1;
	        double[][] array2;
	        double[][] array3;
	        int row1;
	        int row2;
	        int row3;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if ( (itype < 1) || (itype > 3)) {
	            info[0] = -1;
	        } else if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -3;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -5;
	        } else if (ldb < Math.max(1, n)) {
	            info[0] = -7;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error in dsygst with info[0] = " + info[0]);

	            return;
	        } // if (info[0] != 0)

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        // Determine the block size for this environment
	        ch[0] = uplo;
	        opts = new String(ch);
	        nb = ilaenv(1, "DSYGST", opts, n, -1, -1, -1);

	        if ( (nb <= 1) || (nb >= n)) {

	            // Use unblocked code
	            dsygs2(itype, uplo, n, A, lda, B, ldb, info);
	        } else {

	            // Use blocked code
	            if (itype == 1) {

	                if (upper) {

	                    // Compute inv(U')*A*inv(U)
	                    for (k = 1; k <= n; k += nb) {
	                        kb = Math.min(n - k + 1, nb);

	                        // Update the upper triangle of A[k-1:n-1][k-1:n-1]
	                        array1 = new double[kb][kb];
	                        array2 = new double[kb][kb];

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                array1[i][j] = A[i + k - 1][j + k - 1];
	                                array2[i][j] = B[i + k - 1][j + k - 1];
	                            }
	                        }

	                        dsygs2(itype, uplo, kb, array1, kb, array2, kb, info);

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                A[i + k - 1][j + k - 1] = array1[i][j];
	                            }
	                        }

	                        if ( (k + kb) <= n) {
	                            array1 = new double[kb][n - k - kb + 1];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array1[i][j] = A[i + k - 1][j + k + kb - 1];
	                                }
	                            }

	                            dtrsm('L', uplo, 'T', 'N', kb, n - k - kb + 1, 1.0, array2, kb, array1, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    A[i + k - 1][j + k + kb - 1] = array1[i][j];
	                                }
	                            }

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            array3 = new double[kb][n - k - kb + 1];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array3[i][j] = B[i + k - 1][j + k + kb - 1];
	                                }
	                            }

	                            dsymm('L', uplo, kb, n - k - kb + 1, -0.5, array2, kb, array3, kb, 1.0, array1, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    A[i + k - 1][j + k + kb - 1] = array1[i][j];
	                                }
	                            }

	                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array2[i][j] = A[i + k + kb - 1][j + k + kb - 1];
	                                }
	                            }

	                            dsyr2k(uplo, 'T', n - k - kb + 1, kb, -1.0, array1, kb, array3, kb, 1.0, array2, n - k - kb
	                                    + 1);

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    A[i + k + kb - 1][j + k + kb - 1] = array2[i][j];
	                                }
	                            }

	                            array2 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array1[i][j] = A[i + k - 1][j + k + kb - 1];
	                                }
	                            }

	                            dsymm('L', uplo, kb, n - k - kb + 1, -0.5, array2, kb, array3, kb, 1.0, array1, kb);
	                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array2[i][j] = B[i + k + kb - 1][j + k + kb - 1];
	                                }
	                            }

	                            dtrsm('R', uplo, 'N', 'N', kb, n - k - kb + 1, 1.0, array2, n - k - kb + 1, array1, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    A[i + k - 1][j + k + kb - 1] = array1[i][j];
	                                }
	                            }
	                        } // if ((k + kb) <= n)
	                    } // for (k = 1; k <= n; k += nb)
	                } // if (upper)
	                else { // lower

	                    // Compute inv(L)*A*inv(L')
	                    for (k = 1; k <= n; k += nb) {
	                        kb = Math.min(n - k + 1, nb);

	                        // Update the lower triangle of A(k-1:n-1,k-1:n-1
	                        array1 = new double[kb][kb];
	                        array2 = new double[kb][kb];

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                array1[i][j] = A[i + k - 1][j + k - 1];
	                                array2[i][j] = B[i + k - 1][j + k - 1];
	                            }
	                        }

	                        dsygs2(itype, uplo, kb, array1, kb, array2, kb, info);

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                A[i + k - 1][j + k - 1] = array1[i][j];
	                            }
	                        }

	                        if ( (k + kb) <= n) {
	                            array1 = new double[n - k - kb + 1][kb];

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = A[i + k + kb - 1][j + k - 1];
	                                }
	                            }

	                            dtrsm('R', uplo, 'T', 'N', n - k - kb + 1, kb, 1.0, array2, kb, array1, n - k - kb + 1);

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < kb; j++) {
	                                    A[i + k + kb - 1][j + k - 1] = array1[i][j];
	                                }
	                            }

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            array3 = new double[n - k - kb + 1][kb];

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array3[i][j] = B[i + k + kb - 1][j + k - 1];
	                                }
	                            }

	                            dsymm('R', uplo, n - k - kb + 1, kb, -0.5, array2, kb, array3, n - k - kb + 1, 1.0, array1,
	                                    n - k - kb + 1);

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < kb; j++) {
	                                    A[i + k + kb - 1][j + k - 1] = array1[i][j];
	                                }
	                            }

	                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array2[i][j] = A[i + k + kb - 1][j + k + kb - 1];
	                                }
	                            }

	                            dsyr2k(uplo, 'N', n - k - kb + 1, kb, -1.0, array1, n - k - kb + 1, array3, n - k - kb + 1,
	                                    1.0, array2, n - k - kb + 1);

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    A[i + k + kb - 1][j + k + kb - 1] = array2[i][j];
	                                }
	                            }

	                            array2 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = A[i + k + kb - 1][j + k - 1];
	                                }
	                            }

	                            dsymm('R', uplo, n - k - kb + 1, kb, -0.5, array2, kb, array3, n - k - kb + 1, 1.0, array1,
	                                    n - k - kb + 1);
	                            array2 = new double[n - k - kb + 1][n - k - kb + 1];

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < (n - k - kb + 1); j++) {
	                                    array2[i][j] = B[i + k + kb - 1][j + k + kb - 1];
	                                }
	                            }

	                            dtrsm('L', uplo, 'N', 'N', n - k - kb + 1, kb, 1.0, array2, n - k - kb + 1, array1, n - k
	                                    - kb + 1);

	                            for (i = 0; i < (n - k - kb + 1); i++) {

	                                for (j = 0; j < kb; j++) {
	                                    A[i + k + kb - 1][j + k - 1] = array1[i][j];
	                                }
	                            }
	                        } // if ((k + kb) <= n)
	                    } // for (k = 1; k <= n; k += nb)
	                } // else lower
	            } // if (itype == 1)
	            else { // itype != 1

	                if (upper) {

	                    // Compute U*A*U'
	                    for (k = 1; k <= n; k += nb) {
	                        kb = Math.min(n - k + 1, nb);

	                        // Update the upper triangle of A[0:k+kb-2][0:k+kb-2]
	                        row1 = Math.max(1, k - 1);
	                        array1 = new double[row1][kb];

	                        for (i = 0; i < row1; i++) {

	                            for (j = 0; j < kb; j++) {
	                                array1[i][j] = A[i][j + k - 1];
	                            }
	                        }

	                        dtrmm('L', uplo, 'N', 'N', k - 1, kb, 1.0, B, ldb, array1, row1);

	                        for (i = 0; i < row1; i++) {

	                            for (j = 0; j < kb; j++) {
	                                A[i][j + k - 1] = array1[i][j];
	                            }
	                        }

	                        if (k != 1) {
	                            array2 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            row3 = Math.max(1, k - 1);
	                            array3 = new double[row3][kb];

	                            for (i = 0; i < row3; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array3[i][j] = B[i][j + k - 1];
	                                }
	                            }

	                            dsymm('R', uplo, k - 1, kb, 0.5, array2, kb, array3, row3, 1.0, array1, row1);

	                            for (i = 0; i < row1; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    A[i][j + k - 1] = array1[i][j];
	                                }
	                            }

	                            dsyr2k(uplo, 'N', k - 1, kb, 1.0, array1, row1, array3, row3, 1.0, A, lda);
	                            array1 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            row2 = Math.max(1, k - 1);
	                            array2 = new double[row2][kb];

	                            for (i = 0; i < row2; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i][j + k - 1];
	                                }
	                            }

	                            dsymm('R', uplo, k - 1, kb, 0.5, array1, kb, array3, row3, 1.0, array2, row2);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = B[i + k - 1][j + k - 1];
	                                }
	                            }
	                        } // if (k != 1)
	                        else { // k == 1
	                            array1 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = B[i + k - 1][j + k - 1];
	                                }
	                            }

	                            row2 = Math.max(1, k - 1);
	                            array2 = new double[row2][kb];

	                            for (i = 0; i < row2; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i][j + k - 1];
	                                }
	                            }
	                        } // else k == 1

	                        dtrmm('R', uplo, 'T', 'N', k - 1, kb, 1.0, array1, kb, array2, row2);

	                        for (i = 0; i < row2; i++) {

	                            for (j = 0; j < kb; j++) {
	                                A[i][j + k - 1] = array2[i][j];
	                            }
	                        }

	                        array2 = new double[kb][kb];

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                array2[i][j] = A[i + k - 1][j + k - 1];
	                            }
	                        }

	                        dsygs2(itype, uplo, kb, array2, kb, array1, kb, info);

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                A[i + k - 1][j + k - 1] = array2[i][j];
	                            }
	                        }
	                    } // for (k = 1; k <= n; k += nb)
	                } // if (upper)
	                else { // lower

	                    // Compute L'*A*L
	                    for (k = 1; k <= n; k += nb) {
	                        kb = Math.min(n - k + 1, nb);

	                        // Update the lower triangle of A[0:k+kb-2][0:k+kb-2]
	                        if (k != 1) {
	                            array1 = new double[kb][k - 1];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (k - 1); j++) {
	                                    array1[i][j] = A[i + k - 1][j];
	                                }
	                            }

	                            dtrmm('R', uplo, 'N', 'N', kb, k - 1, 1.0, B, ldb, array1, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (k - 1); j++) {
	                                    A[i + k - 1][j] = array1[i][j];
	                                }
	                            }

	                            array2 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array2[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            array3 = new double[kb][k - 1];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (k - 1); j++) {
	                                    array3[i][j] = B[i + k - 1][j];
	                                }
	                            }

	                            dsymm('L', uplo, kb, k - 1, 0.5, array2, kb, array3, kb, 1.0, array1, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (k - 1); j++) {
	                                    A[i + k - 1][j] = array1[i][j];
	                                }
	                            }

	                            dsyr2k(uplo, 'T', k - 1, kb, 1.0, array1, kb, array3, kb, 1.0, A, lda);
	                            array1 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = A[i + k - 1][j + k - 1];
	                                }
	                            }

	                            array2 = new double[kb][k - 1];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (k - 1); j++) {
	                                    array2[i][j] = A[i + k - 1][j];
	                                }
	                            }

	                            dsymm('L', uplo, kb, k - 1, 0.5, array1, kb, array3, kb, 1.0, array2, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; k++) {
	                                    array1[i][j] = B[i + k - 1][j + k - 1];
	                                }
	                            }

	                            dtrmm('L', uplo, 'T', 'N', kb, k - 1, 1.0, array1, kb, array2, kb);

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < (k - 1); j++) {
	                                    A[i + k - 1][j] = array2[i][j];
	                                }
	                            }
	                        } // if (k != 1)
	                        else { // k == 1
	                            array1 = new double[kb][kb];

	                            for (i = 0; i < kb; i++) {

	                                for (j = 0; j < kb; j++) {
	                                    array1[i][j] = B[i + k - 1][j + k - 1];
	                                }
	                            }
	                        } // else k == 1

	                        array2 = new double[kb][kb];

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                array2[i][j] = A[i + k - 1][j + k - 1];
	                            }
	                        }

	                        dsygs2(itype, uplo, kb, array2, kb, array1, kb, info);

	                        for (i = 0; i < kb; i++) {

	                            for (j = 0; j < kb; j++) {
	                                A[i + k - 1][j + k - 1] = array2[i][j];
	                            }
	                        }
	                    } // for (k = 1; k <= n; k += nb)
	                } // else lower
	            } // else itype != 1
	        }

	        return;
	    } // dsygst

	    /**
	     * This is a port of the 2/8/89 Blas routine DSYMM Original version written by: Jack Dongarra, Argonne National Lab.
	     * Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical Algorithms
	     * Group Ltd. dsymm performs one of the matrix operations C = alpha*A*B + beta*C or C = alpha*B*A + beta*C, where
	     * alpha and beta are scalars, A is a symmetric matrix and B and C are m by n matrices
	     * 
	     * @param side input char On entry, side specifies whether the symmetric matrix A appears on the left or right in
	     *            the operation as follows: = 'L' or 'l' C = alpha*A*B + beta*C = 'R' or 'r' C + alpha*B*A + beta*C
	     * @param uplo input char On entry, uplo specifies whether the upper or lower triangular part of the symmetric
	     *            matrix A is to be referenced as follows: = 'U' or 'u' Only the upper triangular part of the symmetric
	     *            matrix is to be referenced. = 'L' or 'l' Only the lower triangular part of the symmetric matrix is to
	     *            be referenced.
	     * @param m input int On entry, m specifies the number of rows of the matrix C. m must be at least zero.
	     * @param n input int On entry, n specifies the number of columns of the matrix C. n must be at least zero.
	     * @param alpha double Specifies scalar.
	     * @param A input double[][] of dimension lda by ka, where ka is m when side = 'L' or 'l' and is n otherwise. Before
	     *            entry with side = 'L' or 'l', the m by m part of the array A must contain the symmetric matrix, such
	     *            that when uplo = 'U' or 'u', the leading m by m upper triangular part of the array A must contain the
	     *            upper triangular part of the symmetric matrix and the strictly lower triangular part of A is not
	     *            referenced, and when uplo = 'L' or 'l', the leading m by m lower triangular part of the array A must
	     *            contain the lower triangular part of the symmetric matrix and the strictly uppper triangular part of A
	     *            is not referenced. Before entry with side = 'R' or 'r', the n by n part of the array A must contain
	     *            the symmetric matrix, such that when uplo = 'U' or 'u', the leading n by n upper triangular part of
	     *            the array A must contain the upper triangular part of the symmetric matrix and the strictly lower
	     *            triangular part of A is not referenced, and when uplo = 'L' or 'l', the leading n by n lower
	     *            triangular part of the array A must contain the lower triangular part of the symmetric matrix and the
	     *            strictly upper triangular part of A is not referenced.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            When side = 'L' or 'l', then lda must be at least max(1,m), otherwise lda must be at least max(1,n).
	     * @param B input double[][] of dimension ldb by n. Before entry, the leading m by n part of the array B must
	     *            contain the matrix B.
	     * @param ldb input int On entry, ldb specifies the first dimension of B as declared in the calling (sub) program.
	     *            ldb must be at least max(1,m).
	     * @param beta beta double Specified scalar. When beta is supplied as zero, then C need not be set on input.
	     * @param C input/output double[][] of dimension ldc by n. Before entry, the leading m by n part of the array C must
	     *            contain the matrix C, except when beta is zero, in which case C need not be set on entry. On exit, the
	     *            array C is overwritten by the m by n updated matrix.
	     * @param ldc input int On entry, ldc specifies the first dimension of C as declared in the calling (sub) program.
	     *            ldc must be at least max(1,m).
	     */
	    private void dsymm(final char side, final char uplo, final int m, final int n, final double alpha,
	            final double[][] A, final int lda, final double[][] B, final int ldb, final double beta,
	            final double[][] C, final int ldc) {
	        boolean upper;
	        int i;
	        int info;
	        int j;
	        int k;
	        int nrowa;
	        double temp1;
	        double temp2;

	        // Set nrowa as the number of rows of A.
	        if ( (side == 'L') || (side == 'l')) {
	            nrowa = m;
	        } else {
	            nrowa = n;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        // Test the input parameters.
	        info = 0;

	        if ( (side != 'L') && (side != 'l') && (side != 'R') && (side != 'r')) {
	            info = 1;
	        } else if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info = 2;
	        } else if (m < 0) {
	            info = 3;
	        } else if (n < 0) {
	            info = 4;
	        } else if (lda < Math.max(1, nrowa)) {
	            info = 7;
	        } else if (ldb < Math.max(1, m)) {
	            info = 9;
	        } else if (ldc < Math.max(1, m)) {
	            info = 12;
	        }

	        if (info != 0) {
	            System.err.println("Error dymmm had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if ( (m == 0) || (n == 0) || ( (alpha == 0.0) && (beta == 1.0))) {
	            return;
	        }

	        if (alpha == 0.0) {

	            if (beta == 0.0) {

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = 0.0;
	                    }
	                }
	            } // if (beta == 0.0)
	            else { // beta != 0.0

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = beta * C[i][j];
	                    }
	                }
	            } // else beta != 0.0

	            return;
	        } // if (alpha == 0.0)

	        if ( (side == 'L') || (side == 'l')) {

	            // Form C = alpha*A*B + beta*C
	            if (upper) {

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i < m; i++) {
	                        temp1 = alpha * B[i][j];
	                        temp2 = 0.0;

	                        for (k = 0; k <= (i - 1); k++) {
	                            C[k][j] = C[k][j] + (temp1 * A[k][i]);
	                            temp2 = temp2 + (B[k][j] * A[k][i]);
	                        } // for (k = 0; k <= i-1; k++)

	                        if (beta == 0.0) {
	                            C[i][j] = (temp1 * A[i][i]) + (alpha * temp2);
	                        } else {
	                            C[i][j] = (beta * C[i][j]) + (temp1 * A[i][i]) + (alpha * temp2);
	                        }
	                    } // for (i = 0; i < m; i++)
	                } // for (j = 0; j < n; j++)
	            } // if (upper)
	            else { // lower

	                for (j = 0; j < n; j++) {

	                    for (i = m - 1; i >= 0; i--) {
	                        temp1 = alpha * B[i][j];
	                        temp2 = 0.0;

	                        for (k = i + 1; k < m; k++) {
	                            C[k][j] = C[k][j] + (temp1 * A[k][i]);
	                            temp2 = temp2 + (B[k][j] * A[k][i]);
	                        } // for (k = i+1; k < m; k++)

	                        if (beta == 0.0) {
	                            C[i][j] = (temp1 * A[i][i]) + (alpha * temp2);
	                        } else {
	                            C[i][j] = (beta * C[i][j]) + (temp1 * A[i][i]) + (alpha * temp2);
	                        }
	                    } // for (i = m-1; i >= 0; i--)
	                } // for (j = 0; j < n; j++)
	            } // else lower
	        } // if ((side == 'L') || (side == 'l'))
	        else { // ((side == 'R') || (side == 'r'))

	            // Form C = alpha*B*A + beta*C
	            for (j = 0; j < n; j++) {
	                temp1 = alpha * A[j][j];

	                if (beta == 0.0) {

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = temp1 * B[i][j];
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = (beta * C[i][j]) + (temp1 * B[i][j]);
	                    }
	                } // else beta != 0.0

	                for (k = 0; k <= (j - 1); k++) {

	                    if (upper) {
	                        temp1 = alpha * A[k][j];
	                    } else {
	                        temp1 = alpha * A[j][k];
	                    }

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = C[i][j] + (temp1 * B[i][k]);
	                    }
	                } // for (k = 0; k <= j-1; k++)

	                for (k = j + 1; k < n; k++) {

	                    if (upper) {
	                        temp1 = alpha * A[j][k];
	                    } else {
	                        temp1 = alpha * A[k][j];
	                    }

	                    for (i = 0; i < m; i++) {
	                        C[i][j] = C[i][j] + (temp1 * B[i][k]);
	                    }
	                } // for (k = j+1; k < n; k++)
	            } // for (j = 0; j < n; j++)
	        } // else ((side == 'R') || (side == 'r'))

	        return;
	    } // dsymm

	    /**
	     * This is a port of the 10/22/86 Blas routine DSYMV Original code written by: Jack Dongarra, Argonne Nationa Lab.
	     * Jeremy Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs.
	     * dsymv performs the matrix-vector operation y = alpha*A*x + beta*y where alpha and beta are scalars, x and y are n
	     * element vectors and A is an n by n symmetric matrix.
	     * 
	     * @param uplo input char On entry, uplo specifies whether the upper or lower triangular part of the array A is to
	     *            be referenced as follows: = 'U' or 'u' Only the upper triangular part of A is to be referenced. = 'L'
	     *            or 'l' Only the lower triangular part of A is to be referenced.
	     * @param n input int On entry, n specifies the order of the matrix A. n must be at least zero.
	     * @param alpha input double Specified scalar
	     * @param A input double[][] of dimension lda by n Before entry with uplo = 'U' or 'u', the leading n by n upper
	     *            triangular part of the array A must contain the upper triagular part of the symmetric matrix and the
	     *            strictly lower triangular part of A is not referenced. Before entry with uplo = 'L' or 'l', the
	     *            leading n by n lower triangular part of the array A must contain the lower triangular part of the
	     *            symmetric matrix and the strictly upper triangular part of A is not referenced.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1,n).
	     * @param x input double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array x must
	     *            contain the n element vector x.
	     * @param incx input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     * @param beta input double On entry, beta specifies the scalar beta. When beta is supplied as zero, then y need not
	     *            be set on input.
	     * @param y input/output double[] of dimension at least (1 + (n-1)*abs(incy)). Before entry, the incremented array y
	     *            must contain the n element vector y. On exit, y is overwritten by the updated vector y.
	     * @param incy input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
	     */
	    private void dsymv(final char uplo, final int n, final double alpha, final double[][] A, final int lda,
	            final double[] x, final int incx, final double beta, final double[] y, final int incy) {
	        double temp1;
	        double temp2;
	        int i;
	        int info;
	        int ix;
	        int iy;
	        int j;
	        int jx;
	        int jy;
	        int kx;
	        int ky;

	        // Test the input parameters
	        info = 0;

	        if ( (uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
	            info = 1;
	        } else if (n < 0) {
	            info = 2;
	        } else if (lda < Math.max(1, n)) {
	            info = 5;
	        } else if (incx == 0) {
	            info = 7;
	        } else if (incy == 0) {
	            info = 10;
	        }

	        if (info != 0) {
	            System.err.println("Error dsymv had error = " + info);

	            return;
	        }

	        // Quick return if possible
	        if ( (n == 0) || ( (alpha == 0.0) && (beta == 1.0))) {
	            return;
	        }

	        // Set up the start points in x and y
	        if (incx > 0) {
	            kx = 1;
	        } else {
	            kx = 1 - ( (n - 1) * incx);
	        }

	        if (incy > 0) {
	            ky = 1;
	        } else {
	            ky = 1 - ( (n - 1) * incy);
	        }

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through the triangular part of A.

	        // First form y = beta*y.

	        if (beta != 1.0) {

	            if (incy == 1) {

	                if (beta == 0.0) {

	                    for (i = 0; i < n; i++) {
	                        y[i] = 0.0;
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (i = 0; i < n; i++) {
	                        y[i] = beta * y[i];
	                    }
	                } // else beta != 0.0
	            } // if (incy == 1)
	            else { // incy != 1
	                iy = ky - 1;

	                if (beta == 0.0) {

	                    for (i = 0; i < n; i++) {
	                        y[iy] = 0.0;
	                        iy = iy + incy;
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (i = 0; i < n; i++) {
	                        y[iy] = beta * y[iy];
	                        iy = iy + incy;
	                    }
	                } // else beta != 0.0
	            } // else incy != 1
	        } // if (beta != 1.0)

	        if (alpha == 0.0) {
	            return;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {

	            // Form y when A is stored in upper triangle
	            if ( (incx == 1) && (incy == 1)) {

	                for (j = 0; j < n; j++) {
	                    temp1 = alpha * x[j];
	                    temp2 = 0.0;

	                    for (i = 0; i <= (j - 1); i++) {
	                        y[i] = y[i] + (temp1 * A[i][j]);
	                        temp2 = temp2 + (A[i][j] * x[i]);
	                    } // for (i = 0; i <= j-1; i++)

	                    y[j] = y[j] + (temp1 * A[j][j]) + (alpha * temp2);
	                } // for (j = 0; j < n; j++)
	            } // if ((incx == 1) && (incy == 1))
	            else { // ((incx != 1) || (incy != 1))
	                jx = kx - 1;
	                jy = ky - 1;

	                for (j = 0; j < n; j++) {
	                    temp1 = alpha * x[jx];
	                    temp2 = 0.0;
	                    ix = kx - 1;
	                    iy = ky - 1;

	                    for (i = 0; i <= (j - 1); i++) {
	                        y[iy] = y[iy] + (temp1 * A[i][j]);
	                        temp2 = temp2 + (A[i][j] * x[ix]);
	                        ix = ix + incx;
	                        iy = iy + incy;
	                    } // for (i = 0; i <= j-1; i++)

	                    y[jy] = y[jy] + (temp1 * A[j][j]) + (alpha * temp2);
	                    jx = jx + incx;
	                    jy = jy + incy;
	                } // for (j = 0; j < n; j++)
	            } // else ((incx != 1) || (incy != 1))
	        } // if ((uplo == 'U') || (uplo == 'u'))
	        else { // ((uplo == 'L') || (uplo == 'l'))

	            // Form y when A is stored in lower triangle
	            if ( (incx == 1) && (incy == 1)) {

	                for (j = 0; j < n; j++) {
	                    temp1 = alpha * x[j];
	                    temp2 = 0.0;
	                    y[j] = y[j] + (temp1 * A[j][j]);

	                    for (i = j + 1; i < n; i++) {
	                        y[i] = y[i] + (temp1 * A[i][j]);
	                        temp2 = temp2 + (A[i][j] * x[i]);
	                    } // for (i = j+1; i < n; i++)

	                    y[j] = y[j] + (alpha * temp2);
	                } // for (j = 0; j < n; j++)
	            } // if ((incx == 1) && (incy == 1))
	            else { // ((incx != 1) || (incy != 1))
	                jx = kx - 1;
	                jy = ky - 1;

	                for (j = 0; j < n; j++) {
	                    temp1 = alpha * x[jx];
	                    temp2 = 0.0;
	                    y[jy] = y[jy] + (temp1 * A[j][j]);
	                    ix = jx;
	                    iy = jy;

	                    for (i = j + 1; i < n; i++) {
	                        ix = ix + incx;
	                        iy = iy + incy;
	                        y[iy] = y[iy] + (temp1 * A[i][j]);
	                        temp2 = temp2 + (A[i][j] * x[ix]);
	                    } // for (i = j+1; i < n; i++)

	                    y[jy] = y[jy] + (alpha * temp2);
	                    jx = jx + incx;
	                    jy = jy + incy;
	                } // for (j = 0; j < n; j++)
	            } // else ((incx != 1) || (incy != 1))
	        } // else ((uplo == 'L') || (uplo == 'l'))

	        return;
	    } // dsymv

	    /**
	     * This is a port of level 2 Blas routine DSYR Original routine written on 22-October-1986 by Jack Dongarra, Argonne
	     * National Lab. Jermey Du Croz, Nag Central Office. Sven Hammarling, Nag Central Office. Richard Hanson, Sandia
	     * National Labs. dsyr performs the symmetric rank 1 operation A = alpha*x*x' + A, where alpha is a real scalar, x
	     * is an n element vector and A is an n by n symmetric matrix.
	     * 
	     * @param uplo (input) char On entry, uplo specifies whether the upper or lower triangular part of the array A is to
	     *            be referenced as follows: uplo = 'U' or 'u' Only the upper triangular part of A is to be referenced.
	     *            uplo = 'L' or 'l' Only the lower triangular part of A is to be referenced. Unchanged on exit.
	     * @param n (input) int On entry, n specifies the order of the matrix A. n must be at least zero. Unchanged on exit.
	     * @param alpha (input) double On entry, alpha specifies the scalar alpha. Unchanged on exit.
	     * @param x (input) double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array x must
	     *            contain the n element vector x. Unchanged on exit.
	     * @param incx (input) int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     *            Unchanged on exit.
	     * @param A (input/output) double[][] of dimension (lda,n). Before entry with uplo = 'U' or 'u', the leading n by n
	     *            upper triangular part of the array A must contain the upper triangular part of the symmetric matrix
	     *            and the strictly lower triangular part of A is not referenced. On exit, the upper triangualr part of
	     *            the array A is overwritten by the upper triangular part of the updated matrix. Before entry with uplo
	     *            = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower
	     *            triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced.
	     *            On exit, the lower triangular part of the array A is overwritten by the lower triangular part of the
	     *            updated matrix.
	     * @param lda (input) int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1,n). Unchanged on exit.
	     */
	    private void dsyr(final char uplo, final int n, final double alpha, final double[] x, final int incx,
	            final double[][] A, final int lda) {
	        double temp;
	        int i;
	        final int[] info = new int[1];
	        int ix;
	        int j;
	        int jx;
	        int kx = 0;

	        info[0] = 0;

	        if ( (uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = 1;
	        } else if (n < 0) {
	            info[0] = 2;
	        } else if (incx == 0) {
	            info[0] = 5;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = 7;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dsyr had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if ( (n == 0) || (alpha == 0.0)) {
	            return;
	        }

	        // Set the start point in x if the increment is not unity
	        if (incx <= 0) {
	            kx = - (n - 1) * incx;
	        } else if (incx != 1) {
	            kx = 0;
	        }

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through the triangular part of A.
	        if ( (uplo == 'U') || (uplo == 'u')) {

	            if (incx == 1) {

	                for (j = 0; j < n; j++) {

	                    if (x[j] != 0.0) {
	                        temp = alpha * x[j];

	                        for (i = 0; i <= j; i++) {
	                            A[i][j] = A[i][j] + (x[i] * temp);
	                        }
	                    } // if (x[j] != 0.0)
	                } // for (j = 0; j < n; j++)
	            } // if (incx == 1)
	            else { // incx != 1
	                jx = kx;

	                for (j = 0; j < n; j++) {

	                    if (x[jx] != 0.0) {
	                        temp = alpha * x[jx];
	                        ix = kx;

	                        for (i = 0; i <= j; i++) {
	                            A[i][j] = A[i][j] + (x[ix] * temp);
	                            ix = ix + incx;
	                        }
	                    } // if (x[jx] != 0.0)

	                    jx = jx + incx;
	                } // for (j = 0; j < n; j++)
	            } // else incx != 1
	        } else { // ((uplo == 'L') || (uplo == 'l'))

	            // Form A when A is stored in lower triangle
	            if (incx == 1) {

	                for (j = 0; j < n; j++) {

	                    if (x[j] != 0.0) {
	                        temp = alpha * x[j];

	                        for (i = j; i < n; i++) {
	                            A[i][j] = A[i][j] + (x[i] * temp);
	                        }
	                    } // if (x[j] != 0.0)
	                } // for (j = 0; j < n; j++)
	            } // if (incx == 1)
	            else { // incx != 1
	                jx = kx;

	                for (j = 0; j < n; j++) {

	                    if (x[jx] != 0.0) {
	                        temp = alpha * x[jx];
	                        ix = jx;

	                        for (i = j; i < n; i++) {
	                            A[i][j] = A[i][j] + (x[ix] * temp);
	                            ix = ix + incx;
	                        }
	                    } // if (x[jx] != 0.0)

	                    jx = jx + incx;
	                } // for (j = 0; j < n; j++)
	            } // else incx != 1
	        } // else ((uplo == 'L') || (uplo == 'l'))

	        return;
	    } // dsyr

	    /**
	     * Port of 10/22/86 Blas DSYR2 routine Original version written by: Jack Dongarra, Argonne National Lab. Jeremy Du
	     * Croz, Nag Central Office Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National Labs. dsyr2
	     * performs the symmetric rank 2 operation A = alpha*x*y' + alpha*y*x' + A, where alpha is a scalar, x and y are n
	     * element vectors, and A is an n by n symmetric matrix.
	     * 
	     * @param uplo input char On entry, uplo specifies whether the upper or lower triangular part of the array A is to
	     *            be referenced as follows: = 'U' or 'u' Only the upper triangular part of A is to be referenced. = 'L'
	     *            or 'l' Only the lower triangular part of A is to be referenced.
	     * @param n input int On entry, n specifies the order of the matrix A. n must be at least zero.
	     * @param alpha input double specified scalar
	     * @param x input double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array x must
	     *            contain the n element vector x.
	     * @param incx input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     * @param y input double[] of dimension at least (1 + (n-1)*abs(incy)). Before entry, the incremented array y must
	     *            contain the n element vector y.
	     * @param incy input int On entry, incy specifies the increment for the elements of y. incy must not be zero.
	     * @param A input/output double[][] of dimension lda by n. Before entry with uplo = 'U' or 'u', the leading n by n
	     *            upper triangular part of the array A must contain the upper triangular part of the symmetric matrix
	     *            and the strictly lower triangular part of A is not referenced. On exit, the upper triangular part of
	     *            the array A is overwritten by the upper triangular part of the updated matrix. Before entry with uplo
	     *            = 'L' or 'l', the leading n by n lower triangular part of the array A must contain the lower
	     *            triangular part of the symmetric matrix and the strictly upper triangular part of A is not referenced.
	     *            On exit, the lower triangular part of the array A is overwritten by the lower triangular part of the
	     *            updated matrix.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1,n).
	     */
	    private void dsyr2(final char uplo, final int n, final double alpha, final double[] x, final int incx,
	            final double[] y, final int incy, final double[][] A, final int lda) {
	        double temp1;
	        double temp2;
	        int i;
	        int info;
	        int ix;
	        int iy;
	        int j;
	        int jx = 0;
	        int jy = 0;
	        int kx = 1;
	        int ky = 1;

	        // Test the input parameters
	        info = 0;

	        if ( (uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
	            info = 1;
	        } else if (n < 0) {
	            info = 2;
	        } else if (incx == 0) {
	            info = 5;
	        } else if (incy == 0) {
	            info = 7;
	        } else if (lda < Math.max(1, n)) {
	            info = 9;
	        }

	        if (info != 0) {
	            System.err.println("Error dsyr2 had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if ( (n == 0) || (alpha == 0.0)) {
	            return;
	        }

	        // Set up the start points in x and y if the increments are not both unity.

	        if ( (incx != 1) || (incy != 1)) {

	            if (incx > 0) {
	                kx = 1;
	            } else {
	                kx = 1 - ( (n - 1) * incx);
	            }

	            if (incy > 0) {
	                ky = 1;
	            } else {
	                ky = 1 - ( (n - 1) * incy);
	            }

	            jx = kx - 1;
	            jy = ky - 1;
	        } // if ((incx != 1) || (incy != 1))

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through the triangular part of A.
	        if ( (uplo == 'U') || (uplo == 'u')) {

	            // Form A when A is stored in the upper triangle
	            if ( (incx == 1) && (incy == 1)) {

	                for (j = 0; j < n; j++) {

	                    if ( (x[j] != 0.0) || (y[j] != 0.0)) {
	                        temp1 = alpha * y[j];
	                        temp2 = alpha * x[j];

	                        for (i = 0; i <= j; i++) {
	                            A[i][j] = A[i][j] + (x[i] * temp1) + (y[i] * temp2);
	                        }
	                    } // if (x[j] != 0.0) || (y[j] != 0.0))
	                } // for (j = 0; j < n; j++)
	            } // if ((incx == 1) && (incy == 1))
	            else { // ((incx != 1) || (incy != 1))

	                for (j = 0; j < n; j++) {

	                    if ( (x[jx] != 0.0) || (y[jy] != 0.0)) {
	                        temp1 = alpha * y[jy];
	                        temp2 = alpha * x[jx];
	                        ix = kx - 1;
	                        iy = ky - 1;

	                        for (i = 0; i <= j; i++) {
	                            A[i][j] = A[i][j] + (x[ix] * temp1) + (y[iy] * temp2);
	                            ix = ix + incx;
	                            iy = iy + incy;
	                        } // for (i = 0; i <= j; i++)
	                    } // if ((x[jx] != 0.0) || (y[jy] != 0.0))

	                    jx = jx + incx;
	                    jy = jy + incy;
	                } // for (j = 0; j < n; j++)
	            } // else ((incx != 1) || (incy != 1))
	        } // if ((uplo == 'U') || (uplo == 'u'))
	        else { // ((uplo == 'L') || (uplo == 'l'))

	            // Form A when A is stored in the lower triangle
	            if ( (incx == 1) && (incy == 1)) {

	                for (j = 0; j < n; j++) {

	                    if ( (x[j] != 0.0) || (y[j] != 0.0)) {
	                        temp1 = alpha * y[j];
	                        temp2 = alpha * x[j];

	                        for (i = j; i < n; i++) {
	                            A[i][j] = A[i][j] + (x[i] * temp1) + (y[i] * temp2);
	                        }
	                    } // if ((x[j] != 0.0) || (y[j] != 0.0))
	                } // for (j = 0; j < n; j++)
	            } // if ((incx == 1) && (incy == 1))
	            else { // ((incx != 1) || (incy != 1))

	                for (j = 0; j < n; j++) {

	                    if ( (x[jx] != 0.0) || (y[jy] != 0.0)) {
	                        temp1 = alpha * y[jy];
	                        temp2 = alpha * x[jx];
	                        ix = jx;
	                        iy = jy;

	                        for (i = j; i < n; i++) {
	                            A[i][j] = A[i][j] + (x[ix] * temp1) + (y[iy] * temp2);
	                            ix = ix + incx;
	                            iy = iy + incy;
	                        } // for (i = j; i < n; i++)
	                    } // if ((x[jx] != 0.0) || (y[jy] != 0.0))

	                    jx = jx + incx;
	                    jy = jy + incy;
	                } // for (j = 0; j < n; j++)
	            } // else ((incx != 1) || (incy != 1))
	        } // else ((uplo == 'L') || (uplo == 'l'))

	        return;
	    } // dsyr2

	    /**
	     * This is a port of the 2/8/89 Blas routine DSYR2K Original version written by: Jack Dongarra, Argonne National
	     * Lab. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
	     * Algorithms Group Ltd. dsyr2k performs one of the symmeric rank 2k operations C = alpha*A*B' + alpha*B*A' +
	     * beta*C, or C = alpha*A'*B + alpha*B'*A + beta*C, where alpha and beta are scalars, C is an n by n symmetric
	     * matrix and A and B are n by k matrices in the first case and k by n matrices in the second case.
	     * 
	     * @param uplo input char On entry, uplo specifies whether the upper or lower triangular part of the array C is to
	     *            be referenced as follows: = 'U' or 'u' Only the upper triangular part of C is to be referenced. = 'L'
	     *            or 'l' Only the lower triangular part of C is to be referenced
	     * @param trans input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n' C =
	     *            alpha*A*B' + alpha*B*A' + beta*C = 'T' or 't' C = alpha*A'*B + alpha*B'*A + beta*C = 'C' or 'c' C =
	     *            alpha*A'*B + alpha*B'*A + beta*C
	     * @param n input int On entry, n specifies the order of the matrix C. n must be at least zero.
	     * @param k input int On entry with trans = 'N' or 'n', k specifies the number of columns of the matrices A and B,
	     *            and on entry with trans = 'T' or 't' or 'C' or 'c', k specifies the number of rows of the matrices A
	     *            and B. k must be at least zero.
	     * @param alpha input double Specifies scalar.
	     * @param A input double[][] of dimension lda by ka, where ka is k when trans = 'N' or 'n', and is n otherwise.
	     *            Before entry with trans = 'N' or 'n', the leading n by k part of the array A must contain the matrix
	     *            A, otherwise the leading k by n part of the array A must contain the matrix A.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            When trans = 'N' or 'n' then lda must be at least max(1,n), otherwise lda must be at least max(1,k).
	     * @param B input double[][] of dimension ldb by kb, where kb is k when trans = 'N' or 'n', and is n otherwise.
	     *            Before entry with trans = 'N' or 'n', the leading n by k part of the array B must contain the matrix
	     *            B, otherwise the leading k by n part of the array B must contain the matrix B.
	     * @param ldb input int On entry, ldb specifies the first dimension of B as declared in the calling (sub) program.
	     *            When trans = 'N' or 'n', then ldb must be at least max(1,n), otherwise ldb must be at least max(1,k).
	     * @param beta input double Specified scalar
	     * @param C input/output double[][] of dimension ldc by n Before entry with uplo = 'U' or 'u', the leading n by n
	     *            upper triangular part of the array C must contain the upper triangular part of the symmetric matrix
	     *            and the strictly lower triangular part of C is not referenced. On exit, the upper triangular part of
	     *            the array C is overwritten by the upper triangular part of the updated matrix. Before entry with uplo
	     *            = 'L' or 'l', the leading n by n lower triangular part of the array C must contain the lower
	     *            triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced.
	     *            On exit, the lower triangular part of the array C is overwritten by the lower triangular part of the
	     *            updated matrix.
	     * @param ldc input int On entry, ldc specifies the first dimension of C as declared in the calling (sub) program.
	     *            ldc must be at least max(1,n).
	     */
	    private void dsyr2k(final char uplo, final char trans, final int n, final int k, final double alpha,
	            final double[][] A, final int lda, final double[][] B, final int ldb, final double beta,
	            final double[][] C, final int ldc) {
	        boolean upper;
	        int i;
	        int info;
	        int j;
	        int L;
	        int nrowa;
	        double temp1;
	        double temp2;

	        // Test the input parameters.

	        if ( (trans == 'N') || (trans == 'n')) {
	            nrowa = n;
	        } else {
	            nrowa = k;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        info = 0;

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info = 1;
	        } else if ( (trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C')
	                && (trans != 'c')) {
	            info = 2;
	        } else if (n < 0) {
	            info = 3;
	        } else if (k < 0) {
	            info = 4;
	        } else if (lda < Math.max(1, nrowa)) {
	            info = 7;
	        } else if (ldb < Math.max(1, nrowa)) {
	            info = 9;
	        } else if (ldc < Math.max(1, n)) {
	            info = 12;
	        }

	        if (info != 0) {
	            System.err.println("Error dsyr2k had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if ( (n == 0) || ( ( (alpha == 0.0) || (k == 0)) && (beta == 1.0))) {
	            return;
	        }

	        if (alpha == 0.0) {

	            if (upper) {

	                if (beta == 0.0) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    }
	                } // else beta != 0.0
	            } // if (upper)
	            else { // lower

	                if (beta == 0.0) {

	                    for (j = 0; j < n; j++) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (j = 0; j < n; j++) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    }
	                } // else beta != 0.0
	            } // else lower

	            return;
	        } // if (alpha == 0.0)

	        if ( (trans == 'N') || (trans == 'n')) {

	            // Form C = alpha*A*B' + alpha*B*A' + beta*C.
	            if (upper) {

	                for (j = 0; j < n; j++) {

	                    if (beta == 0.0) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    } // if (beta == 0.0)
	                    else if (beta != 1.0) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    } // else if (beta != 1.0)

	                    for (L = 0; L < k; L++) {

	                        if ( (A[j][L] != 0.0) || (B[j][L] != 0.0)) {
	                            temp1 = alpha * B[j][L];
	                            temp2 = alpha * A[j][L];

	                            for (i = 0; i <= j; i++) {
	                                C[i][j] = C[i][j] + (A[i][L] * temp1) + (B[i][L] * temp2);
	                            }
	                        } // if ((A[j][L] != 0.0) || (B[j][L] != 0.0))
	                    } // for (L = 0; L < k; L++)
	                } // for (j = 0; j < n; j++)
	            } // if (upper)
	            else { // lower

	                for (j = 0; j < n; j++) {

	                    if (beta == 0.0) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    } // if (beta == 0.0)
	                    else if (beta != 1.0) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    } // else if (beta != 1.0)

	                    for (L = 0; L < k; L++) {

	                        if ( (A[j][L] != 0.0) || (B[j][L] != 0.0)) {
	                            temp1 = alpha * B[j][L];
	                            temp2 = alpha * A[j][L];

	                            for (i = j; i < n; i++) {
	                                C[i][j] = C[i][j] + (A[i][L] * temp1) + (B[i][L] * temp2);
	                            }
	                        } // if ((A[j][L] != 0.0) || (B[j][L] != 0.0))
	                    } // for (L = 0; L < k; L++)
	                } // for (j = 0; j < n; j++)
	            } // else lower
	        } // if ((trans == 'N') || (trans == 'n'))
	        else { // ((trans != 'N') && (trans != 'n'))

	            // Form C = alpha*A'*B + alpha*B'*A + beta*C.
	            if (upper) {

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i <= j; i++) {
	                        temp1 = 0.0;
	                        temp2 = 0.0;

	                        for (L = 0; L < k; L++) {
	                            temp1 = temp1 + (A[L][i] * B[L][j]);
	                            temp2 = temp2 + (B[L][i] * A[L][j]);
	                        } // for (L = 0; L < k; L++)

	                        if (beta == 0.0) {
	                            C[i][j] = (alpha * temp1) + (alpha * temp2);
	                        } else {
	                            C[i][j] = (beta * C[i][j]) + (alpha * temp1) + (alpha * temp2);
	                        }
	                    } // for (i = 0; i <= j; i++)
	                } // for (j = 0; j < n; j++)
	            } // if (upper)
	            else { // lower

	                for (j = 0; j < n; j++) {

	                    for (i = j; i < n; i++) {
	                        temp1 = 0.0;
	                        temp2 = 0.0;

	                        for (L = 0; L < k; L++) {
	                            temp1 = temp1 + (A[L][i] * B[L][j]);
	                            temp2 = temp2 + (B[L][i] * A[L][j]);
	                        } // for (L = 0; L < k; L++)

	                        if (beta == 0.0) {
	                            C[i][j] = (alpha * temp1) + (alpha * temp2);
	                        } else {
	                            C[i][j] = (beta * C[i][j]) + (alpha * temp1) + (alpha * temp2);
	                        }
	                    } // for (i = j; i < n; i++)
	                } // for (j = 0; j < n; j++)
	            } // else lower
	        } // else ((trans != 'N') && (trans != 'n'))

	        return;
	    } // dsyr2k

	    /**
	     * dsyrk is the port of the 2/8/89 blas DSYRK routine. Original version written by: Jack Dongarra, Argonne National
	     * Laboratory. Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
	     * Algorithms Group Ltd. dsyrk performs one of the symmetric rank k operations C = alpha*A*A' + beta*C, or C =
	     * alpha*A'*A + beta*c where alpha and beta are scalars, C is an n by n symmetric matrix and A is an n by k matrix
	     * in the frist case and a k by n matrix in the second case.
	     * 
	     * @param uplo input char On entry, uplo specifies whether the upper or lower triangular part of the array C is to
	     *            be referenced as follows: = 'U' or 'u' Only the upper triangular part of C is to be referenced. = 'L'
	     *            or 'l' Only the lower triangular part of C is to be referenced.
	     * @param trans input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n' C =
	     *            alpha*A*A' + beta*C. = 'T' or 't' C = alpha*A'*A + beta*C. = 'C' or 'c' C = alpha*A'*A + beta*C.
	     * @param n input int On entry, n specifies the order of the matrix C. n must be at least zero.
	     * @param k input int On entry with trans = 'N' or 'n', k specifies the number of columns of the matrix A, and on
	     *            entry with trans = 'T' or 't' or 'C' or 'c', k specifies the number of rows of the matrix A. k must be
	     *            at least zero.
	     * @param alpha input double specified scalar
	     * @param A input double[][] array of dimension lda by ka, where ka is k when trans = 'N' or 'n', and is n
	     *            otherwise. Before entry with trans = 'N' or 'n', the leading n by k part of the array A must contain
	     *            the matrix A, otherwise the leading k by n part of the array A must contain the matrix A.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            When trans = 'N' or 'n' then lda must be at least max(1,n), otherwise lda must be at least max(1,k).
	     * @param beta input double specified scalar
	     * @param C input/output double[][] array of dimension ldc by n Before entry with uplo = 'U' or 'u', the leading n
	     *            by n upper triangular part of the array C must contain the upper triangular part of the symmetric
	     *            matrix and the strictly lower triangular part of C is not referenced. On exit, the upper triangular
	     *            part of the array C, is overwritten by the upper triangular part of the updated matrix. Before entry
	     *            with uplo = 'L' or 'l', the leading n by n lower triangular part of the array C must contain the lower
	     *            triangular part of the symmetric matrix and the strictly upper triangular part of C is not referenced.
	     *            On exit, the lower triangular part of the array C is overwritten by the lower triangular part of the
	     *            updated matrix.
	     * @param ldc input int On entry, ldc specifies the first dimension of C as declared in the calling (sub) program.
	     *            ldc must be at least max(1,n).
	     */
	    private void dsyrk(final char uplo, final char trans, final int n, final int k, final double alpha,
	            final double[][] A, final int lda, final double beta, final double[][] C, final int ldc) {
	        int nrowa;
	        boolean upper;
	        int info;
	        int i;
	        int j;
	        int L;
	        double temp;

	        // Test the input parameters
	        if ( (trans == 'N') || (trans == 'n')) {
	            nrowa = n;
	        } else {
	            nrowa = k;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        info = 0;

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info = 1;
	        } else if ( (trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C')
	                && (trans != 'c')) {
	            info = 2;
	        } else if (n < 0) {
	            info = 3;
	        } else if (k < 0) {
	            info = 4;
	        } else if (lda < Math.max(1, nrowa)) {
	            info = 7;
	        } else if (ldc < Math.max(1, n)) {
	            info = 10;
	        }

	        if (info != 0) {
	            System.err.println("Error in dsyrk with info = " + info);

	            return;
	        } // if (info != 0)

	        // Quick return if possible
	        if ( (n == 0) || ( ( (alpha == 0.0) || (k == 0)) && (beta == 1.0))) {
	            return;
	        }

	        if (alpha == 0.0) {

	            if (upper) {

	                if (beta == 0.0) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    }
	                } // else beta != 0.0
	            } // if (upper)
	            else { // lower

	                if (beta == 0.0) {

	                    for (j = 0; j < n; j++) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    }
	                } // if (beta == 0.0)
	                else { // beta != 0.0

	                    for (j = 0; j < n; j++) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    }
	                } // else beta != 0.0
	            } // else lower
	        } // if (alpha == 0.0)

	        if ( (trans == 'N') || (trans == 'n')) {

	            // Form C = alpha*A*A' + beta*C
	            if (upper) {

	                for (j = 0; j < n; j++) {

	                    if (beta == 0.0) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    } // if (beta == 0.0)
	                    else if (beta != 1.0) {

	                        for (i = 0; i <= j; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    } // else if (beta != 1.0)

	                    for (L = 0; L < k; L++) {

	                        if (A[j][L] != 0.0) {
	                            temp = alpha * A[j][L];

	                            for (i = 0; i <= j; i++) {
	                                C[i][j] = C[i][j] + (temp * A[i][L]);
	                            }
	                        } // if (A[j][L] != 0.0)
	                    } // for (L = 0; L < k; L++)
	                } // for (j = 0; j < n; j++)
	            } // if (upper)
	            else { // lower

	                for (j = 0; j < n; j++) {

	                    if (beta == 0.0) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = 0.0;
	                        }
	                    } // if (beta == 0.0)
	                    else if (beta != 1.0) {

	                        for (i = j; i < n; i++) {
	                            C[i][j] = beta * C[i][j];
	                        }
	                    } // else if (beta != 1.0)

	                    for (L = 0; L < k; L++) {

	                        if (A[j][L] != 0.0) {
	                            temp = alpha * A[j][L];

	                            for (i = j; i < n; i++) {
	                                C[i][j] = C[i][j] + (temp * A[i][L]);
	                            }
	                        } // if (A[j][L] != 0.0)
	                    } // for (L = 0; L < k; L++)
	                } // for (j = 0; j < n; j++)
	            } // else lower
	        } // if ((trans == 'N') || (trans == 'n'))
	        else { // trans != 'N' && trans != 'n'

	            // Form C = alpha*A'*A + beta*C.
	            if (upper) {

	                for (j = 0; j < n; j++) {

	                    for (i = 0; i <= j; i++) {
	                        temp = 0.0;

	                        for (L = 0; L < k; L++) {
	                            temp = temp + (A[L][i] * A[L][j]);
	                        }

	                        if (beta == 0.0) {
	                            C[i][j] = alpha * temp;
	                        } else {
	                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
	                        }
	                    } // for (i = 0; i <= j; i++)
	                } // for (j = 0; j < n; j++)
	            } // if (upper)
	            else { // lower

	                for (j = 0; j < n; j++) {

	                    for (i = j; i < n; i++) {
	                        temp = 0.0;

	                        for (L = 0; L < k; L++) {
	                            temp = temp + (A[L][i] * A[L][j]);
	                        }

	                        if (beta == 0.0) {
	                            C[i][j] = alpha * temp;
	                        } else {
	                            C[i][j] = (alpha * temp) + (beta * C[i][j]);
	                        }
	                    } // for (i = j; i < n; i++)
	                } // for (j = 0; j < n; j++)
	            } // else lower
	        } // else trans != 'N' && trans != 'n'

	        return;
	    } // dsyrk

	    /**
	     * This is a port of version 3.1 LAPACK test routine DSYT21 Original DSYT21 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dsyt21 generally checks a decomposition of the form A = U S U'
	     * where ' means transpose, A is symmetric, U is orthogonal, and S is diagonal (if kband == 0) or symmetric
	     * tridiagonal (if kband == 1).
	     * 
	     * <p>
	     * If itype == 1, then U is represented as a dense matrix; otherwise U is expressed as a product of Householder
	     * transformations, whose vectors are stored in the array "V" and whose scaling constants are in "tau". We shall use
	     * the letter "V" to refer to the product of Householder transformations (which should be equal to U).
	     * </p>
	     * 
	     * <p>
	     * Specifically, if itype == 1, then: result[0] = | A - U S U' | / ( |A| n ulp ) *and* result[1] = | I - UU' | / (n
	     * ulp )
	     * </p>
	     * 
	     * <p>
	     * If itype == 2, then: result[0] = | A - V S V' | / ( |A| n ulp )
	     * </p>
	     * 
	     * <p>
	     * If itype == 3, then: result[0] = | I - VU' | / ( n ulp )
	     * </p>
	     * 
	     * <p>
	     * For itype > 1, the transformation U is expressed as a product V = H(0)...H(n-1), where H(j) = I - tau(j) v(j)
	     * v(j)' and each vector v(j) has its first j elements 0 and the remaining n-j elements stored in V(j:n-1,j-1).
	     * </p>
	     * 
	     * @param itype (input) int Specifies the type of tests to be performed. 1: U expressed as a dense orthogonal
	     *            matrix: result[0] = | A - U S U' | / ( |A| n ulp ) *and* result[1] = | I - UU' | / ( n ulp ) 2: U
	     *            expressed as a product V of Householder transformations: result[0] = | A - V S V' | / ( |A| n ulp ) 3:
	     *            U expressed both as a dense orthogonal matrix and as a product of Householder transformations:
	     *            result[0] = | I - VU' | / ( n ulp )
	     * @param uplo (input) char If uplo == 'U', the upper triangle of A and V will be used and the (strictly) lower
	     *            triangle will not be referenced. If uplo == 'L', the lower triangle of A and V will be used and the
	     *            (strictly) upper triangle will not be referenced.
	     * @param n (input) int The size of the matrix. If it is zero, dsyt21 does nothing. It must be at least zero.
	     * @param kband (input) int The bandwidth of the matrix. It may only be zero or one. If zero, then S is diagonal,
	     *            and E is not referenced. If one, then S is symmetric tri-diagonal.
	     * @param A (input) double[][] of dimension (lda,n) The original (unfactored) matrix. It is assumed to be symmetric,
	     *            and only the upper (uplo == 'U') or only the lower (uplo == 'L') will be referenced.
	     * @param lda (input) int The leading dimension of A. It must be at least 1 and at least n.
	     * @param D (input) double[] of dimension (n) The diagonal of the (symmetric tri-) diagonal matrix.
	     * @param E (input) double[] of dimension (n-1) The off-diagonal of the (symmetric tri-) diagonal matrix. E[0] is
	     *            the [0][1] and [1][0] element, E[1] is the [1][2] and [2][1] element, etc. Not referenced if kband ==
	     *            0.
	     * @param U (input) double[][] of dimension (ldu,n) If itype == 1 or 3, this contains the orthogonal matrix in the
	     *            decomposition, expressed as a dense matrix. If itype == 2, then it is not referenced.
	     * @param ldu (input) int The leading dimension of U. ldu must be at least n and at least 1.
	     * @param V (input) double[][] of dimension (ldv,n) If itype == 2 or 3, the columns of this array contain the
	     *            Householder vectors used to describe the orthogonal matrix in the decomposition. If uplo == 'L', then
	     *            the vectors are in the lower triangle, if uplo == 'U', then in the upper triangle. *Note* If itype ==
	     *            2 or 3, V is modified and restored. The subdiagonal (if uplo == 'L') or the superdiagonal (if uplo ==
	     *            'U') is set to one, and later reset to its original value, during the course of the calculation. If
	     *            itype == 1, then it is neither referenced nor modified.
	     * @param ldv (input) int The leading dimension of V. ldv must be at least n and at least 1.
	     * @param tau (input) double[] of dimension (n) If itype >= 2, then tau[j] is the scalar factor of v(j) v(j)' in the
	     *            Householder transformation H(j) of the product U = H(0)...H(n-3) If itype < 2, then tau is not
	     *            referenced.
	     * @param work (workspace) double[] of dimension (2*n**2)
	     * @param result (output) double[] of dimension (2) The values computed by the two tests are described above. The
	     *            values are currently limited to 1/ulp, to avoid overflow. result[0] is always modified. result[1] is
	     *            modified only if itype == 1.
	     */
	    private void dsyt21(final int itype, final char uplo, final int n, final int kband, final double[][] A,
	            final int lda, final double[] D, final double[] E, final double[][] U, final int ldu, final double[][] V,
	            final int ldv, final double[] tau, final double[] work, final double[] result) {
	        boolean lower;
	        char cuplo;
	        final int[] iinfo = new int[1];
	        int j;
	        int jcol;
	        int jr;
	        int jrow;
	        double anorm;
	        double ulp;
	        double unfl;
	        double vsave;
	        double wnorm = 0.0;
	        double[] x;
	        double[] y;
	        int i;
	        double[][] array1;
	        double[][] array2;
	        int index1;
	        int index2;
	        int index3;
	        int index4;

	        result[0] = 0.0;

	        if (itype == 1) {
	            result[1] = 0.0;
	        }

	        if (n <= 0) {
	            return;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            lower = false;
	            cuplo = 'U';
	        } else {
	            lower = true;
	            cuplo = 'L';
	        }

	        unfl = dlamch('S');
	        ulp = dlamch('E') * dlamch('B');

	        // Some Error Checks
	        if ( (itype < 1) || (itype > 3)) {
	            result[0] = 10.0 / ulp;

	            return;
	        }

	        x = new double[n];
	        y = new double[n];

	        // Do Test 1

	        // Norm of A:
	        if (itype == 3) {
	            anorm = 1.0;
	        } else {
	            anorm = Math.max(dlansy('1', cuplo, n, A, lda, work), unfl);
	        }

	        // Compute error matrix:
	        if (itype == 1) {

	            // itype == 1: error = A - U S U'
	            array1 = new double[n][n];
	            dlaset('F', n, n, 0.0, 0.0, array1, n);
	            dlacpy(cuplo, n, n, A, lda, array1, n);

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < n; i++) {
	                    x[i] = U[i][j];
	                }

	                dsyr(cuplo, n, -D[j], x, 1, array1, n);
	            } // for (j = 0; j < n; j++)

	            if ( (n > 1) && (kband == 1)) {

	                for (j = 0; j < (n - 1); j++) {

	                    for (i = 0; i < n; i++) {
	                        x[i] = U[i][j];
	                        y[i] = U[i][j + 1];
	                        dsyr2(cuplo, n, -E[j], x, 1, y, 1, array1, n);
	                    }
	                } // for (j = 0; j < n-1; j++)
	            } // if ((n > 1) && (kband == 1))

	            wnorm = dlansy('1', cuplo, n, array1, n, work);
	        } // if (itype == 1)
	        else if (itype == 2) {

	            // itype == 2: error = V S V' - A
	            array1 = new double[n][n];
	            dlaset('F', n, n, 0.0, 0.0, array1, n);
	            index1 = 0;
	            index2 = 0;

	            for (i = 0; i < (n * n); i++) {
	                work[i] = array1[index1][index2];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            if (lower) {
	                work[ (n * n) - 1] = D[n - 1];

	                for (j = n - 1; j >= 1; j--) {

	                    if (kband == 1) {
	                        work[ ( (n + 1) * (j - 1)) + 1] = (1.0 - tau[j - 1]) * E[j - 1];

	                        for (jr = j + 2; jr <= n; jr++) {
	                            work[ ( (j - 1) * n) + jr - 1] = -tau[j - 1] * E[j - 1] * V[jr - 1][j - 1];
	                        }
	                    } // if (kband == 1)

	                    vsave = V[j][j - 1];
	                    V[j][j - 1] = 1.0;

	                    for (i = 0; i < (n - j); i++) {
	                        x[i] = V[j + i][j - 1];
	                    }

	                    array1 = new double[n][n - j];
	                    index1 = 0;
	                    index2 = 0;

	                    for (i = 0; i < (n * (n - j)); i++) {
	                        array1[index1][index2] = work[ ( (n + 1) * j) + i];
	                        index1++;

	                        if (index1 == n) {
	                            index1 = 0;
	                            index2++;
	                        }
	                    }

	                    dlarfy('L', n - j, x, 1, tau[j - 1], array1, n, y);
	                    index1 = 0;
	                    index2 = 0;

	                    for (i = 0; i < (n * (n - j)); i++) {
	                        work[ ( (n + 1) * j) + i] = array1[index1][index2];
	                        index1++;

	                        if (index1 == n) {
	                            index1 = 0;
	                            index2++;
	                        }
	                    }

	                    V[j][j - 1] = vsave;
	                    work[ (n + 1) * (j - 1)] = D[j - 1];
	                } // for (j = n-1; j >= 1; j--)
	            } // if (lower)
	            else { // upper
	                work[0] = D[0];

	                for (j = 1; j <= (n - 1); j++) {

	                    if (kband == 1) {
	                        work[ ( (n + 1) * j) - 1] = (1.0 - tau[j - 1]) * E[j - 1];

	                        for (jr = 1; jr <= (j - 1); jr++) {
	                            work[ (j * n) + jr - 1] = -tau[j - 1] * E[j - 1] * V[jr - 1][j];
	                        }
	                    } // if (kband == 1)

	                    vsave = V[j - 1][j];
	                    V[j - 1][j] = 1.0;

	                    for (i = 0; i < j; i++) {
	                        x[i] = V[i][j];
	                    }

	                    array1 = new double[n][j];
	                    index1 = 0;
	                    index2 = 0;

	                    for (i = 0; i < (n * j); i++) {
	                        array1[index1][index2] = work[i];
	                        index1++;

	                        if (index1 == n) {
	                            index1 = 0;
	                            index2++;
	                        }
	                    }

	                    dlarfy('U', j, x, 1, tau[j - 1], array1, n, y);
	                    index1 = 0;
	                    index2 = 0;

	                    for (i = 0; i < (n * j); i++) {
	                        work[i] = array1[index1][index2];
	                        index1++;

	                        if (index1 == n) {
	                            index1 = 0;
	                            index2++;
	                        }
	                    }

	                    V[j - 1][j] = vsave;
	                    work[ (n + 1) * j] = D[j];
	                } // for (j = 1; j <= n-1; j++)
	            } // else upper

	            for (jcol = 1; jcol <= n; jcol++) {

	                if (lower) {

	                    for (jrow = jcol; jrow <= n; jrow++) {
	                        work[jrow + (n * (jcol - 1)) - 1] = work[jrow + (n * (jcol - 1)) - 1] - A[jrow - 1][jcol - 1];
	                    } // for (jrow = jcol; jrow <= n; jrow++)
	                } // if (lower)
	                else { // upper

	                    for (jrow = 1; jrow <= jcol; jrow++) {
	                        work[jrow + (n * (jcol - 1)) - 1] = work[jrow + (n * (jcol - 1)) - 1] - A[jrow - 1][jcol - 1];
	                    } // for (jrow = 1; jrow <= jcol; jrow++)
	                } // else upper
	            } // for (jcol = 1; jcol <= n; jcol++)

	            index1 = 0;
	            index2 = 0;
	            array1 = new double[n][n];

	            for (i = 0; i < (n * n); i++) {
	                array1[index1][index2] = work[i];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            wnorm = dlansy('1', cuplo, n, array1, n, work);
	        } // else if (itype == 2)
	        else if (itype == 3) {

	            // itype == 3: error = U V' - I
	            if (n < 2) {
	                return;
	            }

	            array1 = new double[n][n];
	            dlacpy(' ', n, n, U, ldu, array1, n);
	            index1 = 0;
	            index2 = 0;

	            for (i = 0; i < (n * n); i++) {
	                work[i] = array1[index1][index2];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            array1 = new double[ldv][n - 1];
	            array2 = new double[n][n - 1];

	            if (lower) {
	                index1 = 1;
	                index2 = 0;
	                index3 = 0;
	                index4 = 0;

	                for (i = 0; i < (ldv * (n - 1)); i++) {
	                    array1[index3][index4] = V[index1][index2];
	                    index1++;

	                    if (index1 == ldv) {
	                        index1 = 0;
	                        index2++;
	                    }

	                    index3++;

	                    if (index3 == ldv) {
	                        index3 = 0;
	                        index4++;
	                    }
	                }

	                index1 = 0;
	                index2 = 0;

	                for (i = 0; i < (n * (n - 1)); i++) {
	                    array2[index1][index2] = work[n + i];
	                    index1++;

	                    if (index1 == n) {
	                        index1 = 0;
	                        index2++;
	                    }
	                }

	                dorm2r('R', 'T', n, n - 1, n - 1, array1, ldv, tau, array2, n, x, iinfo);
	                index1 = 0;
	                index2 = 0;

	                for (i = 0; i < (n * (n - 1)); i++) {
	                    work[n + i] = array2[index1][index2];
	                    index1++;

	                    if (index1 == n) {
	                        index1 = 0;
	                        index2++;
	                    }
	                }
	            } // if (lower)
	            else { // upper
	                index1 = 0;
	                index2 = 1;
	                index3 = 0;
	                index4 = 0;

	                for (i = 0; i < (ldv * (n - 1)); i++) {
	                    array1[index3][index4] = V[index1][index2];
	                    index1++;

	                    if (index1 == ldv) {
	                        index1 = 0;
	                        index2++;
	                    }

	                    index3++;

	                    if (index3 == ldv) {
	                        index3 = 0;
	                        index4++;
	                    }
	                }

	                index1 = 0;
	                index2 = 0;

	                for (i = 0; i < (n * (n - 1)); i++) {
	                    array2[index1][index2] = work[i];
	                    index1++;

	                    if (index1 == n) {
	                        index1 = 0;
	                        index2++;
	                    }
	                }

	                dorm2l('R', 'T', n, n - 1, n - 1, array1, ldv, tau, array2, n, x, iinfo);
	                index1 = 0;
	                index2 = 0;

	                for (i = 0; i < (n * (n - 1)); i++) {
	                    work[i] = array2[index1][index2];
	                    index1++;

	                    if (index1 == n) {
	                        index1 = 0;
	                        index2++;
	                    }
	                }
	            } // else upper

	            if (iinfo[0] != 0) {
	                result[0] = 10.0 / ulp;

	                return;
	            } // if (iinfo[0] != 0)

	            for (j = 1; j <= n; j++) {
	                work[ (n + 1) * (j - 1)] = work[ (n + 1) * (j - 1)] - 1.0;
	            }

	            array1 = new double[n][n];
	            index1 = 0;
	            index2 = 0;

	            for (i = 0; i < (n * n); i++) {
	                array1[index1][index2] = work[i];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            wnorm = dlange('1', n, n, array1, n, x);
	        } // else if (itype == 3)

	        if (anorm > wnorm) {
	            result[0] = (wnorm / anorm) / (n * ulp);
	        } else if (anorm < 1.0) {
	            result[0] = (Math.min(wnorm, n * anorm) / anorm) / (n * ulp);
	        } else {
	            result[0] = Math.min(wnorm / anorm, (double) n) / (n * ulp);
	        }

	        // Do test 2
	        // Compute UU' - I
	        if (itype == 1) {
	            array1 = new double[n][n];
	            index1 = 0;
	            index2 = 0;

	            for (i = 0; i < (n * n); i++) {
	                array1[index1][index2] = work[i];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            dgemm('N', 'C', n, n, n, 1.0, U, ldu, U, ldu, 0.0, array1, n);
	            index1 = 0;
	            index2 = 0;

	            for (i = 0; i < (n * n); i++) {
	                work[i] = array1[index1][index2];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            for (j = 1; j <= n; j++) {
	                work[ (n + 1) * (j - 1)] = work[ (n + 1) * (j - 1)] - 1.0;
	            }

	            index1 = 0;
	            index2 = 0;

	            for (i = 0; i < (n * n); i++) {
	                array1[index1][index2] = work[i];
	                index1++;

	                if (index1 == n) {
	                    index1 = 0;
	                    index2++;
	                }
	            }

	            result[1] = Math.min(dlange('1', n, n, array1, n, x), (double) n) / (n * ulp);
	        } // if (itype == 1)

	        return;
	    } // dsyt21

	    /**
	     * This is a port of the version 3.1 LAPACK routine DSYTD2 Original DSYTD2 created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dsytd2 reduces a real symmetric matrix A to symmetric
	     * tridiagonal form T by an orthogonal similarity transformation: Q' * A * Q = T.
	     * 
	     * @param uplo input char Specifies whether the upper or lower triangular part of the symmetric matrix A is stored:
	     *            = 'U': Upper triangular = 'L': Lower triangular
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param A input/output double[][] of dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
	     *            leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and the
	     *            strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
	     *            triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
	     *            triangular part of A is not referenced. On exit, if uplo = 'U', the diagonal and first superdiagonal
	     *            of A are overwritten by the corresponding elements of the tridiagonal matrix T, and the elements above
	     *            the first superdiagonal, with the array tau, represent the orthogonal matrix Q as a product of
	     *            elementary reflectors; if uplo = 'L', the diagonal and first subdiagonal of A are overwritten by the
	     *            corresponding elements of the tridiagonal matrix T, and the elements below the first subdiagonal, with
	     *            the array tau, represent the orthogonal matrix Q as a product of elementary reflectors. See Further
	     *            Details.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param d output double[] of dimension n. The diagonal elements of the tridiagonal matrix T: D[i] = A[i][i].
	     * @param e output double[] of dimension n-1. The off-diagonal elements of the tridiagonal matrix T: e[i] =
	     *            A[i][i+1] if uplo = 'U', e[i] = A[i+1][i] if uplo = 'L'
	     * @param tau output double[] of dimension n-1. The scalar factors of the elementary reflectors (see Furtehr
	     *            Details).
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     * 
	     *            <p>
	     *            Further Details: If uplo = 'U', the matrix Q is represented as a product of elementary reflectors Q =
	     *            H[n-2] ... H[1] H[0] Each H[i] has the form H[i] = I - tau * v * v' where tau is a real scalar, and v
	     *            is a real vector with v(i:n-1) = 0 and v(i-1) = 1; v(0:i-2) is stored on exit in A(0:i-2,i), and tau
	     *            in tau[i-1]. If uplo = 'L', the matrix Q is represented as a product of elementary refelectors Q =
	     *            H[0] H[1] ... H[n-2] Each H[i] has the form H[i] = I - tau * v * v' where tau is a real scalar, and v
	     *            is a real vector with v(0:i-1) = 0 and v(i) = 1; v(i+1:n-1) is stored on exit in A(i+1:n-1,i-1), and
	     *            tau in tau[i-1].
	     *            </p>
	     * 
	     *            <p>
	     *            The contents of A on exit are illustrated by the following examples with n = 5: If uplo = 'U': (d e v2
	     *            v3 v4 ) ( d e v3 v4 ) ( d e v4 ) ( d e ) ( d ) If Uplo = 'L': (d ) (e d ) (v1 e d ) (v1 v2 e d ) (v1
	     *            v2 v3 e d ) where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element of
	     *            the vector defining H[i].
	     *            </p>
	     */
	    private void dsytd2(final char uplo, final int n, final double[][] A, final int lda, final double[] d,
	            final double[] e, final double[] tau, final int[] info) {
	        boolean upper;
	        int i;
	        int j;
	        int k;
	        double alpha;
	        final double[] taui = new double[1];
	        double[] vector1;
	        double[] vector2;
	        double[][] array1;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -4;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dsytd2 had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        if (n <= 0) {
	            return;
	        }

	        if (upper) {

	            // Reduce the upper triangle of A
	            for (i = n - 1; i >= 1; i--) {

	                // Generate elementary reflector H[i-1] = I - tau * v * v' to
	                // annihilate A(0:i-2,i)
	                if (i == 1) {
	                    taui[0] = 0.0;
	                } else {
	                    vector1 = new double[1];
	                    vector1[0] = A[i - 1][i];
	                    vector2 = new double[i - 1];

	                    for (j = 0; j < (i - 1); j++) {
	                        vector2[j] = A[j][i];
	                    }

	                    dlarfg(i, vector1, vector2, 1, taui);
	                    A[i - 1][i] = vector1[0];

	                    for (j = 0; j < (i - 1); j++) {
	                        A[j][i] = vector2[j];
	                    }
	                }

	                e[i - 1] = A[i - 1][i];

	                if (taui[0] != 0.0) {

	                    // Apply H[i-1] from both sides to A(0:i-1,0:i-1)
	                    A[i - 1][i] = 1.0;

	                    // Compute x = tau * A * v storing x in tau(0:i-1)
	                    vector1 = new double[i];

	                    for (j = 0; j < i; j++) {
	                        vector1[j] = A[j][i];
	                    }

	                    dsymv(uplo, i, taui[0], A, lda, vector1, 1, 0.0, tau, 1);

	                    // Compute w = x - 1/2 * tau * (x'*v) * v
	                    alpha = -0.5 * taui[0] * ddot(i, tau, 1, vector1, 1);
	                    daxpy(i, alpha, vector1, 1, tau, 1);

	                    // Apply the transformation as a rank-2 update:
	                    // A = A - v * w' - w * v'
	                    dsyr2(uplo, i, -1.0, vector1, 1, tau, 1, A, lda);
	                    A[i - 1][i] = e[i - 1];
	                } // if (taui[0] != 0.0)

	                d[i] = A[i][i];
	                tau[i - 1] = taui[0];
	            } // for (i = n-1; i >= 1; i--)

	            d[0] = A[0][0];
	        } // if (upper)
	        else { // lower

	            // Reduce the lower triangle of A
	            for (i = 1; i <= (n - 1); i++) {

	                // Generate elementary reflector H[i-1] = I - tau * v * v'
	                // to annihilate A(i+1:n-1,i-1)
	                if (i == (n - 1)) {
	                    taui[0] = 0.0;
	                } else {
	                    vector1 = new double[1];
	                    vector1[0] = A[i][i - 1];
	                    vector2 = new double[n - i - 1];

	                    for (j = 0; j < (n - i - 1); j++) {
	                        vector2[j] = A[j + Math.min(i + 1, n - 1)][i - 1];
	                    }

	                    dlarfg(n - i, vector1, vector2, 1, taui);
	                    A[i][i - 1] = vector1[0];

	                    for (j = 0; j < (n - i - 1); j++) {
	                        A[j + Math.min(i + 1, n - 1)][i - 1] = vector2[j];
	                    }
	                }

	                e[i - 1] = A[i][i - 1];

	                if (taui[0] != 0.0) {

	                    // Apply H[i-1] from both sides to A(i:n-1,i:n-1)
	                    A[i][i - 1] = 1.0;

	                    // Compute x = tau * A * v storing y in tau(i-1:n-2)
	                    array1 = new double[n - i][n - i];

	                    for (j = 0; j < (n - i); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            array1[j][k] = A[j + i][k + i];
	                        }
	                    }

	                    vector1 = new double[n - i];
	                    vector2 = new double[n - i];

	                    for (j = 0; j < (n - i); j++) {
	                        vector1[j] = A[j + i][i - 1];
	                        vector2[j] = tau[j + i - 1];
	                    }

	                    dsymv(uplo, n - i, taui[0], array1, n - i, vector1, 1, 0.0, vector2, 1);

	                    // Compute w = x - 1/2 * tau * (x'*v) * v
	                    alpha = -0.5 * taui[0] * ddot(n - i, vector2, 1, vector1, 1);
	                    daxpy(n - i, alpha, vector1, 1, vector2, 1);

	                    // Apply the transformation as a rank-2 update:
	                    // A = A - v * w' - w * v'
	                    dsyr2(uplo, n - i, -1.0, vector1, 1, vector2, 1, array1, n - i);

	                    for (j = 0; j < (n - i); j++) {
	                        tau[j + i - 1] = vector2[j];
	                    }

	                    for (j = 0; j < (n - i); j++) {

	                        for (k = 0; k < (n - i); k++) {
	                            A[j + i][k + i] = array1[j][k];
	                        }
	                    }

	                    A[i][i - 1] = e[i - 1];
	                } // if (taui[0] != 0.0)

	                d[i - 1] = A[i - 1][i - 1];
	                tau[i - 1] = taui[0];
	            } // for (i = 1; i <= n-1; i++)

	            d[n - 1] = A[n - 1][n - 1];
	        } // else lower

	        return;
	    } // dsytd2

	    /**
	     * This is a port of the version 3.1 LAPACK routine DSYTRD Original DSYTRD created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dsytrd reduces a real symmetric matrix A to a real symmetric
	     * tridiagonal form T by an orthogonal similarity transformation. Q'*A*Q = T.
	     * 
	     * @param uplo input char = 'U': Upper triangle of A is stored. = 'L': Lower triangle of A is stored.
	     * @param n input int The order of the matrix A. n >= 0.
	     * @param A input/output double[][] of dimension lda by n On entry, the symmetric matrix A. If uplo = 'U', the
	     *            leading n-by-n upper triangular part of A contains the upper triangular part of the matrix A, and the
	     *            strictly lower triangular part of A is not referenced. If uplo = 'L', the leading n-by-n lower
	     *            triangular part of A contains the lower triangular part of the matrix A, and the strictly upper
	     *            triangular part of A is not referenced. On exit, if uplo = 'U', the diagonal and first superdiagonal
	     *            of A are overwritten by the corresponding elements of the tridiagonal matrix T, and the elements above
	     *            the first superdiagonal, with the array tau, represent the orthogonal matrix Q as a product of
	     *            elementary reflectors; if uplo = 'L', the diagonal and first subdiagonal of A are overwritten by the
	     *            corresponding elements of the tridiagonal matrix T, and the elements below the first subdiagonal, with
	     *            the array tau, represent the orthogonal matrix Q as a product of elementary reflectors. See further
	     *            details.
	     * @param lda input int The leading dimension of the array A. lda >= max(1,n).
	     * @param d output double[] of dimension n The diagonal elements of the tridiagonal matrix T: d[i] = A[i][i].
	     * @param e output double[] of dimension n-1. The off-diagonal elements of the tridiagonal matrix T: e[i] =
	     *            A[i][i+1] if uplo = 'U', e[i] = A[i+1][i], if uplo = 'L'.
	     * @param tau output double[] of dimension n-1. The scalar factors of the elementary reflectors (see Further
	     *            Details).
	     * @param work (workspace/output) double[] of dimension max(1, lwork). On exit, if info[0] = 0, work[0] returns the
	     *            optimal lwork.
	     * @param lwork input int The dimension of the array work. lwork >= 1. For optimum performance lwork >= n*nb, where
	     *            nb is the optimal blocksize. if lwork = -1, then a workspace query is assumed; the routine only
	     *            calculates the optimal size of the work array, returns this value as the first entry of the work
	     *            array, and no error message related to lwork is issued.
	     * @param info output int[] = 0: successful exit < 0: If info = -i, the i-th argument had an illegal value
	     * 
	     *            <p>
	     *            Further details: If uplo = 'U', the matrix Q is represented as a product of elementary reflectors Q =
	     *            H[n-2]...H[1] H[0]. Each H[i] has the form H[i] = I - tau * v * v' where tau is a real scalar, and v
	     *            is a real vector with v(i:n-1) = 0 and v[i-1] = 1; v(0:i-2) is stored on exit in A(0:i-2,i), and tau
	     *            in tau[i-1]. If uplo = 'L', the matrix Q is represented as a product of elementary reflectors Q = H[0]
	     *            H[1] ... H[n-2] Each H[i] has the form H[i] = I - tau * v * v' where tau is a real scalar, and v is a
	     *            real vector with v(0:i-1) = 0 and v(i) = 0; v(i+1:n-1) is stored on exit in A(i+1:n-1,i-1), and tau in
	     *            tau[i-1].
	     *            </p>
	     * 
	     *            <p>
	     *            The contents of A on exit are illustrated by the following examples with n = 5: If uplo = 'U': (d e v2
	     *            v3 v4) ( d e v3 v4) ( d e v4) ( d e) ( d) If uplo = 'L': (d ) (e d ) (v1 e d ) (v1 v2 e d ) (v1 v2 v3
	     *            e d) where d and e denote diagonal and off-diagonal elements of T, and vi denotes an element of the
	     *            vector defining H[i].
	     *            </p>
	     */
	    private void dsytrd(final char uplo, final int n, final double[][] A, final int lda, final double[] d,
	            final double[] e, final double[] tau, final double[] work, final int lwork, final int[] info) {
	        boolean lquery;
	        boolean upper;
	        int i;
	        final int[] iinfo = new int[1];
	        int iws;
	        int j;
	        int kk;
	        int ldwork = n;
	        int lwkopt = 1;
	        int nb = 1;
	        int nbmin;
	        int nx;
	        final char[] ch = new char[1];
	        String opts = null;
	        double[][] array1;
	        double[][] array2;
	        int p;
	        int q;
	        double[][] work2d;
	        double[] vector1;
	        double[] vector2;
	        double[] vector3;
	        double[][] work2da;

	        // Test the input parameters
	        info[0] = 0;

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        if (lwork == -1) {
	            lquery = true;
	        } else {
	            lquery = false;
	        }

	        if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info[0] = -1;
	        } else if (n < 0) {
	            info[0] = -2;
	        } else if (lda < Math.max(1, n)) {
	            info[0] = -4;
	        } else if ( (lwork < 1) && ( !lquery)) {
	            info[0] = -9;
	        }

	        if (info[0] == 0) {

	            // Determine the block size
	            ch[0] = uplo;
	            opts = new String(ch);
	            nb = ilaenv(1, "DSYTRD", opts, n, -1, -1, -1);
	            lwkopt = n * nb;
	            work[0] = lwkopt;
	        } // if (info[0] == 0)

	        if (info[0] != 0) {
	            System.err.println("Error dsytrd had info[0] = " + info[0]);

	            return;
	        } // if (info[0] != 0)
	        else if (lquery) {
	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            work[0] = 1;

	            return;
	        } // if (n == 0)

	        nx = n;
	        iws = 1;

	        if ( (nb > 1) && (nb < n)) {

	            // Determine when to cross over from blocked to unblocked code (last
	            // block is always handled by unblocked code).
	            nx = Math.max(nb, ilaenv(3, "DSYTRD", opts, n, -1, -1, -1));

	            if (nx < n) {

	                // Determine if workspace is large enough for blocked code
	                ldwork = n;
	                iws = ldwork * nb;

	                if (lwork < iws) {

	                    // Not enough workspace to use optimal nb: determine the minimum
	                    // value of nb, and reduce nb or force use of unblocked code by
	                    // setting nx = n
	                    nb = Math.max(lwork / ldwork, 1);
	                    nbmin = ilaenv(2, "DSYTRD", opts, n, -1, -1, -1);

	                    if (nb < nbmin) {
	                        nx = n;
	                    }
	                } // if (lwork < iws)
	            } // if (nx < n)
	            else {
	                nx = n;
	            }
	        } // if ((nb > 1) && (nb < n))
	        else {
	            nb = 1;
	        }

	        if (upper) {
	            // Reduce the upper triangle of A.
	            // Columns 0:kk-1 are handled by the unblocked method.

	            kk = n - ( ( (n - nx + nb - 1) / nb) * nb);

	            for (i = n - nb + 1; i >= (kk + 1); i -= nb) {

	                // Reduce columns i-1:i+nb-2 to tridiagonal form and form the matrix
	                // W which is needed to update the unreduced part of the matrix
	                work2d = new double[ldwork][nb];
	                dlatrd(uplo, i + nb - 1, nb, A, lda, e, tau, work2d, ldwork);

	                // Update the unreduced submatrix A(0:i-2,0:i-2), using an update of
	                // the form: A = A - V*W' - W*V'
	                if (i != 1) {
	                    array1 = new double[i - 1][nb];

	                    for (p = 0; p < (i - 1); p++) {

	                        for (q = 0; q < nb; q++) {
	                            array1[p][q] = A[p][q + i - 1];
	                        }
	                    }

	                    dsyr2k(uplo, 'N', i - 1, nb, -1.0, array1, i - 1, work2d, ldwork, 1.0, A, lda);
	                } // if (i != 1)

	                // Copy the superdiagonal elements back into A, and diagonal elements
	                // into d
	                for (j = i; j <= (i + nb - 1); j++) {
	                    A[j - 2][j - 1] = e[j - 2];
	                    d[j - 1] = A[j - 1][j - 1];
	                }
	            } // for (i = n-nb+1; i >= kk+1; i-= nb)

	            // Use unblocked code to reduce the last or only block
	            dsytd2(uplo, kk, A, lda, d, e, tau, iinfo);
	        } // if (upper)
	        else { // lower

	            // Reduce lower triangle of A
	            for (i = 1; i <= (n - nx); i += nb) {

	                // Reduce columns i-1:i+nb-2 to tridiagonal form and form the matrix W
	                // which is needed to update the unreduced part of the matrix
	                array1 = new double[n - i + 1][n - i + 1];

	                for (p = 0; p < (n - i + 1); p++) {

	                    for (q = 0; q < (n - i + 1); q++) {
	                        array1[p][q] = A[p + i - 1][q + i - 1];
	                    }
	                }

	                vector1 = new double[n - i];
	                vector2 = new double[n - i];
	                work2d = new double[n - i + 1][nb];
	                dlatrd(uplo, n - i + 1, nb, array1, n - i + 1, vector1, vector2, work2d, n - i + 1);

	                for (p = 0; p < (n - i + 1); p++) {

	                    for (q = 0; q < (n - i + 1); q++) {
	                        A[p + i - 1][q + i - 1] = array1[p][q];
	                    }
	                }

	                for (p = 0; p < (n - i); p++) {
	                    e[p + i - 1] = vector1[p];
	                    tau[p + i - 1] = vector2[p];
	                }

	                // Update the unreduced submatrix A(i+ib-1:n-1,i+ib-1:n-1), using
	                // an update of the form: A = A - V*W' - W*V'
	                array1 = new double[n - i - nb + 1][nb];

	                for (p = 0; p < (n - i - nb + 1); p++) {

	                    for (q = 0; q < nb; q++) {
	                        array1[p][q] = A[p + i + nb - 1][q + i - 1];
	                    }
	                }

	                work2da = new double[n - i - nb + 1][nb];

	                for (p = 0; p < (n - i - nb + 1); p++) {

	                    for (q = 0; q < nb; q++) {
	                        work2da[p][q] = work2d[p + nb][q];
	                    }
	                }

	                array2 = new double[n - i - nb + 1][n - i - nb + 1];

	                for (p = 0; p < (n - i - nb + 1); p++) {

	                    for (q = 0; q < (n - i - nb + 1); q++) {
	                        array2[p][q] = A[p + i + nb - 1][q + i + nb - 1];
	                    }
	                }

	                dsyr2k(uplo, 'N', n - i - nb + 1, nb, -1.0, array1, n - i - nb + 1, work2da, n - i - nb + 1, 1.0,
	                        array2, n - i - nb + 1);

	                for (p = 0; p < (n - i - nb + 1); p++) {

	                    for (q = 0; q < (n - i - nb + 1); q++) {
	                        A[p + i + nb - 1][q + i + nb - 1] = array2[p][q];
	                    }
	                }

	                // Copy subdiagonal elements back into A, and diagonal elements
	                // into D.
	                for (j = i; j <= (i + nb - 1); j++) {
	                    A[j][j - 1] = e[j - 1];
	                    d[j - 1] = A[j - 1][j - 1];
	                }
	            } // for (i = 1; i <= n-nx; i += nb)

	            // Use unblocked code to reduce the last or only block
	            array1 = new double[n - i + 1][n - i + 1];

	            for (p = 0; p < (n - i + 1); p++) {

	                for (q = 0; q < (n - i + 1); q++) {
	                    array1[p][q] = A[p + i - 1][q + i - 1];
	                }
	            }

	            vector1 = new double[n - i + 1];
	            vector2 = new double[n - i];
	            vector3 = new double[n - i];
	            dsytd2(uplo, n - i + 1, array1, n - i + 1, vector1, vector2, vector3, iinfo);

	            for (p = 0; p < (n - i + 1); p++) {

	                for (q = 0; q < (n - i + 1); q++) {
	                    A[p + i - i][q + i - 1] = array1[p][q];
	                }
	            }

	            for (p = 0; p < (n - i + 1); p++) {
	                d[p + i - 1] = vector1[p];
	            }

	            for (p = 0; p < (n - i); p++) {
	                e[p + i - 1] = vector2[p];
	                tau[p + i - 1] = vector3[p];
	            }
	        } // else lower

	        work[0] = lwkopt;

	        return;
	    } // dsytrd

	    /**
	     * This is a port of version 3.1 LAPACK routine DTGEVC Original DTGEVC created by Univ. of Tennessee, Univ. of
	     * California Berkeley, and NAG Ltd., November, 2006 dtgevc computes some or all of the right and/or left
	     * eigenvectors of a pair of real eigenvectors of a pair of real matrices (S,P), where S is a quasi-triangular
	     * matrix and P is upper triangular. Matrix pairs of this type are produced by the generalized Schur factorization
	     * of a matrix pair (A,B): A = Q*S*Z**T, B = Q*P*Z**T as computed by dgghrd + dhgeqz
	     * 
	     * The right eigenvector x and the left eigenvector y of (S, P) corresponding to an eigenvalue w are defined by: S*x
	     * = w*P*x, (y**H)*S = w*(y**H)*P,
	     * 
	     * where y**H denotes the conjugate transpose of y. The eigenvalues are not input to this routine, but are computed
	     * directly from the diagonal blocks of S and P.
	     * 
	     * This routine returns the matrices X and/or Y of right and left eigenvectors of (S,P), or the products Z*X and/or
	     * Q*Y, where Z and Q are input matrices. If Q and Z are the orthogonal factors from the generalized Schur
	     * factorization of a matrix pair (A,B), then Z*X and Q*Y are the matrices of right and left eigenvectors of (A, B).
	     * 
	     * @param side input char = 'R': compute right eigenvectors only = 'L': compute left eigenvectors only = 'B':
	     *            compute both right and left eigenvectors
	     * @param howmny input char = 'A': compute all right and/or left eigenvectors = 'B': compute all right and/or left
	     *            eigenvectors, backtransformed by the matrices in vr and/or vl = 'S': Compute selected right and/or
	     *            left eigenvectors, specified by the boolean array select
	     * @param select input boolean[] of dimension (n) If howmny = 'S', select specifies the eigenvectors to be computed.
	     *            If w[j] is a real eigenvalue, the corresponding real eigenvector is computed if select[j] is true. If
	     *            w[j] and w[j+1] are real and imaginary parts of a complex eigenvalue, the corresponding complex
	     *            eigenvector is computed if either select[j] or select[j+1] is true, and on exit select[j] is set to
	     *            true and select[j+1] is set to false. Not referenced if howmny == 'A' or 'B'.
	     * @param n input int The order of the matrices S and P. n >= 0.
	     * @param S input double[][] of dimension (lds,n) The upper quasi-triangular matrix S from a generalized Schur
	     *            factorization, as computd by dhgeqz,
	     * @param lds input int The leading dimension of array S. lds >= max(1,n).
	     * @param P input double[][] of dimension (ldp,n) The upper triangular matrix P from a generalized Schur
	     *            factorization, as computed by dhgeqz. 2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
	     *            must be in positive diagonal form.
	     * @param ldp input int The leading dimension of the array P. ldp >= max(1,n).
	     * @param vl (input/output) double[][] of dimension (ldvl,mm) On entry, if side = 'L' or 'B' and howmny = 'B', vl
	     *            must contain an n-by-n matrix Q (usually the orthogonal matrix Q of left Schur vectors returned by
	     *            dhgeqz). On exit, if side = 'L' or 'B', vl contains: if howmny = 'A', the matrix Y of left
	     *            eigenvectors of (S,P) if howmny = 'B', the matrix Q*Y if howmny = 'S', the left eigenvectors of (S,P)
	     *            specified by select, stored consecutively in the columns of vl, in the same order as their
	     *            eigenvalues.
	     * 
	     *            <p>
	     *            A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the
	     *            first holding the real part, and the second the imaginary part.
	     * 
	     *            Not referenced if side == 'R'.
	     *            </p>
	     * @param ldvl input int The leading dimension of the array vl. ldvl >= 1, and if side == 'L' or 'B', ldvl >= n.
	     * @param vr (input/output) double[][] of dimension (ldvr,mm) On entry, if side = 'R' or 'B' and howmny = 'B', vr
	     *            must contain an n-by-n matrix Z (usually the orthogonal matrix Z of right Schur vectors returned by
	     *            dhgeqz).
	     * 
	     *            On exit, if side = 'R' or 'B', vr contains: if howmny = 'A', the matrix X of right eigenvectors of
	     *            (S,P) if howmny = 'B' or 'b', the matrix Z*X if howmny = 'S' or 's', the right eigenvectors of (S,P)
	     *            specified by select, stored consecutively in the columns of vr, in the same order as their
	     *            eigenvalues.
	     * 
	     *            <p>
	     *            A complex eigenvector corresponding to a complex eigenvalue is stored in two consecutive columns, the
	     *            first holding the real part and the second holding the imaginary part.
	     * 
	     *            Not referenced if side = 'L'.
	     *            </p>
	     * @param ldvr input int The leading dimension of the array vr. ldvr >= 1, and if side == 'R' or 'B', ldvr >= n.
	     * @param mm input int The number of columns in the arrays vl and/or vr. mm >= m.
	     * @param m output int[] The number of columns in the arrys vl and/or vr actually used to store the eigenvectors. If
	     *            howmny = 'A' or 'B', m is set to n. Each selected real eigenvector occupies one column and each
	     *            selected complex eigenvector occupies two columns.
	     * @param work workspace double[] of dimension (6*n)
	     * @param info output int[] = 0: successful exit < 0: if info[0] = -i, the i-th argument had an illegal value. > 0:
	     *            the 2-by-2 block (info-1:info) does not have a complex eigenvalue.
	     * 
	     *            Further details: Allocation of workspace: work[j] = 1-norm of j-th column of A, above the diagonal.
	     *            work[n+j] = 1-norm of j-th column of B, above the diagonal. work[2*n:3*n-1] = real part of eigenvector
	     *            work[3*n:4*n-1] = imaginary part of eigenvector work[4*n:5*n-1] = real part of back-transformed
	     *            eigenvector work[5*n:6*n-1] = imaginary part of back-transformed eigenvector
	     * 
	     *            Rowwise vs. columnwise solution methods:
	     * 
	     *            Finding a generalized eigenvector consists basically of solving the singular triangular system (A -
	     *            wB) x = 0 (for right) or: (A- wB)**H y = 0 (for left)
	     * 
	     *            <p>
	     *            Consider finding the i-th right eigenvector (assume all eigenvalues are real). The equation to be
	     *            solved is: 0 = sum from k=j to k=n-1 of C[j][k] v[k] = sum from k=j to k=i of C[j][k] v[k] for j =
	     *            i,...,0 where C = (A - w B) (The components v(i+1:n-1) are 0.)
	     *            </p>
	     * 
	     *            <p>
	     *            The "rowwise" method is: (1) v(i) := 1 for j = i-1,...,0: (2) compute s = -sum from k=j+1 to k=i of
	     *            C[j][k] v[k] and (3) v[j] := s / C[j][j]
	     *            </p>
	     * 
	     *            <p>
	     *            Step 2 is sometimes called the "dot product" step, since it is an inner product between the j-th row
	     *            and the portion of the eigenvector that has been computed so far.
	     *            </p>
	     * 
	     *            <p>
	     *            The "columnwise" method consists basically in doing the sums for all the rows in parallel. As each
	     *            v[j] is computed, the contribution of v[j] times the j-th column of C is added to the partial sums.
	     *            </p>
	     * 
	     *            <p>
	     *            When finding left eigenvectors, the matrix in question is the transpose of the one in storage, so the
	     *            rowwise method then actually accesses columns of A and B at each step.
	     *            </p>
	     */
	    private void dtgevc(final char side, final char howmny, final boolean[] select, final int n, final double[][] S,
	            final int lds, final double[][] P, final int ldp, final double[][] vl, final int ldvl, final double[][] vr,
	            final int ldvr, final int mm, final int[] m, final double[] work, final int[] info) {
	        final double safety = 100.0;
	        boolean compl;
	        boolean compr;
	        boolean il2by2;
	        boolean ilabad;
	        boolean ilall;
	        boolean ilback;
	        boolean ilbbad;
	        boolean ilcomp;
	        boolean ilcplx;
	        boolean lsa;
	        boolean lsb;
	        int i;
	        int ibeg;
	        int ieig;
	        int iend;
	        int ihwmny;
	        final int[] iinfo = new int[1];
	        int im;
	        int iside;
	        int j;
	        int ja;
	        int jc;
	        int je;
	        int jr;
	        int jw;
	        int na;
	        int nw;
	        final double[] acoef = new double[1];
	        double acoefa;
	        double anorm;
	        double ascale;
	        double bcoefa;
	        final double[] bcoefi = new double[1];
	        final double[] bcoefr = new double[1];
	        final double[] big = new double[1];
	        double bignum;
	        double bnorm;
	        double bscale;
	        double cim2a;
	        double cim2b;
	        double cimaga;
	        double cimagb;
	        double cre2a;
	        double cre2b;
	        double creala;
	        double crealb;
	        double dmin;
	        final double[] safmin = new double[1];
	        double salfar;
	        double sbeta;
	        final double[] scale = new double[1];
	        double small;
	        final double[] temp = new double[1];
	        final double[] temp2 = new double[1];
	        double temp2i;
	        double temp2r;
	        double ulp;
	        double xmax;
	        double xscale;
	        final double[] bdiag = new double[2];
	        final double[][] sum = new double[2][2];
	        final double[][] sums = new double[2][2];
	        final double[][] sump = new double[2][2];
	        double[][] array1;
	        double[][] array2;
	        double[] x;
	        double[] y;
	        int p;
	        int q;
	        int r;
	        int row1;

	        // Decode and test the input parameters
	        if ( (howmny == 'A') || (howmny == 'a')) {
	            ihwmny = 1;
	            ilall = true;
	            ilback = false;
	        } else if ( (howmny == 'S') || (howmny == 's')) {
	            ihwmny = 2;
	            ilall = false;
	            ilback = false;
	        } else if ( (howmny == 'B') || (howmny == 'b')) {
	            ihwmny = 3;
	            ilall = true;
	            ilback = true;
	        } else {
	            ihwmny = -1;
	            ilall = true;
	            ilback = false;
	        }

	        if ( (side == 'R') || (side == 'r')) {
	            iside = 1;
	            compl = false;
	            compr = true;
	        } else if ( (side == 'L') || (side == 'l')) {
	            iside = 2;
	            compl = true;
	            compr = false;
	        } else if ( (side == 'B') || (side == 'b')) {
	            iside = 3;
	            compl = true;
	            compr = true;
	        } else {
	            iside = -1;
	            compl = false;
	            compr = false;
	        }

	        info[0] = 0;

	        if (iside < 0) {
	            info[0] = -1;
	        } else if (ihwmny < 0) {
	            info[0] = -2;
	        } else if (n < 0) {
	            info[0] = -4;
	        } else if (lds < Math.max(1, n)) {
	            info[0] = -6;
	        } else if (ldp < Math.max(1, n)) {
	            info[0] = -8;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dtgevc had info[0] = " + info[0]);

	            return;
	        }

	        // Count the number of eigenvectors to be computed
	        if ( !ilall) {
	            im = 0;
	            ilcplx = false;

	            for (j = 0; j < n; j++) {

	                if (ilcplx) {
	                    ilcplx = false;

	                    continue;
	                } // if (ilcplx)

	                if (j < (n - 1)) {

	                    if (S[j + 1][j] != 0.0) {
	                        ilcplx = true;
	                    }
	                } // if (j < (n-1))

	                if (ilcplx) {

	                    if (select[j] || (select[j + 1])) {
	                        im = im + 2;
	                    }
	                } // if (ilcplx)
	                else if (select[j]) {
	                    im = im + 1;
	                } // else if (select[j])
	            } // for (j = 0; j < n; j++)
	        } // if (!ilall)
	        else { // ilall
	            im = n;
	        } // else ilall

	        // Check 2-by-2 diagonal blocks of S, P
	        ilabad = false;
	        ilbbad = false;

	        for (j = 0; j < (n - 1); j++) {

	            if (S[j + 1][j] != 0.0) {

	                if ( (P[j][j] == 0.0) || (P[j + 1][j + 1] == 0.0) || (P[j][j + 1] != 0.0)) {
	                    ilbbad = true;
	                }

	                if (j < (n - 2)) {

	                    if (S[j + 2][j + 1] != 0.0) {
	                        ilabad = true;
	                    }
	                } // if (j < n-2)
	            } // if (S[j+1][j] != 0.0)
	        } // for (j = 0; j < n-1; j++)

	        if (ilabad) {
	            info[0] = -5;
	        } else if (ilbbad) {
	            info[0] = -7;
	        } else if ( (compl && (ldvl < n)) || (ldvl < 1)) {
	            info[0] = -10;
	        } else if ( (compr && (ldvr < n)) || (ldvr < 1)) {
	            info[0] = -12;
	        } else if (mm < im) {
	            info[0] = -13;
	        }

	        if (info[0] != 0) {
	            System.err.println("Error dtgevc had info[0] = " + info[0]);

	            return;
	        }

	        // Quick return if possible
	        m[0] = im;

	        if (n == 0) {
	            return;
	        }

	        // Machine constants
	        safmin[0] = dlamch('S');
	        big[0] = 1.0 / safmin[0];
	        dlabad(safmin, big);
	        ulp = dlamch('E') * dlamch('B');
	        small = safmin[0] * n / ulp;
	        big[0] = 1.0 / small;
	        bignum = 1.0 / (safmin[0] * n);

	        // Compute the 1-norm of each column of the strictly upper triangular
	        // part (i.e., excluding all elements belonging to the diagonal blocks)
	        // of S and P to check for possible overflow in the triangular solver.
	        anorm = Math.abs(S[0][0]);

	        if (n > 1) {
	            anorm = anorm + Math.abs(S[1][0]);
	        }

	        bnorm = Math.abs(P[0][0]);
	        work[0] = 0.0;
	        work[n] = 0.0;

	        for (j = 2; j <= n; j++) {
	            temp[0] = 0.0;
	            temp2[0] = 0.0;

	            if (S[j - 1][j - 2] == 0.0) {
	                iend = j - 1;
	            } else {
	                iend = j - 2;
	            }

	            for (i = 1; i <= iend; i++) {
	                temp[0] = temp[0] + Math.abs(S[i - 1][j - 1]);
	                temp2[0] = temp2[0] + Math.abs(P[i - 1][j - 1]);
	            }

	            work[j - 1] = temp[0];
	            work[n - 1 + j] = temp2[0];

	            for (i = iend + 1; i <= Math.min(j + 1, n); i++) {
	                temp[0] = temp[0] + Math.abs(S[i - 1][j - 1]);
	                temp2[0] = temp2[0] + Math.abs(P[i - 1][j - 1]);
	            }

	            anorm = Math.max(anorm, temp[0]);
	            bnorm = Math.max(bnorm, temp2[0]);
	        } // for (j = 2; j <= n; j++)

	        ascale = 1.0 / Math.max(anorm, safmin[0]);
	        bscale = 1.0 / Math.max(bnorm, safmin[0]);

	        // Left eigenvectors
	        if (compl) {
	            ieig = 0;

	            // Main loop over eigenvalues
	            ilcplx = false;

	            for (je = 1; je <= n; je++) {

	                // Skip this iteration if (a) howmny = 'S' and select = false, or
	                // (b) this would be the second of a complex pair.
	                // Check for complex eigenvalue, so as to be sure of which
	                // entry(-ies) of select to look at.
	                if (ilcplx) {
	                    ilcplx = false;

	                    continue;
	                } // if (ilcplx)

	                nw = 1;

	                if (je < n) {

	                    if (S[je][je - 1] != 0.0) {
	                        ilcplx = true;
	                        nw = 2;
	                    } // if (S[je][je-1] != 0.0)
	                } // if (je < n)

	                if (ilall) {
	                    ilcomp = true;
	                } else if (ilcplx) {
	                    ilcomp = select[je - 1] || select[je];
	                } else {
	                    ilcomp = select[je - 1];
	                } // else

	                if ( !ilcomp) {
	                    continue;
	                } // if (!ilcomp)

	                // Decide if (a) singular pencil, (b) real eigenvalue, or
	                // (c) complex eigenvalue
	                if ( !ilcplx) {

	                    if ( (Math.abs(S[je - 1][je - 1]) <= safmin[0]) && (Math.abs(P[je - 1][je - 1]) <= safmin[0])) {

	                        // Singular matrix pencil -- return unit eigenvector
	                        ieig = ieig + 1;

	                        for (jr = 1; jr <= n; jr++) {
	                            vl[jr - 1][ieig - 1] = 0.0;
	                        }

	                        vl[ieig - 1][ieig - 1] = 1.0;

	                        continue;
	                    } // if ((Math.abs(S[je-1][je-1]) <= safmin[0]) &&
	                } // if (!ilcplx)

	                // Clear vector
	                for (jr = 0; jr < (nw * n); jr++) {
	                    work[ (2 * n) + jr] = 0.0;
	                }

	                // Compute coefficients in (a S - b B)transpose y = 0
	                // a is acoef
	                // b is coefr + i*bcoefi
	                if ( !ilcplx) {

	                    // Real eigenvalue
	                    temp[0] = Math.max(Math.abs(S[je - 1][je - 1]) * ascale, Math.abs(P[je - 1][je - 1]) * bscale);
	                    temp[0] = Math.max(temp[0], safmin[0]);
	                    temp[0] = 1.0 / temp[0];
	                    salfar = (temp[0] * S[je - 1][je - 1]) * ascale;
	                    sbeta = (temp[0] * P[je - 1][je - 1]) * bscale;
	                    acoef[0] = sbeta * ascale;
	                    bcoefr[0] = salfar * bscale;
	                    bcoefi[0] = 0.0;

	                    // Scale to avoid underflow
	                    scale[0] = 1.0;
	                    lsa = ( (Math.abs(sbeta) >= safmin[0]) && (Math.abs(acoef[0]) < small));
	                    lsb = ( (Math.abs(salfar) >= safmin[0]) && (Math.abs(bcoefr[0]) < small));

	                    if (lsa) {
	                        scale[0] = (small / Math.abs(sbeta)) * Math.min(anorm, big[0]);
	                    }

	                    if (lsb) {
	                        scale[0] = Math.max(scale[0], (small / Math.abs(salfar)) * Math.min(bnorm, big[0]));
	                    }

	                    if (lsa || lsb) {
	                        temp[0] = Math.max(1.0, Math.abs(acoef[0]));
	                        temp[0] = Math.max(temp[0], Math.abs(bcoefr[0]));
	                        scale[0] = Math.min(scale[0], 1.0 / (safmin[0] * temp[0]));

	                        if (lsa) {
	                            acoef[0] = ascale * (scale[0] * sbeta);
	                        } else {
	                            acoef[0] = scale[0] * acoef[0];
	                        }

	                        if (lsb) {
	                            bcoefr[0] = bscale * (scale[0] * salfar);
	                        } else {
	                            bcoefr[0] = scale[0] * bcoefr[0];
	                        }
	                    } // if (lsa || lsb)

	                    acoefa = Math.abs(acoef[0]);
	                    bcoefa = Math.abs(bcoefr[0]);

	                    // First component is 1
	                    work[ (2 * n) + je - 1] = 1.0;
	                    xmax = 1.0;
	                } // if (!ilcplx)
	                else { // complex eigenvalue
	                    array1 = new double[2][2];
	                    array2 = new double[2][2];

	                    for (p = 0; p < 2; p++) {

	                        for (q = 0; q < 2; q++) {
	                            array1[p][q] = S[je - 1 + p][je - 1 + q];
	                            array2[p][q] = P[je - 1 + p][je - 1 + q];
	                        }
	                    }

	                    dlag2(array1, 2, array2, 2, safmin[0] * safety, acoef, temp, bcoefr, temp2, bcoefi);
	                    bcoefi[0] = -bcoefi[0];

	                    if (bcoefi[0] == 0.0) {
	                        info[0] = je;

	                        return;
	                    } // if (bcoefi[0] == 0.0)

	                    // Scale to avoid over/underflow
	                    acoefa = Math.abs(acoef[0]);
	                    bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
	                    scale[0] = 1.0;

	                    if ( ( (acoefa * ulp) < safmin[0]) && (acoefa >= safmin[0])) {
	                        scale[0] = (safmin[0] / ulp) / acoefa;
	                    }

	                    if ( ( (bcoefa * ulp) < safmin[0]) && (bcoefa >= safmin[0])) {
	                        scale[0] = Math.max(scale[0], (safmin[0] / ulp) / bcoefa);
	                    }

	                    if ( (safmin[0] * acoefa) > ascale) {
	                        scale[0] = ascale / (safmin[0] * acoefa);
	                    }

	                    if ( (safmin[0] * bcoefa) > bscale) {
	                        scale[0] = Math.min(scale[0], bscale / (safmin[0] * bcoefa));
	                    }

	                    if (scale[0] != 1.0) {
	                        acoef[0] = scale[0] * acoef[0];
	                        acoefa = Math.abs(acoef[0]);
	                        bcoefr[0] = scale[0] * bcoefr[0];
	                        bcoefi[0] = scale[0] * bcoefi[0];
	                        bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
	                    } // if (scale != 1.0)

	                    // Compute first two components of eigenvector
	                    temp[0] = acoef[0] * S[je][je - 1];
	                    temp2r = (acoef[0] * S[je - 1][je - 1]) - (bcoefr[0] * P[je - 1][je - 1]);
	                    temp2i = -bcoefi[0] * P[je - 1][je - 1];

	                    if (Math.abs(temp[0]) > (Math.abs(temp2r) + Math.abs(temp2i))) {
	                        work[ (2 * n) + je - 1] = 1.0;
	                        work[ (3 * n) + je - 1] = 0.0;
	                        work[ (2 * n) + je] = -temp2r / temp[0];
	                        work[ (3 * n) + je] = -temp2i / temp[0];
	                    } else {
	                        work[ (2 * n) + je] = 1.0;
	                        work[ (3 * n) + je] = 0.0;
	                        temp[0] = acoef[0] * S[je - 1][je];
	                        work[ (2 * n) + je - 1] = ( (bcoefr[0] * P[je][je]) - (acoef[0] * S[je][je])) / temp[0];
	                        work[ (3 * n) + je - 1] = bcoefi[0] * P[je][je] / temp[0];
	                    }

	                    xmax = Math.max(Math.abs(work[ (2 * n) + je - 1]) + Math.abs(work[ (3 * n) + je - 1]), Math
	                            .abs(work[ (2 * n) + je])
	                            + Math.abs(work[ (3 * n) + je]));
	                } // else complex eigenvalue

	                dmin = Math.max(ulp * acoefa * anorm, ulp * bcoefa * bnorm);
	                dmin = Math.max(dmin, safmin[0]);

	                // Triangular solve of (a S - b P)transpose y = 0
	                // (rowwise in (a S - b P )transpose,
	                // or columnwise in (a S - b P))
	                il2by2 = false;

	                for (j = je + nw; j <= n; j++) {

	                    if (il2by2) {
	                        il2by2 = false;

	                        continue;
	                    } // if (il2by2)

	                    na = 1;
	                    bdiag[0] = P[j - 1][j - 1];

	                    if (j < n) {

	                        if (S[j][j - 1] != 0.0) {
	                            il2by2 = true;
	                            bdiag[1] = P[j][j];
	                            na = 2;
	                        } // if (S[j][j-1] != 0.0)
	                    } // if (j < n)

	                    // Check whether scaling is necessary for dot products
	                    xscale = 1.0 / Math.max(1.0, xmax);
	                    temp[0] = Math.max(work[j - 1], work[n + j - 1]);
	                    temp[0] = Math.max(temp[0], (acoefa * work[j - 1]) + (bcoefa * work[n + j - 1]));

	                    if (il2by2) {
	                        temp[0] = Math.max(temp[0], work[j]);
	                        temp[0] = Math.max(temp[0], work[n + j]);
	                        temp[0] = Math.max(temp[0], (acoefa * work[j]) + (bcoefa * work[n + j]));
	                    } // if (il2by2)

	                    if (temp[0] > (bignum * xscale)) {

	                        for (jw = 0; jw <= (nw - 1); jw++) {

	                            for (jr = je; jr <= (j - 1); jr++) {
	                                work[ ( (jw + 2) * n) + jr - 1] = xscale * work[ ( (jw + 2) * n) + jr - 1];
	                            } // for (jr = je; jr <= j - 1; jr++)
	                        } // for (jw = 0; jw <= nw-1; jw++)

	                        xmax = xmax * xscale;
	                    } // if (temp[0] > bignum * xscale)

	                    // Compute dot products
	                    // SUM = sum from k = je to k = j-1 of
	                    // conjg(a * S[k-1][j-1] - b*P[k-1][j-1]) * x[k-1]
	                    // To reduce the op count, this is done as
	                    // aconjg*conjg(sum from k=je to k=j-1 of S[k-1][j-1]*x[k-1])
	                    // - bonjg*conjg(sum from k=je to k=j-1 of P[k-1][j-1]*x[k-1])
	                    // which may cause underflow problems if S or P are close to
	                    // underflow. (e.g., less than small.)
	                    for (jw = 1; jw <= nw; jw++) {

	                        for (ja = 1; ja <= na; ja++) {
	                            sums[ja - 1][jw - 1] = 0.0;
	                            sump[ja - 1][jw - 1] = 0.0;

	                            for (jr = je; jr <= (j - 1); jr++) {
	                                sums[ja - 1][jw - 1] = sums[ja - 1][jw - 1]
	                                        + (S[jr - 1][j + ja - 2] * work[ ( (jw + 1) * n) + jr - 1]);
	                                sump[ja - 1][jw - 1] = sump[ja - 1][jw - 1]
	                                        + (P[jr - 1][j + ja - 2] * work[ ( (jw + 1) * n) + jr - 1]);
	                            } // for (jr = je; jr <= j-1; jr++)
	                        } // for (ja = 1; ja <= na; ja++)
	                    } // for (jw = 1; jw <= nw; jw++)

	                    for (ja = 0; ja < na; ja++) {

	                        if (ilcplx) {
	                            sum[ja][0] = ( -acoef[0] * sums[ja][0]) + (bcoefr[0] * sump[ja][0])
	                                    - (bcoefi[0] * sump[ja][1]);
	                            sum[ja][1] = ( -acoef[0] * sums[ja][1]) + (bcoefr[0] * sump[ja][1])
	                                    + (bcoefi[0] * sump[ja][0]);
	                        } else { // if (ilcplx), !ilcplx
	                            sum[ja][0] = ( -acoef[0] * sums[ja][0]) + (bcoefr[0] * sump[ja][0]);
	                        } // else !ilcplx
	                    } // for (ja = 0; ja < na; ja++)

	                    // Solve (a S - b B)transpose y = SUM(,)
	                    // with scaling and perturbation of the denominator
	                    array1 = new double[na][na];

	                    for (p = 0; p < na; p++) {

	                        for (q = 0; q < na; q++) {
	                            array1[p][q] = S[j - 1 + p][j - 1 + q];
	                        }
	                    }

	                    array2 = new double[na][nw];
	                    dlaln2(true, na, nw, dmin, acoef[0], array1, na, bdiag[0], bdiag[1], sum, 2, bcoefr[0], bcoefi[0],
	                            array2, na, scale, temp, iinfo);
	                    work[ (2 * n) + j - 1] = array2[0][0];

	                    if (na == 2) {
	                        work[ (2 * n) + j] = array2[1][0];
	                    }

	                    if (nw == 2) {
	                        work[ (3 * n) + j - 1] = array2[0][1];

	                        if (na == 2) {
	                            work[ (3 * n) + j] = array2[1][1];
	                        }
	                    }

	                    if (scale[0] < 1.0) {

	                        for (jw = 0; jw <= (nw - 1); jw++) {

	                            for (jr = je; jr <= (j - 1); jr++) {
	                                work[ ( (jw + 2) * n) + jr - 1] = scale[0] * work[ ( (jw + 2) * n) + jr - 1];
	                            } // for (jr = je; jr <= j-1; jr++)
	                        } // for (jw = 0; jw <= nw - 1; jw++)

	                        xmax = scale[0] * xmax;
	                    } // if (scale[0] < 1.0)

	                    xmax = Math.max(xmax, temp[0]);
	                } // for (j = je + nw; j <= n; j++)

	                // Copy eigenvector to vl, back transforming if howmny == 'B'
	                ieig = ieig + 1;

	                if (ilback) {

	                    for (jw = 0; jw <= (nw - 1); jw++) {
	                        row1 = Math.max(1, n);
	                        array1 = new double[row1][n + 1 - je];

	                        for (p = 0; p < row1; p++) {

	                            for (q = 0; q < (n + 1 - je); q++) {
	                                array1[p][q] = vl[p][je - 1 + q];
	                            }
	                        }

	                        x = new double[n + 1 - je];

	                        for (p = 0; p < (n + 1 - je); p++) {
	                            x[p] = work[ ( (jw + 2) * n) + je - 1 + p];
	                        }

	                        y = new double[n];

	                        for (p = 0; p < n; p++) {
	                            y[p] = work[ ( (jw + 4) * n) + p];
	                        }

	                        dgemv('N', n, n + 1 - je, 1.0, array1, row1, x, 1, 0.0, y, 1);

	                        for (p = 0; p < n; p++) {
	                            work[ ( (jw + 4) * n) + p] = y[p];
	                        }
	                    } // for (jw = 0; jw <= nw - 1; jw++)

	                    array1 = new double[n][nw];
	                    r = 0;

	                    for (q = 0; q < nw; q++) {

	                        for (p = 0; p < n; p++) {
	                            array1[p][q] = work[ (4 * n) + r];
	                            r++;
	                        }
	                    }

	                    array2 = new double[n][nw];
	                    dlacpy(' ', n, nw, array1, n, array2, n);

	                    for (p = 0; p < n; p++) {

	                        for (q = 0; q < nw; q++) {
	                            vl[p][je - 1 + q] = array2[p][q];
	                        }
	                    }

	                    ibeg = 1;
	                } // if (ilback)
	                else { // !ilback
	                    array1 = new double[n][nw];
	                    r = 0;

	                    for (q = 0; q < nw; q++) {

	                        for (p = 0; p < n; p++) {
	                            array1[p][q] = work[ (2 * n) + r];
	                            r++;
	                        }
	                    }

	                    array2 = new double[n][nw];
	                    dlacpy(' ', n, nw, array1, n, array2, n);

	                    for (p = 0; p < n; p++) {

	                        for (q = 0; q < nw; q++) {
	                            vl[p][ieig - 1 + q] = array2[p][q];
	                        }
	                    }

	                    ibeg = je;
	                } // else !ilback

	                // Scale eigenvector
	                xmax = 0.0;

	                if (ilcplx) {

	                    for (j = ibeg - 1; j < n; j++) {
	                        xmax = Math.max(xmax, Math.abs(vl[j][ieig - 1]) + Math.abs(vl[j][ieig]));
	                    }
	                } // if (ilcplx)
	                else { // !ilcplx

	                    for (j = ibeg - 1; j < n; j++) {
	                        xmax = Math.max(xmax, Math.abs(vl[j][ieig - 1]));
	                    }
	                } // else !ilcplx

	                if (xmax > safmin[0]) {
	                    xscale = 1.0 / xmax;

	                    for (jw = 0; jw <= (nw - 1); jw++) {

	                        for (jr = ibeg; jr <= n; jr++) {
	                            vl[jr - 1][ieig + jw - 1] = xscale * vl[jr - 1][ieig + jw - 1];
	                        }
	                    }
	                } // if (xmax > safmin[0])

	                ieig = ieig + nw - 1;
	            } // for (je = 1; je <= n; je++)
	        } // if (compl)

	        // Right eigenvectors
	        if (compr) {
	            ieig = im + 1;

	            // Main loop over eigenvalues
	            ilcplx = false;

	            for (je = n; je >= 1; je--) {

	                // Skip this iteration if (a) howmny = 'S' and select = false, or
	                // (b) this would be the second of a complex pair.
	                // Check for complex eigenvalue, so as to be sure of which
	                // entry(-ies) of select to look at -- if complex, select[je-1]
	                // or select[je-2]
	                // If this is a complex pair, the 2-by-2 diagonal block
	                // corresponding to the eigenvalue is i0n rows/columns je-2:je-1
	                if (ilcplx) {
	                    ilcplx = false;

	                    continue;
	                } // if (ilcplx)

	                nw = 1;

	                if (je > 1) {

	                    if (S[je - 1][je - 2] != 0.0) {
	                        ilcplx = true;
	                        nw = 2;
	                    } // if (S[je-1][je-2] != 0.0)
	                } // if (je > 1)

	                if (ilall) {
	                    ilcomp = true;
	                } // if (ilall)
	                else if (ilcplx) {
	                    ilcomp = select[je - 1] || select[je - 2];
	                } // else if (ilcplx)
	                else {
	                    ilcomp = select[je - 1];
	                }

	                if ( !ilcomp) {
	                    continue;
	                } // if (!ilcomp)

	                // Decide if (a) singular pencil, (b) real eigenvalue, or
	                // (c) complex eigenvalue.
	                if ( !ilcplx) {

	                    if ( (Math.abs(S[je - 1][je - 1]) <= safmin[0]) && (Math.abs(P[je - 1][je - 1]) <= safmin[0])) {

	                        // Singular matrix pencil -- unit eigenvector
	                        ieig = ieig - 1;

	                        for (jr = 0; jr < n; jr++) {
	                            vr[jr][ieig - 1] = 0.0;
	                        }

	                        vr[ieig - 1][ieig - 1] = 1.0;

	                        continue;
	                    } // if ((Math.abs(S[je-1][je-1]) <= safmin[0]) &&
	                } // if (!ilcplx)

	                // Clear vector
	                for (jw = 0; jw <= (nw - 1); jw++) {

	                    for (jr = 1; jr <= n; jr++) {
	                        work[ ( (jw + 2) * n) + jr - 1] = 0.0;
	                    }
	                }

	                // Compute coefficients in (a S - b B) x = 0
	                // a is acoef[0]
	                // b is bcoefr + i*bcoefi[0]
	                if ( !ilcplx) {

	                    // Real eigenvalue
	                    temp[0] = Math.max(Math.abs(S[je - 1][je - 1]) * ascale, Math.abs(P[je - 1][je - 1]) * bscale);
	                    temp[0] = Math.max(temp[0], safmin[0]);
	                    temp[0] = 1.0 / temp[0];
	                    salfar = (temp[0] * S[je - 1][je - 1]) * ascale;
	                    sbeta = (temp[0] * P[je - 1][je - 1]) * bscale;
	                    acoef[0] = sbeta * ascale;
	                    bcoefr[0] = salfar * bscale;
	                    bcoefi[0] = 0.0;

	                    // Scale to avoid underflow
	                    scale[0] = 1.0;
	                    lsa = ( (Math.abs(sbeta) >= safmin[0]) && (Math.abs(acoef[0]) < small));
	                    lsb = ( (Math.abs(salfar) >= safmin[0]) && (Math.abs(bcoefr[0]) < small));

	                    if (lsa) {
	                        scale[0] = (small / Math.abs(sbeta)) * Math.min(anorm, big[0]);
	                    } // if (lsa)

	                    if (lsb) {
	                        scale[0] = Math.max(scale[0], (small / Math.abs(salfar)) * Math.min(bnorm, big[0]));
	                    } // if (lsb)

	                    if (lsa || lsb) {
	                        temp[0] = Math.max(1.0, Math.abs(acoef[0]));
	                        temp[0] = Math.max(temp[0], Math.abs(bcoefr[0]));
	                        scale[0] = Math.min(scale[0], 1.0 / (safmin[0] * temp[0]));

	                        if (lsa) {
	                            acoef[0] = ascale * (scale[0] * sbeta);
	                        } else {
	                            acoef[0] = scale[0] * acoef[0];
	                        }

	                        if (lsb) {
	                            bcoefr[0] = bscale * (scale[0] * salfar);
	                        } else {
	                            bcoefr[0] = scale[0] * bcoefr[0];
	                        }
	                    } // if (lsa || lsb)

	                    acoefa = Math.abs(acoef[0]);
	                    bcoefa = Math.abs(bcoefr[0]);

	                    // First component is 1
	                    work[ (2 * n) + je - 1] = 1.0;
	                    xmax = 1.0;

	                    // Compute contribution from column je-1 of S and P to sum
	                    // (See "Further Details" above.)
	                    for (jr = 1; jr <= (je - 1); jr++) {
	                        work[ (2 * n) + jr - 1] = (bcoefr[0] * P[jr - 1][je - 1]) - (acoef[0] * S[jr - 1][je - 1]);
	                    } // for (jr = 1; jr <= je-1; jr++)
	                } // if (!ilcplx)
	                else { // ilcplx

	                    // Complex eigenvalue
	                    array1 = new double[2][2];
	                    array2 = new double[2][2];

	                    for (p = 0; p < 2; p++) {

	                        for (q = 0; q < 2; q++) {
	                            array1[p][q] = S[je - 2 + p][je - 2 + q];
	                            array2[p][q] = P[je - 2 + p][je - 2 + q];
	                        }
	                    }

	                    dlag2(array1, 2, array2, 2, safmin[0] * safety, acoef, temp, bcoefr, temp2, bcoefi);

	                    if (bcoefi[0] == 0.0) {
	                        info[0] = je - 1;

	                        return;
	                    } // if (bcoefi[0] == 0.0)

	                    // Scale to avoid over/underflow
	                    acoefa = Math.abs(acoef[0]);
	                    bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
	                    scale[0] = 1.0;

	                    if ( ( (acoefa * ulp) < safmin[0]) && (acoefa >= safmin[0])) {
	                        scale[0] = (safmin[0] / ulp) / acoefa;
	                    }

	                    if ( ( (bcoefa * ulp) < safmin[0]) && (bcoefa >= safmin[0])) {
	                        scale[0] = Math.max(scale[0], (safmin[0] / ulp) / bcoefa);
	                    }

	                    if ( (safmin[0] * acoefa) > ascale) {
	                        scale[0] = ascale / (safmin[0] * acoefa);
	                    }

	                    if ( (safmin[0] * bcoefa) > bscale) {
	                        scale[0] = Math.min(scale[0], bscale / (safmin[0] * bcoefa));
	                    }

	                    if (scale[0] != 1.0) {
	                        acoef[0] = scale[0] * acoef[0];
	                        acoefa = Math.abs(acoef[0]);
	                        bcoefr[0] = scale[0] * bcoefr[0];
	                        bcoefi[0] = scale[0] * bcoefi[0];
	                        bcoefa = Math.abs(bcoefr[0]) + Math.abs(bcoefi[0]);
	                    } // if (scale[0] != 1.0)

	                    // Compute first two components of eigenvector
	                    // and contribution to sums
	                    temp[0] = acoef[0] * S[je - 1][je - 2];
	                    temp2r = (acoef[0] * S[je - 1][je - 1]) - (bcoefr[0] * P[je - 1][je - 1]);
	                    temp2i = -bcoefi[0] * P[je - 1][je - 1];

	                    if (Math.abs(temp[0]) >= (Math.abs(temp2r) + Math.abs(temp2i))) {
	                        work[ (2 * n) + je - 1] = 1.0;
	                        work[ (3 * n) + je - 1] = 0.0;
	                        work[ (2 * n) + je - 2] = -temp2r / temp[0];
	                        work[ (3 * n) + je - 2] = -temp2i / temp[0];
	                    } // if (Math.abs(temp[0]) >= Math.abs(temp2r) +
	                    else {
	                        work[ (2 * n) + je - 2] = 1.0;
	                        work[ (3 * n) + je - 2] = 0.0;
	                        temp[0] = acoef[0] * S[je - 2][je - 1];
	                        work[ (2 * n) + je - 1] = ( (bcoefr[0] * P[je - 2][je - 2]) - (acoef[0] * S[je - 2][je - 2]))
	                                / temp[0];
	                        work[ (3 * n) + je - 1] = bcoefi[0] * P[je - 2][je - 2] / temp[0];
	                    } // else

	                    xmax = Math.max(Math.abs(work[ (2 * n) + je - 1]) + Math.abs(work[ (3 * n) + je - 1]), Math
	                            .abs(work[ (2 * n) + je - 2])
	                            + Math.abs(work[ (3 * n) + je - 2]));

	                    // Compute contribution from columns je-1 and je-2
	                    // of A and B to the sums
	                    creala = acoef[0] * work[ (2 * n) + je - 2];
	                    cimaga = acoef[0] * work[ (3 * n) + je - 2];
	                    crealb = (bcoefr[0] * work[ (2 * n) + je - 2]) - (bcoefi[0] * work[ (3 * n) + je - 2]);
	                    cimagb = (bcoefi[0] * work[ (2 * n) + je - 2]) + (bcoefr[0] * work[ (3 * n) + je - 2]);
	                    cre2a = acoef[0] * work[ (2 * n) + je - 1];
	                    cim2a = acoef[0] * work[ (3 * n) + je - 1];
	                    cre2b = (bcoefr[0] * work[ (2 * n) + je - 1]) - (bcoefi[0] * work[ (3 * n) + je - 1]);
	                    cim2b = (bcoefi[0] * work[ (2 * n) + je - 1]) + (bcoefr[0] * work[ (3 * n) + je - 1]);

	                    for (jr = 1; jr <= (je - 2); jr++) {
	                        work[ (2 * n) + jr - 1] = ( -creala * S[jr - 1][je - 2]) + (crealb * P[jr - 1][je - 2])
	                                - (cre2a * S[jr - 1][je - 1]) + (cre2b * P[jr - 1][je - 1]);
	                        work[ (3 * n) + jr - 1] = ( -cimaga * S[jr - 1][je - 2]) + (cimagb * P[jr - 1][je - 2])
	                                - (cim2a * S[jr - 1][je - 1]) + (cim2b * P[jr - 1][je - 1]);
	                    } // for (jr = 1; jr <= je-2; jr++)
	                } // else ilcplx

	                dmin = Math.max(ulp * acoefa * anorm, ulp * bcoefa * bnorm);
	                dmin = Math.max(dmin, safmin[0]);

	                // Columnwise triangular solve of (a S - b P) x = 0
	                il2by2 = false;

	                for (j = je - nw; j >= 1; j--) {

	                    // If a 2-by-2 block is in position j-2:j-1, wait until
	                    // next iteration to process it (when it will be j-1:j)
	                    if ( ( !il2by2) && (j > 1)) {

	                        if (S[j - 1][j - 2] != 0.0) {
	                            il2by2 = true;

	                            continue;
	                        }
	                    } // if ((!il2by2) && (j > 1))

	                    bdiag[0] = P[j - 1][j - 1];

	                    if (il2by2) {
	                        na = 2;
	                        bdiag[1] = P[j][j];
	                    } else {
	                        na = 1;
	                    }

	                    // Compute x[j-1] (and x[j], if 2-by-2 block)
	                    array1 = new double[na][na];

	                    for (p = 0; p < na; p++) {

	                        for (q = 0; q < na; q++) {
	                            array1[p][q] = S[j - 1 + p][j - 1 + q];
	                        }
	                    }

	                    array2 = new double[n][nw];
	                    r = 0;

	                    for (q = 0; q < nw; q++) {

	                        for (p = 0; p < n; p++) {
	                            array2[p][q] = work[ (2 * n) + j - 1 + r];
	                            r++;
	                        }
	                    }

	                    dlaln2(false, na, nw, dmin, acoef[0], array1, na, bdiag[0], bdiag[1], array2, n, bcoefr[0],
	                            bcoefi[0], sum, 2, scale, temp, iinfo);

	                    if (scale[0] < 1.0) {

	                        for (jw = 0; jw <= (nw - 1); jw++) {

	                            for (jr = 1; jr <= je; jr++) {
	                                work[ ( (jw + 2) * n) + jr - 1] = scale[0] * work[ ( (jw + 2) * n) + jr - 1];
	                            }
	                        }
	                    } // if (scale[0] < 1.0)

	                    xmax = Math.max(scale[0] * xmax, temp[0]);

	                    for (jw = 1; jw <= nw; jw++) {

	                        for (ja = 1; ja <= na; ja++) {
	                            work[ ( (jw + 1) * n) + j + ja - 2] = sum[ja - 1][jw - 1];
	                        }
	                    }

	                    // w = w + x[j-1]*(a S(*,j-1) - b P(*,j-1) with scaling
	                    if (j > 1) {

	                        // Check whether scaling is necessary for sum
	                        xscale = 1.0 / Math.max(1.0, xmax);
	                        temp[0] = (acoefa * work[j - 1]) + (bcoefa * work[n + j - 1]);

	                        if (il2by2) {
	                            temp[0] = Math.max(temp[0], (acoefa * work[j]) + (bcoefa * work[n + j]));
	                        } // if (il2by2)

	                        temp[0] = Math.max(temp[0], acoefa);
	                        temp[0] = Math.max(temp[0], bcoefa);

	                        if (temp[0] > (bignum * xscale)) {

	                            for (jw = 0; jw <= (nw - 1); jw++) {

	                                for (jr = 1; jr <= je; jr++) {
	                                    work[ ( (jw + 2) * n) + jr - 1] = xscale * work[ ( (jw + 2) * n) + jr - 1];
	                                }
	                            }

	                            xmax = xmax * xscale;
	                        } // if (temp[0] > bignum*xscale)

	                        // Compute the contributions of the off-diagonals of
	                        // column j-1 (and j, if 2-by-2 block) of S and P to the
	                        // sums.

	                        for (ja = 1; ja <= na; ja++) {

	                            if (ilcplx) {
	                                creala = acoef[0] * work[ (2 * n) + j + ja - 2];
	                                cimaga = acoef[0] * work[ (3 * n) + j + ja - 2];
	                                crealb = (bcoefr[0] * work[ (2 * n) + j + ja - 2])
	                                        - (bcoefi[0] * work[ (3 * n) + j + ja - 2]);
	                                cimagb = (bcoefi[0] * work[ (2 * n) + j + ja - 2])
	                                        + (bcoefr[0] * work[ (3 * n) + j + ja - 2]);

	                                for (jr = 1; jr <= (j - 1); jr++) {
	                                    work[ (2 * n) + jr - 1] = work[ (2 * n) + jr - 1]
	                                            - (creala * S[jr - 1][j + ja - 2]) + (crealb * P[jr - 1][j + ja - 2]);
	                                    work[ (3 * n) + jr - 1] = work[ (3 * n) + jr - 1]
	                                            - (cimaga * S[jr - 1][j + ja - 2]) + (cimagb * P[jr - 1][j + ja - 2]);
	                                } // for (jr = 1; jr <= j-1; jr++)
	                            } // if (ilcplx)
	                            else { // !ilcplx
	                                creala = acoef[0] * work[ (2 * n) + j + ja - 2];
	                                crealb = bcoefr[0] * work[ (2 * n) + j + ja - 2];

	                                for (jr = 1; jr <= (j - 1); jr++) {
	                                    work[ (2 * n) + jr - 1] = work[ (2 * n) + jr - 1]
	                                            - (creala * S[jr - 1][j + ja - 2]) + (crealb * P[jr - 1][j + ja - 2]);
	                                } // for (jr = 1; jr <= j-1; jr++)
	                            } // else !ilcplx
	                        } // for (ja = 1; ja <= na; ja++)
	                    } // if (j > 1)

	                    il2by2 = false;
	                } // for (j = je - nw; j >= 1; j--)

	                // Copy eigenvector to vr, back transforming if howmny == 'B'
	                ieig = ieig - nw;

	                if (ilback) {

	                    for (jw = 0; jw <= (nw - 1); jw++) {

	                        for (jr = 1; jr <= n; jr++) {
	                            work[ ( (jw + 4) * n) + jr - 1] = work[ (jw + 2) * n] * vr[jr - 1][0];
	                        }

	                        for (jc = 2; jc <= je; jc++) {

	                            for (jr = 1; jr <= n; jr++) {
	                                work[ ( (jw + 4) * n) + jr - 1] = work[ ( (jw + 4) * n) + jr - 1]
	                                        + (work[ ( (jw + 2) * n) + jc - 1] * vr[jr - 1][jc - 1]);
	                            }
	                        }
	                    } // for (jw = 0; jw <= nw-1; jw++)

	                    for (jw = 0; jw <= (nw - 1); jw++) {

	                        for (jr = 1; jr <= n; jr++) {
	                            vr[jr - 1][ieig + jw - 1] = work[ ( (jw + 4) * n) + jr - 1];
	                        }
	                    }

	                    iend = n;
	                } // if (ilback)
	                else { // !ilback

	                    for (jw = 0; jw <= (nw - 1); jw++) {

	                        for (jr = 1; jr <= n; jr++) {
	                            vr[jr - 1][ieig + jw - 1] = work[ ( (jw + 2) * n) + jr - 1];
	                        }
	                    }

	                    iend = je;
	                } // else !ilback

	                // Scale eigenvector
	                xmax = 0.0;

	                if (ilcplx) {

	                    for (j = 1; j <= iend; j++) {
	                        xmax = Math.max(xmax, Math.abs(vr[j - 1][ieig - 1]) + Math.abs(vr[j - 1][ieig]));
	                    }
	                } // if (ilcplx)
	                else {

	                    for (j = 1; j <= iend; j++) {
	                        xmax = Math.max(xmax, Math.abs(vr[j - 1][ieig - 1]));
	                    }
	                } // else

	                if (xmax > safmin[0]) {
	                    xscale = 1.0 / xmax;

	                    for (jw = 0; jw <= (nw - 1); jw++) {

	                        for (jr = 1; jr <= iend; jr++) {
	                            vr[jr - 1][ieig + jw - 1] = xscale * vr[jr - 1][ieig + jw - 1];
	                        }
	                    }
	                } // if (xmax > safmin[0])
	            } // for (je = n; je >= 1; je--)
	        } // if (compr)

	        return;
	    } // dtgevc

	    /**
	     * This is a port of the 2/8/89 Blas routine DTRMM Original code written by: Jack Dongarra, Argonne National
	     * Laboratory Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
	     * Algorithms Group Ltd. dtrmm performs one of the matrix-matrix operations B = alpha*op(A)*B or B = alpha*B*op(A),
	     * where alpha is scalar, B is an m by n matrix, A is a unit, or non-unit, upper or lower tringular matrix and op(A)
	     * is one of op(A) = A or op(A) = A'.
	     * 
	     * @param side input char On entry, side specifies whether op(A) multiplies B from the left or right as follows: =
	     *            'L' or 'l' B = alpha*op(A)*B = 'R' or 'r' B = alpha*B*op(A)
	     * @param uplo input char On entry, uplo specifies whether matrix A is an upper or lower triangular matrix as
	     *            follows: = 'U' or 'u' A is an upper triangular matrix = 'L' or 'l' A is a lower triangular matrix
	     * @param transa input char On entry, transa specifies the form of op(A) to be used in the matrix multiplication as
	     *            follows: = 'N' or 'n' op(A) = A = 'T' or 't' op(A) = A' = 'C' or 'c' op(A) = A'
	     * @param diag input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u' A is
	     *            assumed to be unit triangular = 'N' or 'n' A is not assumed to be unit triangular
	     * @param m input int On entry, m specifies the number of rows of B. m must be at least zero.
	     * @param n input int On entry, n specifies the number of columns of B. n must be at least zero.
	     * @param alpha input double Specified scalar. When alpha is zero then A is not referenced and B need not be set
	     *            before entry.
	     * @param A input double[][] of dimension lda by k, where k is m when side = 'L' or 'l' and is n when side = 'R' or
	     *            'r'. Before entry with uplo = 'U' or 'u', the leading k by k upper triangular part of the array A must
	     *            contain the upper triangular matrix and the strictly lower triangular part of A is not referenced.
	     *            Before entry with uplo = 'L' or 'l', the leading k by k lower triangular part of the array A must
	     *            contain the lower triangular matrix and the strictly upper triangular part of A is not referenced.
	     *            Note that when diag = 'U' or 'u', the diagonal elements of A are not referenced either, but are
	     *            assumed to be unity.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            When side = 'L' or 'l' then lda must be at least max(1,m), when side = 'R' or 'r' then lda must be at
	     *            least max(1,n).
	     * @param B input/output double[][] of dimension ldb by n Before entry, the leading m by n part of the array B must
	     *            contain the matrix B, and on exit is overwritten by the transformed matrix.
	     * @param ldb input int On entry, ldb specifies the first dimension of B as declared in the calling (sub) program.
	     *            ldb must be at least max(1,m).
	     */
	    private void dtrmm(final char side, final char uplo, final char transa, final char diag, final int m, final int n,
	            final double alpha, final double[][] A, final int lda, final double[][] B, final int ldb) {
	        boolean lside;
	        boolean nounit;
	        boolean upper;
	        int i;
	        int info;
	        int j;
	        int k;
	        int nrowa;
	        double temp;

	        // Test the input parameters
	        if ( (side == 'L') || (side == 'l')) {
	            lside = true;
	        } else {
	            lside = false;
	        }

	        if (lside) {
	            nrowa = m;
	        } else {
	            nrowa = n;
	        }

	        if ( (diag == 'N') || (diag == 'n')) {
	            nounit = true;
	        } else {
	            nounit = false;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        info = 0;

	        if ( ( !lside) && (side != 'R') && (side != 'r')) {
	            info = 1;
	        } else if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info = 2;
	        } else if ( (transa != 'N') && (transa != 'n') && (transa != 'T') && (transa != 't') && (transa != 'C')
	                && (transa != 'c')) {
	            info = 3;
	        } else if ( (diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
	            info = 4;
	        } else if (m < 0) {
	            info = 5;
	        } else if (n < 0) {
	            info = 6;
	        } else if (lda < Math.max(1, nrowa)) {
	            info = 9;
	        } else if (ldb < Math.max(1, m)) {
	            info = 11;
	        }

	        if (info != 0) {
	            System.err.println("Error dtrmm had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if (alpha == 0.0) {

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    B[i][j] = 0.0;
	                }
	            }

	            return;
	        } // if (alpha == 0.0)

	        if (lside) {

	            if ( (transa == 'N') || (transa == 'n')) {

	                // Form B = alpha*A*B
	                if (upper) {

	                    for (j = 0; j < n; j++) {

	                        for (k = 0; k < m; k++) {

	                            if (B[k][j] != 0.0) {
	                                temp = alpha * B[k][j];

	                                for (i = 0; i <= (k - 1); i++) {
	                                    B[i][j] = B[i][j] + (temp * A[i][k]);
	                                }

	                                if (nounit) {
	                                    temp = temp * A[k][k];
	                                }

	                                B[k][j] = temp;
	                            } // if (B[k][j] != 0.0)
	                        } // for (k = 0; k < m; k++)
	                    } // for (j = 0; j < n; j++)
	                } // if (upper)
	                else { // lower

	                    for (j = 0; j < n; j++) {

	                        for (k = m - 1; k >= 0; k--) {

	                            if (B[k][j] != 0.0) {
	                                temp = alpha * B[k][j];
	                                B[k][j] = temp;

	                                if (nounit) {
	                                    B[k][j] = B[k][j] * A[k][k];
	                                }

	                                for (i = k + 1; i < m; i++) {
	                                    B[i][j] = B[i][j] + (temp * A[i][k]);
	                                }
	                            } // if (B[k][j] != 0.0)
	                        } // for (k = m-1; k >= 0; k--)
	                    } // for (j = 0; j < n; j++)
	                } // lower
	            } // if (transa == 'N') || (transa == 'n'))
	            else { // ((transa != 'N') && (transa != 'n'))

	                // Form B = alpha*A'*B
	                if (upper) {

	                    for (j = 0; j < n; j++) {

	                        for (i = m - 1; i >= 0; i--) {
	                            temp = B[i][j];

	                            if (nounit) {
	                                temp = temp * A[i][i];
	                            }

	                            for (k = 0; k <= (i - 1); k++) {
	                                temp = temp + (A[k][i] * B[k][j]);
	                            }

	                            B[i][j] = alpha * temp;
	                        } // for (i = m-1; i >= 0; i--)
	                    } // for (j = 0; j < n; j++)
	                } // if (upper)
	                else { // lower

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i < m; i++) {
	                            temp = B[i][j];

	                            if (nounit) {
	                                temp = temp * A[i][i];
	                            }

	                            for (k = i + 1; k < m; k++) {
	                                temp = temp + (A[k][i] * B[k][j]);
	                            }

	                            B[i][j] = alpha * temp;
	                        } // for (i = 0; i < m; i++)
	                    } // for (j = 0; j < n; j++)
	                } // lower
	            } // else ((transa != 'N') && (transa != 'n'))
	        } // if (lside)
	        else { // !lside

	            if ( (transa == 'N') || (transa == 'n')) {

	                // Form B = alpha*B*A
	                if (upper) {

	                    for (j = n - 1; j >= 0; j--) {
	                        temp = alpha;

	                        if (nounit) {
	                            temp = temp * A[j][j];
	                        }

	                        for (i = 0; i < m; i++) {
	                            B[i][j] = temp * B[i][j];
	                        }

	                        for (k = 0; k <= (j - 1); k++) {

	                            if (A[k][j] != 0.0) {
	                                temp = alpha * A[k][j];

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] + (temp * B[i][k]);
	                                }
	                            } // if (A[k][j] != 0.0)
	                        } // for (k = 0; k <= j-1; k++)
	                    } // for (j = n-1; j >= 0; j--)
	                } // if (upper)
	                else { // lower

	                    for (j = 0; j < n; j++) {
	                        temp = alpha;

	                        if (nounit) {
	                            temp = temp * A[j][j];
	                        }

	                        for (i = 0; i < m; i++) {
	                            B[i][j] = temp * B[i][j];
	                        }

	                        for (k = j + 1; k < n; k++) {

	                            if (A[k][j] != 0.0) {
	                                temp = alpha * A[k][j];

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] + (temp * B[i][k]);
	                                }
	                            } // if (A[k][j] != 0.0)
	                        } // for (k = j+1; k < n; k++)
	                    } // for (j = 0; j < n; j++)
	                } // lower
	            } // if (transa == 'N') || (transa == 'n'))
	            else { // ((transa != 'N') && (transa != 'n'))

	                // Form B = alpha*B*A'
	                if (upper) {

	                    for (k = 0; k < n; k++) {

	                        for (j = 0; j <= (k - 1); j++) {

	                            if (A[j][k] != 0.0) {
	                                temp = alpha * A[j][k];

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] + (temp * B[i][k]);
	                                }
	                            } // if (A[j][k] != 0.0)
	                        } // for (j = 0; j <= k-1; j++)

	                        temp = alpha;

	                        if (nounit) {
	                            temp = temp * A[k][k];
	                        }

	                        if (temp != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][k] = temp * B[i][k];
	                            }
	                        } // if (temp != 1.0)
	                    } // for (k = 0; k < n; k++)
	                } // if (upper)
	                else { // lower

	                    for (k = n - 1; k >= 0; k--) {

	                        for (j = k + 1; j < n; j++) {

	                            if (A[j][k] != 0.0) {
	                                temp = alpha * A[j][k];

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] + (temp * B[i][k]);
	                                }
	                            } // if (A[j][k] != 0.0)
	                        } // for (j = k+1; j < n; j++)

	                        temp = alpha;

	                        if (nounit) {
	                            temp = temp * A[k][k];
	                        }

	                        if (temp != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][k] = temp * B[i][k];
	                            } // for (i = 0; i < m; i++)
	                        } // if (temp != 1.0)
	                    } // for (k = n-1; k >= 0; k--)
	                } // lower
	            } // else ((transa != 'N') && (transa != 'n'))
	        } // else !lside

	        return;
	    } // dtrmm

	    /**
	     * This is a port of the 10/22/86 blas routine DTRMV Original version written by: Jack Dongarra, Argonne National
	     * Lab. Jeremy Du Croz, Nag Central Office Sven Hammarling, Nag Central Office Richard Hanson, Sandia National Labs.
	     * dtrmv performs one of the matrix-vector operations x = A*x or x = A'*x where x is an n element vector and A is an
	     * n by n unit, or non-unit, upper or lower triangular matrix
	     * 
	     * @param uplo input char On entry, uplo specifies whether the matrix is an upper or lower triangular matrix as
	     *            follows: = 'U' or 'u' A is an upper triangular matrix = 'L' or 'l' A is a lower triangular matrix
	     * @param trans input char On entry, trans specifies the operation to be performed as follows: = 'N' or 'n', x = A*x
	     *            = 'T' or 't', x = A'*x = 'C' or 'c', x = A'*x
	     * @param diag input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u' A is
	     *            assumed to be unit triangular. = 'N' or 'n' A is not assumed to be unit triangular.
	     * @param n input int On entry, n specifies the order of the matrix A. n must be at least zero.
	     * @param A input double[][] dimension lda by n Before entry with uplo = 'U' or 'u', the leading n by n upper
	     *            triangular part of the array A must contain the upper triangular matrix and the strictly lower
	     *            triangular part of A is not referenced. Before entry with uplo = 'L' or 'l', the leading n by n lower
	     *            triangular part of the array A must contain the lower triangular matrix and the strictly upper
	     *            triangular part of A is not referenced. Note that when diag = 'U' or 'u', the diagonal elements of A
	     *            are not referenced either, but are assumed to be unity.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1,n).
	     * @param x input/output double[] of dimension at least (1 + (n-1)*abs(incx)) Before entry, the incremented array x
	     *            must contain the n element vector x. On exit, array x is is overwritten with the transformed vector x.
	     * @param incx input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     */
	    private void dtrmv(final char uplo, final char trans, final char diag, final int n, final double[][] A,
	            final int lda, final double[] x, final int incx) {
	        double temp;
	        int i;
	        int info;
	        int ix;
	        int j;
	        int jx;
	        int kx = 0;
	        boolean nounit;

	        // Test the input parameters
	        info = 0;

	        if ( (uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
	            info = 1;
	        } else if ( (trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C')
	                && (trans != 'c')) {
	            info = 2;
	        } else if ( (diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
	            info = 3;
	        } else if (n < 0) {
	            info = 4;
	        } else if (lda < Math.max(1, n)) {
	            info = 6;
	        } else if (incx == 0) {
	            info = 8;
	        }

	        if (info != 0) {
	            System.err.println("Error dtrmv had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if ( (diag == 'N') || (diag == 'n')) {
	            nounit = true;
	        } else {
	            nounit = false;
	        }

	        // Set up the start point in x if the increment is not unity. This will
	        // be (n-1)*incx too small for descending loops.

	        if (incx <= 0) {
	            kx = 1 - ( (n - 1) * incx);
	        } else if (incx != 1) {
	            kx = 1;
	        }

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through A.
	        if ( (trans == 'N') || (trans == 'n')) {

	            // Form x = A*x
	            if ( (uplo == 'U') || (uplo == 'u')) {

	                if (incx == 1) {

	                    for (j = 0; j < n; j++) {

	                        if (x[j] != 0.0) {
	                            temp = x[j];

	                            for (i = 0; i <= (j - 1); i++) {
	                                x[i] = x[i] + (temp * A[i][j]);
	                            }

	                            if (nounit) {
	                                x[j] = x[j] * A[j][j];
	                            }
	                        } // if (x[j] != 0.0)
	                    } // for (j = 0; j < n; j++)
	                } // if (incx == 1)
	                else { // incx != 1
	                    jx = kx - 1;

	                    for (j = 0; j < n; j++) {

	                        if (x[jx] != 0.0) {
	                            temp = x[jx];
	                            ix = kx - 1;

	                            for (i = 0; i <= (j - 1); i++) {
	                                x[ix] = x[ix] + (temp * A[i][j]);
	                                ix = ix + incx;
	                            } // for (i = 0; i <= j-1; i++)

	                            if (nounit) {
	                                x[jx] = x[jx] * A[j][j];
	                            }
	                        } // if (x[jx] != 0.0)

	                        jx = jx + incx;
	                    } // for (j = 0; j < n; j++)
	                } // else incx != 1
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // uplo == 'L' || uplo == 'l'

	                if (incx == 1) {

	                    for (j = n - 1; j >= 0; j--) {

	                        if (x[j] != 0.0) {
	                            temp = x[j];

	                            for (i = n - 1; i >= (j + 1); i--) {
	                                x[i] = x[i] + (temp * A[i][j]);
	                            } // for (i = n-1; i >= j+1; i--)

	                            if (nounit) {
	                                x[j] = x[j] * A[j][j];
	                            }
	                        } // if (x[j] != 0.0)
	                    } // for (j = n-1; j >= 0; j--)
	                } // if (incx == 1)
	                else { // incx != 1
	                    kx = kx + ( (n - 1) * incx);
	                    jx = kx - 1;

	                    for (j = n - 1; j >= 0; j--) {

	                        if (x[jx] != 0.0) {
	                            temp = x[jx];
	                            ix = kx - 1;

	                            for (i = n - 1; i >= (j + 1); i--) {
	                                x[ix] = x[ix] + (temp * A[i][j]);
	                                ix = ix - incx;
	                            } // for (i = n-1; i >= j+1; i--)

	                            if (nounit) {
	                                x[jx] = x[jx] * A[j][j];
	                            }
	                        } // if (x[jx] != 0.0)

	                        jx = jx - incx;
	                    } // for (j = n-1; j >= 0; j--)
	                } // else incx != 1
	            } // else uplo == 'L' || uplo == 'l'
	        } // if ((trans == 'N') || (trans == 'n'))
	        else { // trans != 'N' && trans != 'n'

	            // Form x = A'*x
	            if ( (uplo == 'U') || (uplo == 'u')) {

	                if (incx == 1) {

	                    for (j = n - 1; j >= 0; j--) {
	                        temp = x[j];

	                        if (nounit) {
	                            temp = temp * A[j][j];
	                        }

	                        for (i = j - 1; i >= 0; i--) {
	                            temp = temp + (A[i][j] * x[i]);
	                        } // for (i = j-1; i >= 0; i--)

	                        x[j] = temp;
	                    } // for (j = n-1; j >= 0; j--)
	                } // if (incx == 1)
	                else { // incx != 1
	                    jx = kx + ( (n - 1) * incx) - 1;

	                    for (j = n - 1; j >= 0; j--) {
	                        temp = x[jx];
	                        ix = jx;

	                        if (nounit) {
	                            temp = temp * A[j][j];
	                        }

	                        for (i = j - 1; i >= 0; i--) {
	                            ix = ix - incx;
	                            temp = temp + (A[i][j] * x[ix]);
	                        } // for (i = j-1; i >= 0; i--)

	                        x[jx] = temp;
	                        jx = jx - incx;
	                    } // for (j = n-1; j >= 0; j--)
	                } // else incx != 1
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l')) {

	                if (incx == 1) {

	                    for (j = 0; j < n; j++) {
	                        temp = x[j];

	                        if (nounit) {
	                            temp = temp * A[j][j];
	                        }

	                        for (i = j + 1; i < n; i++) {
	                            temp = temp + (A[i][j] * x[i]);
	                        } // for (i = j+1; i < n; i++)

	                        x[j] = temp;
	                    } // for (j = 0; j < n; j++)
	                } // if (incx == 1)
	                else { // incx != 1
	                    jx = kx - 1;

	                    for (j = 0; j < n; j++) {
	                        temp = x[jx];
	                        ix = jx;

	                        if (nounit) {
	                            temp = temp * A[j][j];
	                        }

	                        for (i = j + 1; i < n; i++) {
	                            ix = ix + incx;
	                            temp = temp + (A[i][j] * x[ix]);
	                        } // for (i = j+1; i < n; i++)

	                        x[jx] = temp;
	                        jx = jx + incx;
	                    } // for (j = 0; j < n; j++)
	                } // else incx != 1
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else trans != 'N' && trans != 'n'

	        return;
	    } // dtrmv

	    /**
	     * This is a port of the 2/8/89 Blas routine DTRSM Original code written by: Jack Dongarra, Argonne National
	     * Laboratory Iain Duff, AERE Harwell. Jeremy Du Croz, Numerical Algorithms Group Ltd. Sven Hammarling, Numerical
	     * Algorithms Group Ltd. dtrsm solves one of the matrix equations op(A)*X = alpha*B or X*op(A) = alpha*B, where
	     * alpha is a scalar, X and B are m by n matrices, A is a unit, or non-unit, upper or lower triangular matrix and
	     * op(A) is one of op(A) = A or op(A) = A'. The matrix X is overwritten on B.
	     * 
	     * @param side input char On entry, side specifies whether op(A) appears on the left or right or X as follows: = 'L'
	     *            or 'l' op(A)*X = alpha*B = 'R' or 'r' X*op(A) = alpha*B
	     * @param uplo input char On entry, uplo specifies whether the matrix A is an upper or lower triangular matrix as
	     *            follows: = 'U' or 'u' A is an upper triangular matrix = 'L' or 'l' A is a lower triangular matrix
	     * @param transa input char On entry, transa specifies the form of op(A) to be used in the matrix multiplication as
	     *            follows: = 'N' or 'n' op(A) = A, 'T' or 't' op(A) = A', 'C' or 'c' op(A) = A'
	     * @param diag input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u' A is
	     *            assumed to be unit triangular. = 'N' or 'n' A is not assumed to be unit triangular.
	     * @param m input int On entry, m specifies the number of rows of B. m must be at least zero.
	     * @param n input int On entry, n specifies the number of columns of B. n must be at least zero.
	     * @param alpha input double Specified scalar. When alpha is zero then A is not referenced and B need not be set
	     *            before entry.
	     * @param A input double[][] of dimension lda by k, where k is m when side = 'L' or 'l' and is n when side = 'R' or
	     *            'r'. Before entry with uplo = 'U' or 'u', the leading k by k upper triangular part of the array A must
	     *            contain the upper triangular matrix and the strictly lower part of A is not referenced. Before entry
	     *            with uplo = 'L' or 'l', the leading k by k lower triangular part of the array A must contain the lower
	     *            triangular matrix and the strictly upper triangular part of A is not referenced. Note that when diag =
	     *            'U' or 'u', the diagonal elements of A are not referenced either, but are assumed to be unity.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            When side = 'L' or 'l', then lda must be at least max(1,m). When side = 'R' or 'r', then lda must be
	     *            at least max(1,n).
	     * @param B input/output double[][] of dimension ldb by n. Before entry, the leading m by n part of the array B must
	     *            contain the right-hand side matrix B, and on exit is overwritten by the solution matrix X.
	     * @param ldb input int On entry, ldb specifies the first dimension of B as declared in the calling (sub) program.
	     *            ldb must be at least max(1,m).
	     */
	    private void dtrsm(final char side, final char uplo, final char transa, final char diag, final int m, final int n,
	            final double alpha, final double[][] A, final int lda, final double[][] B, final int ldb) {
	        boolean lside;
	        boolean nounit;
	        boolean upper;
	        int i;
	        int info;
	        int j;
	        int k;
	        int nrowa;
	        double temp;

	        // Test the input parameters
	        if ( (side == 'L') || (side == 'l')) {
	            lside = true;
	        } else {
	            lside = false;
	        }

	        if (lside) {
	            nrowa = m;
	        } else {
	            nrowa = n;
	        }

	        if ( (diag == 'N') || (diag == 'n')) {
	            nounit = true;
	        } else {
	            nounit = false;
	        }

	        if ( (uplo == 'U') || (uplo == 'u')) {
	            upper = true;
	        } else {
	            upper = false;
	        }

	        info = 0;

	        if ( ( !lside) && (side != 'R') && (side != 'r')) {
	            info = 1;
	        } else if ( ( !upper) && (uplo != 'L') && (uplo != 'l')) {
	            info = 2;
	        } else if ( (transa != 'N') && (transa != 'n') && (transa != 'T') && (transa != 't') && (transa != 'C')
	                && (transa != 'c')) {
	            info = 3;
	        } else if ( (diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
	            info = 4;
	        } else if (m < 0) {
	            info = 5;
	        } else if (n < 0) {
	            info = 6;
	        } else if (lda < Math.max(1, nrowa)) {
	            info = 9;
	        } else if (ldb < Math.max(1, m)) {
	            info = 11;
	        }

	        if (info != 0) {
	            System.err.println("Error dtrsm had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if (alpha == 0.0) {

	            for (j = 0; j < n; j++) {

	                for (i = 0; i < m; i++) {
	                    B[i][j] = 0.0;
	                }
	            }

	            return;
	        } // if (alpha == 0.0)

	        if (lside) {

	            if ( (transa == 'N') || (transa == 'n')) {

	                // Form B = alpha*inv(A)*B
	                if (upper) {

	                    for (j = 0; j < n; j++) {

	                        if (alpha != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][j] = alpha * B[i][j];
	                            }
	                        } // if (alpha != 1.0)

	                        for (k = m - 1; k >= 0; k--) {

	                            if (B[k][j] != 0.0) {

	                                if (nounit) {
	                                    B[k][j] = B[k][j] / A[k][k];
	                                }

	                                for (i = 0; i <= (k - 1); i++) {
	                                    B[i][j] = B[i][j] - (B[k][j] * A[i][k]);
	                                }
	                            } // if (B[k][j] != 0.0)
	                        } // for (k = m-1; k >= 0; k--)
	                    } // for (j = 0; j < n; j++)
	                } // if (upper)
	                else { // lower

	                    for (j = 0; j < n; j++) {

	                        if (alpha != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][j] = alpha * B[i][j];
	                            }
	                        } // if (alpha != 1.0)

	                        for (k = 0; k < m; k++) {

	                            if (B[k][j] != 0.0) {

	                                if (nounit) {
	                                    B[k][j] = B[k][j] / A[k][k];
	                                }

	                                for (i = k + 1; i < m; i++) {
	                                    B[i][j] = B[i][j] - (B[k][j] * A[i][k]);
	                                }
	                            } // if (B[k][j] != 0.0)
	                        } // for (k = 0; k < m; k++)
	                    } // for (j = 0; j < n; j++)
	                } // else lower
	            } // if ((transa == 'N') || (transa == 'n')
	            else { // ((transa != 'N') && (transa != 'n'))

	                // Form B = alpha*inv(A')*B
	                if (upper) {

	                    for (j = 0; j < n; j++) {

	                        for (i = 0; i < m; i++) {
	                            temp = alpha * B[i][j];

	                            for (k = 0; k <= (i - 1); k++) {
	                                temp = temp - (A[k][i] * B[k][j]);
	                            }

	                            if (nounit) {
	                                temp = temp / A[i][i];
	                            }

	                            B[i][j] = temp;
	                        } // for (i = 0; i < m; i++)
	                    } // for (j = 0; j < n; j++)
	                } // if (upper)
	                else { // lower

	                    for (j = 0; j < n; j++) {

	                        for (i = m - 1; i >= 0; i--) {
	                            temp = alpha * B[i][j];

	                            for (k = i + 1; k < m; k++) {
	                                temp = temp - (A[k][i] * B[k][j]);
	                            }

	                            if (nounit) {
	                                temp = temp / A[i][i];
	                            }

	                            B[i][j] = temp;
	                        } // for (i = m-1; i >= 0; i--)
	                    } // for (j = 0; j < n; j++)
	                } // else lower
	            } // else ((transa != 'N') && (transa != 'n'))
	        } // if (lside)
	        else { // !lside

	            if ( (transa == 'N') || (transa == 'n')) {

	                // Form B = alpha*B*inv(A)
	                if (upper) {

	                    for (j = 0; j < n; j++) {

	                        if (alpha != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][j] = alpha * B[i][j];
	                            }
	                        } // if (alpha != 1.0)

	                        for (k = 0; k <= (j - 1); k++) {

	                            if (A[k][j] != 0.0) {

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] - (A[k][j] * B[i][k]);
	                                }
	                            } // if (A[k][j] != 0.0)
	                        } // for (k = 0; k <= j-1; k++)

	                        if (nounit) {
	                            temp = 1.0 / A[j][j];

	                            for (i = 0; i < m; i++) {
	                                B[i][j] = temp * B[i][j];
	                            }
	                        } // if (nounit)
	                    } // for (j = 0; j < n; j++)
	                } // if (upper)
	                else { // lower

	                    for (j = n - 1; j >= 0; j--) {

	                        if (alpha != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][j] = alpha * B[i][j];
	                            }
	                        } // if (alpha != 1.0)

	                        for (k = j + 1; k < n; k++) {

	                            if (A[k][j] != 0.0) {

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] - (A[k][j] * B[i][k]);
	                                }
	                            } // if (A[k][j] != 0.0)
	                        } // for (k = j+1; k < n; k++)

	                        if (nounit) {
	                            temp = 1.0 / A[j][j];

	                            for (i = 0; i < m; i++) {
	                                B[i][j] = temp * B[i][j];
	                            }
	                        } // if (nounit)
	                    } // for (j = n-1; j >= 0; j--)
	                } // else lower
	            } // if ((transa == 'N') || (transa == 'n')
	            else { // ((transa != 'N') && (transa != 'n'))

	                // Form B = alpha*B*inv(A')
	                if (upper) {

	                    for (k = n - 1; k >= 0; k--) {

	                        if (nounit) {
	                            temp = 1.0 / A[k][k];

	                            for (i = 0; i < m; i++) {
	                                B[i][k] = temp * B[i][k];
	                            }
	                        } // if (nounit)

	                        for (j = 0; j <= (k - 1); j++) {

	                            if (A[j][k] != 0.0) {
	                                temp = A[j][k];

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] - (temp * B[i][k]);
	                                }
	                            } // if (A[j][k] != 0.0)
	                        } // for (j = 0; j <= k-1; j++)

	                        if (alpha != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][k] = alpha * B[i][k];
	                            }
	                        } // if (alpha != 1.0)
	                    } // for (k = n-1; k >= 0; k--)
	                } // if (upper)
	                else { // lower

	                    for (k = 0; k < n; k++) {

	                        if (nounit) {
	                            temp = 1.0 / A[k][k];

	                            for (i = 0; i < m; i++) {
	                                B[i][k] = temp * B[i][k];
	                            }
	                        } // if (nounit)

	                        for (j = k + 1; j < n; j++) {

	                            if (A[j][k] != 0.0) {
	                                temp = A[j][k];

	                                for (i = 0; i < m; i++) {
	                                    B[i][j] = B[i][j] - (temp * B[i][k]);
	                                }
	                            } // if (A[j][k] != 0.0)
	                        } // for (j = k+1; j < n; j++)

	                        if (alpha != 1.0) {

	                            for (i = 0; i < m; i++) {
	                                B[i][k] = alpha * B[i][k];
	                            }
	                        } // if (alpha != 1.0)
	                    } // for (k = 0; k < n; k++)
	                } // else lower
	            } // else ((transa != 'N') && (transa != 'n'))
	        } // else !lside

	        return;
	    } // dtrsm

	    /**
	     * This is a port of the 10/22/86 Blas routine DTRSV Original version written by: Jack Dongarra, Argonne National
	     * Lab. Jeremy Du Croz, Nag Central Office Sven Hammarling, Nag Central Office. Richard Hanson, Sandia National
	     * Labs. dtrsv solves one of the systems of equations A*x = b or A'*x = b where b and x are n element vectors and A
	     * is an n by n unit, or non-unit, upper or lower triangular matrix.
	     * 
	     * <p>
	     * No test for singularity or near-singularity is included in this routine. Such test must be performed before
	     * calling this routine.
	     * </p>
	     * 
	     * @param uplo input char On entry, uplo specifies whether the matrix is an upper or lower triangular matrix as
	     *            follows = 'U' or 'u' A is an upper triangular matrix. = 'L' or 'l' A is a lower triangular matrix.
	     * @param trans input char On entry, trans specifies the equations to be solved as follows: = 'N' or 'n' A*x = b =
	     *            'T' or 't' A'*x = b = 'C' or 'c' A'*x = b
	     * @param diag input char On entry, diag specifies whether or not A is unit triangular as follows: = 'U' or 'u' A is
	     *            assumed to be unit triangular. = 'N' or 'n' A is not assumed to be unit triangular.
	     * @param n input int On entry, n specifies the order of matrix A. n must be at least zero.
	     * @param A input double[][] of dimension lda by n Before entry with uplo = 'U' or 'u', the leading n by n upper
	     *            triangular part of the array A must contain the upper triangular matrix and the strictly lower
	     *            triangular part of A is not referenced. Before entry with uplo = 'L' or 'l', the leading n by n lower
	     *            triangular part of the array A must contain the lower triangular matrix and the strictly upper
	     *            triangular part of A is not referenced. Note that when diag = 'U' or 'u', the diagonal elements of A
	     *            are not referenced either, but are assumed to be unity.
	     * @param lda input int On entry, lda specifies the first dimension of A as declared in the calling (sub) program.
	     *            lda must be at least max(1,n).
	     * @param x input/output double[] of dimension at least (1 + (n-1)*abs(incx)). Before entry, the incremented array x
	     *            must contain the n element right-hand side vector b. On exit, array x is overwritten with the solution
	     *            vector x.
	     * @param incx input int On entry, incx specifies the increment for the elements of x. incx must not be zero.
	     */
	    private void dtrsv(final char uplo, final char trans, final char diag, final int n, final double[][] A,
	            final int lda, final double[] x, final int incx) {
	        double temp;
	        int i;
	        int info;
	        int ix;
	        int j;
	        int jx;
	        int kx = 1;
	        boolean nounit;

	        // Test the input parameters
	        info = 0;

	        if ( (uplo != 'U') && (uplo != 'u') && (uplo != 'L') && (uplo != 'l')) {
	            info = 1;
	        } else if ( (trans != 'N') && (trans != 'n') && (trans != 'T') && (trans != 't') && (trans != 'C')
	                && (trans != 'c')) {
	            info = 2;
	        } else if ( (diag != 'U') && (diag != 'u') && (diag != 'N') && (diag != 'n')) {
	            info = 3;
	        } else if (n < 0) {
	            info = 4;
	        } else if (lda < Math.max(1, n)) {
	            info = 6;
	        } else if (incx == 0) {
	            info = 8;
	        }

	        if (info != 0) {
	            System.err.println("Error dtrsv had info = " + info);

	            return;
	        }

	        // Quick return if possible
	        if (n == 0) {
	            return;
	        }

	        if ( (diag == 'N') || (diag == 'n')) {
	            nounit = true;
	        } else {
	            nounit = false;
	        }

	        // Set up the start point in x if the increment is not unity. This will
	        // be (n-1)*incx too small for descending loops.

	        if (incx <= 0) {
	            kx = 1 - ( (n - 1) * incx);
	        } else if (incx != 1) {
	            kx = 1;
	        }

	        // Start the operations. In this version the elements of A are accessed
	        // sequentially with one pass through A.

	        if ( (trans == 'N') || (trans == 'n')) {

	            // Form x = inv(A)*x
	            if ( (uplo == 'U') || (uplo == 'u')) {

	                if (incx == 1) {

	                    for (j = n - 1; j >= 0; j--) {

	                        if (x[j] != 0.0) {

	                            if (nounit) {
	                                x[j] = x[j] / A[j][j];
	                            }

	                            temp = x[j];

	                            for (i = j - 1; i >= 0; i--) {
	                                x[i] = x[i] - (temp * A[i][j]);
	                            }
	                        } // if (x[j] != 0.0)
	                    } // for (j = n-1; j >= 0; j--)
	                } // if (incx == 1)
	                else { // incx != 1
	                    jx = kx + ( (n - 1) * incx) - 1;

	                    for (j = n - 1; j >= 0; j--) {

	                        if (x[jx] != 0.0) {

	                            if (nounit) {
	                                x[jx] = x[jx] / A[j][j];
	                            }

	                            temp = x[jx];
	                            ix = jx;

	                            for (i = j - 1; i >= 0; i--) {
	                                ix = ix - incx;
	                                x[ix] = x[ix] - (temp * A[i][j]);
	                            }
	                        } // if (x[jx] != 0.0)

	                        jx = jx - incx;
	                    } // for (j = n-1; j >= 0; j--)
	                } // else incx != 1
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                if (incx == 1) {

	                    for (j = 0; j < n; j++) {

	                        if (x[j] != 0.0) {

	                            if (nounit) {
	                                x[j] = x[j] / A[j][j];
	                            }

	                            temp = x[j];

	                            for (i = j + 1; i < n; i++) {
	                                x[i] = x[i] - (temp * A[i][j]);
	                            }
	                        } // if (x[j] != 0.0)
	                    } // for (j = 0; j < n; j++)
	                } // if (incx == 1)
	                else { // incx != 1
	                    jx = kx - 1;

	                    for (j = 0; j < n; j++) {

	                        if (x[jx] != 0.0) {

	                            if (nounit) {
	                                x[jx] = x[jx] / A[j][j];
	                            }

	                            temp = x[jx];
	                            ix = jx;

	                            for (i = j + 1; i < n; i++) {
	                                ix = ix + incx;
	                                x[ix] = x[ix] - (temp * A[i][j]);
	                            } // for (i = j+1; i < n; i++)
	                        } // if (x[jx] != 0.0)

	                        jx = jx + incx;
	                    } // for (j = 0; j < n; j++)
	                } // else incx != 1
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // if ((trans == 'N') || (trans == 'n'))
	        else { // ((trans != 'N') && (trans != 'n'))

	            // Form x = inv(A')*x.
	            if ( (uplo == 'U') || (uplo == 'u')) {

	                if (incx == 1) {

	                    for (j = 0; j < n; j++) {
	                        temp = x[j];

	                        for (i = 0; i <= (j - 1); i++) {
	                            temp = temp - (A[i][j] * x[i]);
	                        }

	                        if (nounit) {
	                            temp = temp / A[j][j];
	                        }

	                        x[j] = temp;
	                    } // for (j = 0; j < n; j++)
	                } // if (incx == 1)
	                else { // incx != 1
	                    jx = kx - 1;

	                    for (j = 0; j < n; j++) {
	                        temp = x[jx];
	                        ix = kx - 1;

	                        for (i = 0; i <= (j - 1); i++) {
	                            temp = temp - (A[i][j] * x[ix]);
	                            ix = ix + incx;
	                        } // for (i = 0; i <= j-1; i++)

	                        if (nounit) {
	                            temp = temp / A[j][j];
	                        }

	                        x[jx] = temp;
	                        jx = jx + incx;
	                    } // for (j = 0; j < n; j++)
	                } // else incx != 1
	            } // if ((uplo == 'U') || (uplo == 'u'))
	            else { // ((uplo == 'L') || (uplo == 'l'))

	                if (incx == 1) {

	                    for (j = n - 1; j >= 0; j--) {
	                        temp = x[j];

	                        for (i = n - 1; i >= (j + 1); i--) {
	                            temp = temp - (A[i][j] * x[i]);
	                        }

	                        if (nounit) {
	                            temp = temp / A[j][j];
	                        }

	                        x[j] = temp;
	                    } // for (j = n-1; j >= 0; j--)
	                } // if (incx == 1)
	                else { // incx != 1
	                    kx = kx + ( (n - 1) * incx);
	                    jx = kx - 1;

	                    for (j = n - 1; j >= 0; j--) {
	                        temp = x[jx];
	                        ix = kx - 1;

	                        for (i = n - 1; i >= (j + 1); i--) {
	                            temp = temp - (A[i][j] * x[ix]);
	                            ix = ix - incx;
	                        } // for (i = n-1; i >= j+1; i--)

	                        if (nounit) {
	                            temp = temp / A[j][j];
	                        }

	                        x[jx] = temp;
	                        jx = jx - incx;
	                    } // for (j = n-1; j >= 0; j--)
	                } // else incx != 1
	            } // else ((uplo == 'L') || (uplo == 'l'))
	        } // else ((trans != 'N') && (trans != 'n'))

	        return;
	    }

	    /**
	     * Version 3.2 auxiliary routine ported form LAPACK Original IEEECK created by Univ. of Tennessee, Univ. of
	     * California Berkeley, University of Colorado Denver, and NAG Ltd., November, 2006 ieeeck is called form the ilaenv
	     * routine to verify that infinity and possibly NaN arithmetic is safe (i.e. will not trap)
	     * 
	     * @param ispec input int Specifies whether to test just for infinity arithmetic or whether to test for infinity and
	     *            NaN arithmetic = 0: Verify infinity arithmetic only. = 1: Verify infinity and NaN aritmetic
	     * @param zero input double Must contain the value 0.0. This is passed to prevent the compiler from optimizing away
	     *            this code
	     * @param one input double Must contain the value 1.0. This is passed to prevent the compiler from optimizing away
	     *            this code.
	     * 
	     * @return int = 0: Arithmetic failed to produce the correct answers = 1: Arithmetic produced the correct answers
	     */
	    private int ieeeck(final int ispec, final double zero, final double one) {
	        double posinf;
	        double neginf;
	        double negzro;
	        double newzro;
	        double nan1;
	        double nan2;
	        double nan3;
	        double nan4;
	        double nan5;
	        double nan6;

	        posinf = one / zero;

	        if (posinf <= one) {
	            return 0;
	        }

	        neginf = -one / zero;

	        if (neginf >= zero) {
	            return 0;
	        }

	        negzro = one / (neginf + one);

	        if (negzro != zero) {
	            return 0;
	        }

	        neginf = one / negzro;

	        if (neginf >= zero) {
	            return 0;
	        }

	        newzro = negzro + zero;

	        if (newzro != zero) {
	            return 0;
	        }

	        posinf = one / newzro;

	        if (posinf <= one) {
	            return 0;
	        }

	        neginf = neginf * posinf;

	        if (neginf >= zero) {
	            return 0;
	        }

	        posinf = posinf * posinf;

	        if (posinf <= one) {
	            return 0;
	        }

	        // Return if we were only asked to check infinity arithmetic
	        if (ispec == 0) {
	            return 1;
	        }

	        nan1 = posinf + neginf;

	        nan2 = posinf / neginf;

	        nan3 = posinf / posinf;

	        nan4 = posinf * zero;

	        nan5 = neginf * negzro;

	        nan6 = nan5 * 0.0;
	        
	        // These 6 following if statements generate warnings, but they are used in the original
	        // IEEECK LAPACK routine.

	        if (nan1 == nan1) {
	            return 0;
	        }

	        if (nan2 == nan2) {
	            return 0;
	        }

	        if (nan3 == nan3) {
	            return 0;
	        }

	        if (nan4 == nan4) {
	            return 0;
	        }

	        if (nan5 == nan5) {
	            return 0;
	        }

	        if (nan6 == nan6) {
	            return 0;
	        }

	        return 1;
	    } // ieeeck

	    /**
	     * ilaenv is ported from the version 3.2.1 LAPACK auxiliary routine Original ILAENV created by Univ. of Tennessee,
	     * Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd., April, 2009
	     * 
	     * <p>
	     * ilaenv is called from the LAPACK routines to choose problem-dependent parameters for the local environment. See
	     * ispec for a description of the parameters.
	     * </p>
	     * 
	     * <p>
	     * This version provides a set of parameters which should give good, but not optimal, performance on many of the
	     * currently available computers. Users are encouraged to modify this subroutine to set the tuning parameters for
	     * their particular machine using the option and problem size information in the arguments.
	     * </p>
	     * 
	     * <p>
	     * This routine will not function correctly if it is converted to all lower case. Converting it to all upper case is
	     * allowed.
	     * </p>
	     * 
	     * @param ispec input integer Specifies the parameter to be returned as the value of ilaenv. = 1: the optimal
	     *            blocksize; if this value is 1, an unblocked algorithm will give the best performance. = 2: the minimum
	     *            block size for which the block routine should be used; if the usable block size is less than this
	     *            value, an unblocked routine should be used = 3: the crossover point ( in a block routine, for n less
	     *            than this value, an unblocked routine should be used) = 4: the number of shifts, used in the
	     *            nonsymmetric eigenvalue routines (deprecated) = 5: the minimum column dimension for blocking to be
	     *            used; rectangular blocks must have dimension at least k by m, where k is given by ilaenv(2,...) and m
	     *            by ilaenv(5,...) = 6: the crossover point for the SVD (when reducing an m by n matrix to bidiagonal
	     *            form, if max(m,n)/min(m,n) exceeds this value, a QR factorization is used first to reduce the matrix
	     *            to a triangular form.) = 7: the number of processors = 8: the crossover point for the multishift QR
	     *            method for nonsymmetric eigenvalue problems (deprecated) = 9: maximum size of the subproblems at the
	     *            bottom of the computation tree in the divide-and-conquer algorithm (used by xgelsd and xgesdd) = 10:
	     *            ieee NaN arithmetic can be trusted not to trap = 11: infinity can be trusted not to trap 12 <= ispec
	     *            <= 16: xhseqr or one of its subroutines see iparmq for detailed explanation
	     * @param name input String The name of the calling subroutine, in either upper case or lower case.
	     * @param opts input String The character options to the subroutine name, concatenated into a single character
	     *            string. For example, uplo = 'U', trans = 'T', and diag = 'N' for a triangular routine would be
	     *            specified as opts = 'UTN'. opts has all the character options to subroutine name, in the same order
	     *            that they appear in the argument list for name, even if they are not used in determining the value of
	     *            the parameter specified by ispec.
	     * @param n1 input integer
	     * @param n2 input integer
	     * @param n3 input integer
	     * @param n4 input integer n1 to n4 have problem dimensions for the subroutine name; these may not all be required.
	     *            The problem dimensions n1, n2, n3, and n4 are specified in the order that they appear in the argument
	     *            list for name. n1 is used first, n2 second, and so on, and unused problem dimensions are passed a
	     *            value of -1.
	     * 
	     * @return answer output integer >= 0; the value of the parameter specified by ispec < 0: il answer = -k, the k-th
	     *         parameter had an illegal value The parameter value returned by ilaenv is checked for validity in the
	     *         calling routine.
	     */
	    private int ilaenv(final int ispec, final String name, final String opts, final int n1, final int n2, final int n3,
	            final int n4) {
	        String subnam;
	        int answer;
	        char first;
	        String c1, c2, c3, c4;
	        boolean sname;
	        boolean cname;
	        int nb;
	        int nbmin;
	        int nx;

	        if ( (ispec < 1) || (ispec > 16)) {

	            // Invalid value for ispec
	            return -1;
	        }

	        if ( (ispec == 1) || (ispec == 2) || (ispec == 3)) {

	            // Copy name to subnam
	            // Make subnam upper case is the first character of name is lower case
	            subnam = new String(name);
	            first = name.charAt(0);

	            if (Character.isLowerCase(first)) {
	                subnam = subnam.toUpperCase();
	            }

	            c1 = subnam.substring(0, 1);

	            if ( (c1.equals("S")) || (c1.equals("D"))) {
	                sname = true;
	            } else {
	                sname = false;
	            }

	            if ( (c1.equals("C")) || (c1.equals("Z"))) {
	                cname = true;
	            } else {
	                cname = false;
	            }

	            if ( ! (cname || sname)) {
	                return 1;
	            }

	            c2 = subnam.substring(1, 3);
	            c3 = subnam.substring(3, 6);
	            c4 = c3.substring(1, 3);

	            if (ispec == 1) {

	                // block size
	                // In these examples, separate code is provided for setting nb for
	                // real and complex. We assume that nb will take the same value in
	                // single or double precision.
	                nb = 1;

	                if (c2.equals("GE")) {

	                    if (c3.equals("TRF")) {
	                        nb = 64;
	                    } // if (c3.equals("TRF"))
	                    else if ( (c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) || (c3.equals("QLF"))) {
	                        nb = 32;
	                    } // else if ((c3.equals("QRF")) || (c3.equals("RQF")) ||
	                    else if (c3.equals("HRD")) {
	                        nb = 32;
	                    } // else if (c3.equals("HRD"))
	                    else if (c3.equals("BRD")) {
	                        nb = 32;
	                    } // else if (c3.equals("BRD"))
	                    else if (c3.equals("TRI")) {
	                        nb = 64;
	                    } // else if (c3.equals("TRI"))
	                } // if (c2.equals("GE"))
	                else if (c2.equals("PO")) {

	                    if (c3.equals("TRF")) {
	                        nb = 64;
	                    } // if (c3.equals("TRF"))
	                } // else if (c2.equals("PO"))
	                else if (c2.equals("SY")) {

	                    if (c3.equals("TRF")) {
	                        nb = 64;
	                    } // if (c3.equals("TRF"))
	                    else if (sname && (c3.equals("TRD"))) {
	                        nb = 32;
	                    } // else if (sname && (c3.equals("TRD")))
	                    else if (sname && (c3.equals("GST"))) {
	                        nb = 64;
	                    } // else if (sname && (c3.equals("GST")))
	                } // else if (c2.equals("SY"))
	                else if (cname && (c2.equals("HE"))) {

	                    if (c3.equals("TRF")) {
	                        nb = 64;
	                    } // if (c3.equals("TRF"))
	                    else if (c3.equals("TRD")) {
	                        nb = 32;
	                    } // else if (c3.equals("TRD"))
	                    else if (c3.equals("GST")) {
	                        nb = 64;
	                    } // else if (c3.equals("GST"))
	                } // else if (cname && (c2.equals("HE")))
	                else if (sname && (c2.equals("OR"))) {

	                    if ( (c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

	                        if ( (c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL"))
	                                || (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
	                            nb = 32;
	                        }
	                    } // if (c3.substring(0,1).equals("G")) ||
	                } // else if (sname && (c2.equals("OR")))
	                else if (cname && (c2.equals("UN"))) {

	                    if ( (c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

	                        if ( (c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL"))
	                                || (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
	                            nb = 32;
	                        }
	                    } // if (c3.substring(0,1).equals("G")) ||
	                } // else if (cname && (c2.equals("UN")))
	                else if (c2.equals("GB")) {

	                    if (c3.equals("TRF")) {

	                        if (n4 <= 64) {
	                            nb = 1;
	                        } else {
	                            nb = 32;
	                        }
	                    } // if (c3.equals("TRF"))
	                } // else if (c2.equals("GB"))
	                else if (c2.equals("PB")) {

	                    if (c3.equals("TRF")) {

	                        if (n2 <= 64) {
	                            nb = 1;
	                        } else {
	                            nb = 32;
	                        }
	                    } // if (c3.equals("TRF"))
	                } // else if (c2.equals("PB"))
	                else if (c2.equals("TR")) {

	                    if (c3.equals("TRI")) {
	                        nb = 64;
	                    } // if (c3.equals("TRI"))
	                } // else if (C2.equals("TR"))
	                else if (c2.equals("LA")) {

	                    if (c3.equals("UUM")) {
	                        nb = 64;
	                    } // if (c3.equals("UUM"))
	                } // else if (c2.equals("LA"))
	                else if (sname && (c2.equals("ST"))) {

	                    if (c3.equals("EBZ")) {
	                        nb = 1;
	                    } // if (c3.equals("EBZ"))
	                } // else if (sname && (c2.equals("ST")))

	                return nb;
	            } // if (ispec == 1)
	            else if (ispec == 2) {
	                // minimum block size

	                nbmin = 2;

	                if (c2.equals("GE")) {

	                    if ( (c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) || (c3.equals("QLF"))
	                            || (c3.equals("HRD")) || (c3.equals("BRD")) || (c3.equals("TRI"))) {
	                        nbmin = 2;
	                    } // if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) ||
	                } // if (c2.equals("GE"))
	                else if (c2.equals("SY")) {

	                    if (c3.equals("TRF")) {
	                        nbmin = 8;
	                    } // if (c3.equals("TRF"))
	                    else if (sname && (c3.equals("TRD"))) {
	                        nbmin = 2;
	                    } // else if (sname && (c3.equals("TRD")))
	                } // else if (c2.equals("SY"))
	                else if (cname && (c2.equals("HE"))) {

	                    if (c3.equals("TRD")) {
	                        nbmin = 2;
	                    } // if (c3.equals("TRD"))
	                } // else if (cname && (c2.equals("HE")))
	                else if (sname && (c2.equals("OR"))) {

	                    if ( (c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

	                        if ( (c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL"))
	                                || (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
	                            nbmin = 2;
	                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
	                    } // if ((c3.substring(0,1).equals("G")) ||
	                } // else if (sname && (c2.equals("OR")))
	                else if (cname && (c2.equals("UN"))) {

	                    if ( (c3.substring(0, 1).equals("G")) || (c3.substring(0, 1).equals("M"))) {

	                        if ( (c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL"))
	                                || (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
	                            nbmin = 2;
	                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
	                    } // if ((c3.substring(0,1).equals("G")) ||
	                } // else if (cname && (c2.equals("UN")))

	                return nbmin;
	            } // else if (ispec == 2)
	            else { // ispec == 3

	                // crossover point

	                nx = 0;

	                if (c2.equals("GE")) {

	                    if ( (c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) || (c3.equals("QLF"))
	                            || (c3.equals("HRD")) || (c3.equals("BRD"))) {
	                        nx = 128;
	                    } // if ((c3.equals("QRF")) || (c3.equals("RQF")) || (c3.equals("LQF")) ||
	                } // if (c2.equals("GE"))
	                else if (c2.equals("SY")) {

	                    if (sname && (c3.equals("TRD"))) {
	                        nx = 32;
	                    } // if (sname && (c3.equals("TRD")))
	                } // else if (c2.equals("SY"))
	                else if (cname && (c2.equals("HE"))) {

	                    if (c3.equals("TRD")) {
	                        nx = 32;
	                    } // if (c3.equals("TRD"))
	                } // else if (cname && (c2.equals("HE")))
	                else if (sname && (c2.equals("OR"))) {

	                    if (c3.substring(0, 1).equals("G")) {

	                        if ( (c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL"))
	                                || (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
	                            nx = 128;
	                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
	                    } // if (c3.substring(0,1).equals("G"))
	                } // else if (sname && (c2.equals("OR")))
	                else if (cname && (c2.equals("UN"))) {

	                    if (c3.substring(0, 1).equals("G")) {

	                        if ( (c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) || (c4.equals("QL"))
	                                || (c4.equals("HR")) || (c4.equals("TR")) || (c4.equals("BR"))) {
	                            nx = 128;
	                        } // if ((c4.equals("QR")) || (c4.equals("RQ")) || (c4.equals("LQ")) ||
	                    } // if (c3.substring(0,1).equals("G"))
	                } // else if (cname && (c2.equals("UN")))

	                return nx;
	            } // else ispec == 3
	        } // if ((ispec == 1) || (ispec == 2) || (ispec == 3))
	        else if (ispec == 4) {

	            // number of shifts (used by xhseqr)
	            return 6;
	        } // else if (ispec == 4)
	        else if (ispec == 5) {

	            // minimum column dimension (not used)
	            return 2;
	        } // else if (ispec == 5)
	        else if (ispec == 6) {

	            // crossover point for SVD (used by xgelss and xgesvd)
	            return (int) (1.6 * Math.min(n1, n2));
	        } // else if (ispec == 6)
	        else if (ispec == 7) {

	            // number of processors (not used)
	            return 1;
	        } // else if (ispec == 7)
	        else if (ispec == 8) {

	            // crossover point for multishift (used by xhseqr)
	            return 50;
	        } // else if (ispec == 8)
	        else if (ispec == 9) {

	            // maximum size of the subproblems at the bottom of the computation
	            // tree in divide-and-conquer algorithm (used by xgelsd and xgesdd)
	            return 25;
	        } // else if (ispec == 9)
	        else if (ispec == 10) {

	            // ieee NaN arithmetic can be trusted not to trap
	            answer = ieeeck(1, 0.0, 1.0);

	            return answer;
	        } // else if (ispec == 10)
	        else if (ispec == 11) {

	            // infinity arithmetic can be trusted not to trap
	            answer = ieeeck(0, 0.0, 1.0);

	            return answer;
	        } // else ispec == 11
	        else { // 12 <= ispec <= 16
	            // answer = iparmq(ispec, name, opts, n1, n2, n3, n4);

	            return -1;
	        }
	    } // ilaenv

	    /**
	     * This is a port of version 3.1 LAPACK auxiliary routine XLAENV. Univ. of Tennessee, Univ. of California Berkeley
	     * and NAG Ltd.. November 2006
	     * 
	     * .. Scalar Arguments .. INTEGER ISPEC, NVALUE ..
	     * 
	     * Purpose =======
	     * 
	     * XLAENV sets certain machine- and problem-dependent quantities which will later be retrieved by ILAENV.
	     * 
	     * Arguments =========
	     * 
	     * ISPEC (input) INTEGER Specifies the parameter to be set in the COMMON array IPARMS. = 1: the optimal blocksize;
	     * if this value is 1, an unblocked algorithm will give the best performance. = 2: the minimum block size for which
	     * the block routine should be used; if the usable block size is less than this value, an unblocked routine should
	     * be used. = 3: the crossover point (in a block routine, for N less than this value, an unblocked routine should be
	     * used) = 4: the number of shifts, used in the nonsymmetric eigenvalue routines = 5: the minimum column dimension
	     * for blocking to be used; rectangular blocks must have dimension at least k by m, where k is given by
	     * ILAENV(2,...) and m by ILAENV(5,...) = 6: the crossover point for the SVD (when reducing an m by n matrix to
	     * bidiagonal form, if max(m,n)/min(m,n) exceeds this value, a QR factorization is used first to reduce the matrix
	     * to a triangular form) = 7: the number of processors = 8: another crossover point, for the multishift QR and QZ
	     * methods for nonsymmetric eigenvalue problems. = 9: maximum size of the subproblems at the bottom of the
	     * computation tree in the divide-and-conquer algorithm (used by xGELSD and xGESDD) =10: ieee NaN arithmetic can be
	     * trusted not to trap =11: infinity arithmetic can be trusted not to trap
	     * 
	     * NVALUE (input) INTEGER The value of the parameter specified by ISPEC.
	     */
	    private void xlaenv(final int ispec, final int nvalue) {
	        if ( (ispec >= 1) && (ispec <= 9)) {
	            iparms[ispec - 1] = nvalue;
	        }
	        return;
	    } // xlaenv

	}
