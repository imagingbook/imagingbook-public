<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: module: imagingbook.common, package: imagingbook.common.sift, class: SiftDetector, enum: NeighborhoodType3D">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*******************************************************************************</span>
<span class="source-line-no">002</span><span id="line-2"> * This software is provided as a supplement to the authors' textbooks on digital</span>
<span class="source-line-no">003</span><span id="line-3"> * image processing published by Springer-Verlag in various languages and editions.</span>
<span class="source-line-no">004</span><span id="line-4"> * Permission to use and distribute this software is granted under the BSD 2-Clause</span>
<span class="source-line-no">005</span><span id="line-5"> * "Simplified" License (see http://opensource.org/licenses/BSD-2-Clause).</span>
<span class="source-line-no">006</span><span id="line-6"> * Copyright (c) 2006-2022 Wilhelm Burger, Mark J. Burge. All rights reserved.</span>
<span class="source-line-no">007</span><span id="line-7"> * Visit https://imagingbook.com for additional details.</span>
<span class="source-line-no">008</span><span id="line-8"> ******************************************************************************/</span>
<span class="source-line-no">009</span><span id="line-9"></span>
<span class="source-line-no">010</span><span id="line-10">package imagingbook.common.sift;</span>
<span class="source-line-no">011</span><span id="line-11"></span>
<span class="source-line-no">012</span><span id="line-12">import ij.process.FloatProcessor;</span>
<span class="source-line-no">013</span><span id="line-13">import imagingbook.common.math.Arithmetic;</span>
<span class="source-line-no">014</span><span id="line-14">import imagingbook.common.math.Matrix;</span>
<span class="source-line-no">015</span><span id="line-15">import imagingbook.common.sift.scalespace.DogOctave;</span>
<span class="source-line-no">016</span><span id="line-16">import imagingbook.common.sift.scalespace.DogScaleSpace;</span>
<span class="source-line-no">017</span><span id="line-17">import imagingbook.common.sift.scalespace.GaussianScaleSpace;</span>
<span class="source-line-no">018</span><span id="line-18">import imagingbook.common.sift.scalespace.ScaleLevel;</span>
<span class="source-line-no">019</span><span id="line-19"></span>
<span class="source-line-no">020</span><span id="line-20">import java.util.ArrayList;</span>
<span class="source-line-no">021</span><span id="line-21">import java.util.Collections;</span>
<span class="source-line-no">022</span><span id="line-22">import java.util.List;</span>
<span class="source-line-no">023</span><span id="line-23"></span>
<span class="source-line-no">024</span><span id="line-24">import static imagingbook.common.math.Arithmetic.mod;</span>
<span class="source-line-no">025</span><span id="line-25">import static imagingbook.common.math.Arithmetic.sqr;</span>
<span class="source-line-no">026</span><span id="line-26"></span>
<span class="source-line-no">027</span><span id="line-27">/**</span>
<span class="source-line-no">028</span><span id="line-28"> * &lt;p&gt;</span>
<span class="source-line-no">029</span><span id="line-29"> * This class implements the detection of SIFT features from images, as described in [1]. See Ch. 25 of [2] for more</span>
<span class="source-line-no">030</span><span id="line-30"> * details.</span>
<span class="source-line-no">031</span><span id="line-31"> * &lt;/p&gt;</span>
<span class="source-line-no">032</span><span id="line-32"> * &lt;p&gt;</span>
<span class="source-line-no">033</span><span id="line-33"> * Currently only images of type {@link FloatProcessor} are supported. The input image is normalized to values in [0,1]</span>
<span class="source-line-no">034</span><span id="line-34"> * before SIFT detection starts. A large set of parameters can be specified (see {@link SiftParameters}).</span>
<span class="source-line-no">035</span><span id="line-35"> * &lt;/p&gt;</span>
<span class="source-line-no">036</span><span id="line-36"> * &lt;p&gt;</span>
<span class="source-line-no">037</span><span id="line-37"> * [1] D. G. Lowe. Distinctive image features from scale-invariant keypoints. International Journal of Computer Vision</span>
<span class="source-line-no">038</span><span id="line-38"> * 60, 91â€“110 (2004). &lt;br&gt; [2] W. Burger, M.J. Burge, &lt;em&gt;Digital Image Processing &amp;ndash; An Algorithmic</span>
<span class="source-line-no">039</span><span id="line-39"> * Introduction&lt;/em&gt;, 3rd ed, Springer (2022).</span>
<span class="source-line-no">040</span><span id="line-40"> * &lt;/p&gt;</span>
<span class="source-line-no">041</span><span id="line-41"> *</span>
<span class="source-line-no">042</span><span id="line-42"> * @author WB</span>
<span class="source-line-no">043</span><span id="line-43"> * @version 2022/11/20</span>
<span class="source-line-no">044</span><span id="line-44"> * @see SiftParameters</span>
<span class="source-line-no">045</span><span id="line-45"> */</span>
<span class="source-line-no">046</span><span id="line-46">public class SiftDetector {</span>
<span class="source-line-no">047</span><span id="line-47">        </span>
<span class="source-line-no">048</span><span id="line-48">        /**</span>
<span class="source-line-no">049</span><span id="line-49">         * Types of 3D neighborhoods used in min/max detection </span>
<span class="source-line-no">050</span><span id="line-50">         */</span>
<span class="source-line-no">051</span><span id="line-51">        public enum NeighborhoodType3D {</span>
<span class="source-line-no">052</span><span id="line-52">                NH8(8), NH10(10), NH18(18), NH26(26);</span>
<span class="source-line-no">053</span><span id="line-53">                private final int size;</span>
<span class="source-line-no">054</span><span id="line-54">                private NeighborhoodType3D(int size) {</span>
<span class="source-line-no">055</span><span id="line-55">                        this.size = size;</span>
<span class="source-line-no">056</span><span id="line-56">                }</span>
<span class="source-line-no">057</span><span id="line-57">        }</span>
<span class="source-line-no">058</span><span id="line-58"></span>
<span class="source-line-no">059</span><span id="line-59">        static private final double PI2 = 2 * Math.PI;</span>
<span class="source-line-no">060</span><span id="line-60">        </span>
<span class="source-line-no">061</span><span id="line-61">        private final SiftParameters params;</span>
<span class="source-line-no">062</span><span id="line-62">        private final int nhSize;</span>
<span class="source-line-no">063</span><span id="line-63">        private final GaussianScaleSpace G;</span>
<span class="source-line-no">064</span><span id="line-64">        private final DogScaleSpace D;</span>
<span class="source-line-no">065</span><span id="line-65"></span>
<span class="source-line-no">066</span><span id="line-66">        // Constructors ------------------------------------ </span>
<span class="source-line-no">067</span><span id="line-67"></span>
<span class="source-line-no">068</span><span id="line-68">        /**</span>
<span class="source-line-no">069</span><span id="line-69">         * Constructor using default parameters.</span>
<span class="source-line-no">070</span><span id="line-70">         * @param fp the input image</span>
<span class="source-line-no">071</span><span id="line-71">         * @see #SiftDetector(FloatProcessor, SiftParameters)</span>
<span class="source-line-no">072</span><span id="line-72">         */</span>
<span class="source-line-no">073</span><span id="line-73">        public SiftDetector(FloatProcessor fp) {</span>
<span class="source-line-no">074</span><span id="line-74">                this(fp, new SiftParameters()); // uses default parameters</span>
<span class="source-line-no">075</span><span id="line-75">        }</span>
<span class="source-line-no">076</span><span id="line-76"></span>
<span class="source-line-no">077</span><span id="line-77">        /**</span>
<span class="source-line-no">078</span><span id="line-78">         * &lt;p&gt;</span>
<span class="source-line-no">079</span><span id="line-79">         * Constructor using specific parameters. The input image is normalized to values in [0,1], the minimum pixel value</span>
<span class="source-line-no">080</span><span id="line-80">         * being mapped to 0 and the maximum value to 1. An exception is thrown if the supplied image is "flat", i.e.,</span>
<span class="source-line-no">081</span><span id="line-81">         * contains only a single pixel value. A large set of parameters can be specified (see {@link SiftParameters}). The</span>
<span class="source-line-no">082</span><span id="line-82">         * constructor sets up the complete Gaussian and DoG scale spaces but does not perform feature detection itself,</span>
<span class="source-line-no">083</span><span id="line-83">         * which is done by calling {@link #getSiftFeatures()}.</span>
<span class="source-line-no">084</span><span id="line-84">         * &lt;/p&gt;</span>
<span class="source-line-no">085</span><span id="line-85">         *</span>
<span class="source-line-no">086</span><span id="line-86">         * @param fp the input image</span>
<span class="source-line-no">087</span><span id="line-87">         * @param params an instance of {@link SiftParameters}</span>
<span class="source-line-no">088</span><span id="line-88">         * @see SiftParameters</span>
<span class="source-line-no">089</span><span id="line-89">         */</span>
<span class="source-line-no">090</span><span id="line-90">        public SiftDetector(FloatProcessor fp, SiftParameters params) {</span>
<span class="source-line-no">091</span><span id="line-91">                this.params = params;</span>
<span class="source-line-no">092</span><span id="line-92">                this.nhSize = params.nhType.size;</span>
<span class="source-line-no">093</span><span id="line-93">                if (!normalizeTo01(fp))</span>
<span class="source-line-no">094</span><span id="line-94">                        throw new IllegalArgumentException("could not normalize input image");</span>
<span class="source-line-no">095</span><span id="line-95">                this.G = new GaussianScaleSpace(fp, params.P, params.Q, params.sigmaS, params.sigma0, -1, params.Q + 1);</span>
<span class="source-line-no">096</span><span id="line-96">                this.D = new DogScaleSpace(G);</span>
<span class="source-line-no">097</span><span id="line-97">        }</span>
<span class="source-line-no">098</span><span id="line-98">        </span>
<span class="source-line-no">099</span><span id="line-99">        private boolean normalizeTo01(FloatProcessor fp) {</span>
<span class="source-line-no">100</span><span id="line-100">                float[] a = (float[])fp.getPixels();</span>
<span class="source-line-no">101</span><span id="line-101">                float minVal = Matrix.min(a);</span>
<span class="source-line-no">102</span><span id="line-102">                float maxVal = Matrix.max(a);</span>
<span class="source-line-no">103</span><span id="line-103">                float diff = maxVal - minVal;</span>
<span class="source-line-no">104</span><span id="line-104">                if (Arithmetic.isZero(diff)) {</span>
<span class="source-line-no">105</span><span id="line-105">                        return false;   // only one pixel value</span>
<span class="source-line-no">106</span><span id="line-106">                }</span>
<span class="source-line-no">107</span><span id="line-107">                float scale = 1.0f / diff;</span>
<span class="source-line-no">108</span><span id="line-108">                for (int i = 0; i &lt; a.length; i++) {</span>
<span class="source-line-no">109</span><span id="line-109">                        a[i] = (a[i] - minVal) * scale; </span>
<span class="source-line-no">110</span><span id="line-110">                }</span>
<span class="source-line-no">111</span><span id="line-111">                return true;</span>
<span class="source-line-no">112</span><span id="line-112">        }</span>
<span class="source-line-no">113</span><span id="line-113">        </span>
<span class="source-line-no">114</span><span id="line-114">        // --------------------------------------------------</span>
<span class="source-line-no">115</span><span id="line-115">        </span>
<span class="source-line-no">116</span><span id="line-116">        /**</span>
<span class="source-line-no">117</span><span id="line-117">         * Calculates and returns a list of SIFT descriptors.</span>
<span class="source-line-no">118</span><span id="line-118">         * </span>
<span class="source-line-no">119</span><span id="line-119">         * @return a list of extracted SIFT descriptors</span>
<span class="source-line-no">120</span><span id="line-120">         */</span>
<span class="source-line-no">121</span><span id="line-121">        public List&lt;SiftDescriptor&gt; getSiftFeatures() {</span>
<span class="source-line-no">122</span><span id="line-122">                List&lt;KeyPoint&gt; keyPoints = getKeyPoints();</span>
<span class="source-line-no">123</span><span id="line-123">                List&lt;SiftDescriptor&gt; siftDescriptors = new ArrayList&lt;SiftDescriptor&gt;();</span>
<span class="source-line-no">124</span><span id="line-124">                for (KeyPoint kp : keyPoints) {</span>
<span class="source-line-no">125</span><span id="line-125">                        for (double phi_d : getDominantOrientations(kp)) {</span>
<span class="source-line-no">126</span><span id="line-126">                                SiftDescriptor sd = makeSiftDescriptor(kp, phi_d);</span>
<span class="source-line-no">127</span><span id="line-127">                                if (sd != null) {</span>
<span class="source-line-no">128</span><span id="line-128">                                        siftDescriptors.add(sd);</span>
<span class="source-line-no">129</span><span id="line-129">                                }</span>
<span class="source-line-no">130</span><span id="line-130">                        }</span>
<span class="source-line-no">131</span><span id="line-131">                }</span>
<span class="source-line-no">132</span><span id="line-132">                return siftDescriptors;</span>
<span class="source-line-no">133</span><span id="line-133">        }</span>
<span class="source-line-no">134</span><span id="line-134"></span>
<span class="source-line-no">135</span><span id="line-135">        /**</span>
<span class="source-line-no">136</span><span id="line-136">         * Returns the {@link GaussianScaleSpace} for this SIFT detector instance. Mainly intended for debugging and</span>
<span class="source-line-no">137</span><span id="line-137">         * testing.</span>
<span class="source-line-no">138</span><span id="line-138">         *</span>
<span class="source-line-no">139</span><span id="line-139">         * @return the {@link GaussianScaleSpace} for this SIFT detector</span>
<span class="source-line-no">140</span><span id="line-140">         */</span>
<span class="source-line-no">141</span><span id="line-141">        public GaussianScaleSpace getGaussianScaleSpace() {</span>
<span class="source-line-no">142</span><span id="line-142">                return this.G;</span>
<span class="source-line-no">143</span><span id="line-143">        }</span>
<span class="source-line-no">144</span><span id="line-144"></span>
<span class="source-line-no">145</span><span id="line-145">        /**</span>
<span class="source-line-no">146</span><span id="line-146">         * Returns the {@link DogScaleSpace} for this SIFT detector instance. Mainly intended for debugging and testing.</span>
<span class="source-line-no">147</span><span id="line-147">         *</span>
<span class="source-line-no">148</span><span id="line-148">         * @return the {@link DogScaleSpace} for this SIFT detector</span>
<span class="source-line-no">149</span><span id="line-149">         */</span>
<span class="source-line-no">150</span><span id="line-150">        public DogScaleSpace getDogScaleSpace() {</span>
<span class="source-line-no">151</span><span id="line-151">                return this.D;</span>
<span class="source-line-no">152</span><span id="line-152">        }</span>
<span class="source-line-no">153</span><span id="line-153">        </span>
<span class="source-line-no">154</span><span id="line-154">        // --------------------------------------------------</span>
<span class="source-line-no">155</span><span id="line-155"></span>
<span class="source-line-no">156</span><span id="line-156">        /**</span>
<span class="source-line-no">157</span><span id="line-157">         * Only used for debugging: produces key points with orientation histograms attached for display purposes.</span>
<span class="source-line-no">158</span><span id="line-158">         *</span>
<span class="source-line-no">159</span><span id="line-159">         * @param keypoints the sequence of original key points</span>
<span class="source-line-no">160</span><span id="line-160">         * @return a sequence of enhanced key points</span>
<span class="source-line-no">161</span><span id="line-161">         */</span>
<span class="source-line-no">162</span><span id="line-162">        @SuppressWarnings("unused")</span>
<span class="source-line-no">163</span><span id="line-163">        private  List&lt;KeyPoint&gt; makeRichKeypoints(List&lt;KeyPoint&gt; keypoints) {</span>
<span class="source-line-no">164</span><span id="line-164">                List&lt;KeyPoint&gt; richKeyPoints = new ArrayList&lt;KeyPoint&gt;();</span>
<span class="source-line-no">165</span><span id="line-165">                for (KeyPoint kp : keypoints) {</span>
<span class="source-line-no">166</span><span id="line-166">                        float[] oh = getOrientationHistogram(kp);</span>
<span class="source-line-no">167</span><span id="line-167">                        smoothCircular(oh,params.nSmooth);</span>
<span class="source-line-no">168</span><span id="line-168">                        kp.orientation_histogram = oh;  // TODO: remove, for testing only!!</span>
<span class="source-line-no">169</span><span id="line-169">                        List&lt;Double&gt; peakOrientations = findPeakOrientationIndices(oh);</span>
<span class="source-line-no">170</span><span id="line-170">                        for (double km : peakOrientations) {</span>
<span class="source-line-no">171</span><span id="line-171">                                //for (int i=0; i&lt;Math.min(1, peakOrientations.length); i++) {  // use only 1 descriptor!</span>
<span class="source-line-no">172</span><span id="line-172">                                float phi = (float) (km * 2 * Math.PI / oh.length);     // 0 &lt;= phi &lt; 2 PI. Should be in range +/-PI?</span>
<span class="source-line-no">173</span><span id="line-173">                                KeyPoint rkp = kp.clone();</span>
<span class="source-line-no">174</span><span id="line-174">                                rkp.orientation = phi;</span>
<span class="source-line-no">175</span><span id="line-175">                                richKeyPoints.add(rkp);</span>
<span class="source-line-no">176</span><span id="line-176">                        }</span>
<span class="source-line-no">177</span><span id="line-177">                }</span>
<span class="source-line-no">178</span><span id="line-178">                return richKeyPoints;</span>
<span class="source-line-no">179</span><span id="line-179">        }</span>
<span class="source-line-no">180</span><span id="line-180"></span>
<span class="source-line-no">181</span><span id="line-181">        /**</span>
<span class="source-line-no">182</span><span id="line-182">         * Used for debugging/illustrations only!</span>
<span class="source-line-no">183</span><span id="line-183">         * </span>
<span class="source-line-no">184</span><span id="line-184">         * @param oh orientation histogram</span>
<span class="source-line-no">185</span><span id="line-185">         * @return list of histogram indices for the peak orientations</span>
<span class="source-line-no">186</span><span id="line-186">         */</span>
<span class="source-line-no">187</span><span id="line-187">        private List&lt;Double&gt; findPeakOrientationIndices(float[] oh) {</span>
<span class="source-line-no">188</span><span id="line-188">                int nb = oh.length;</span>
<span class="source-line-no">189</span><span id="line-189">                List&lt;Double&gt; orientIndexes = new ArrayList&lt;Double&gt;(nb);</span>
<span class="source-line-no">190</span><span id="line-190">                // find the maximum entry in the orientation histogram 'oh':</span>
<span class="source-line-no">191</span><span id="line-191">                float maxh = oh[0];</span>
<span class="source-line-no">192</span><span id="line-192">                for (int k = 1; k &lt; nb; k++) {</span>
<span class="source-line-no">193</span><span id="line-193">                        if (oh[k] &gt; maxh)</span>
<span class="source-line-no">194</span><span id="line-194">                                maxh = oh[k];</span>
<span class="source-line-no">195</span><span id="line-195">                }</span>
<span class="source-line-no">196</span><span id="line-196"></span>
<span class="source-line-no">197</span><span id="line-197">                if (maxh &gt; 0.01f) { // ascertain minimum (non-zero) gradient energy</span>
<span class="source-line-no">198</span><span id="line-198">                        // collect all peaks &gt; 80% of the maximum entry in 'oh'</span>
<span class="source-line-no">199</span><span id="line-199">                        float minh = maxh * (float) params.tDomOr;</span>
<span class="source-line-no">200</span><span id="line-200">                        for (int k = 0; k &lt; nb; k++) { // hp ~ hc ~ ha</span>
<span class="source-line-no">201</span><span id="line-201">                                // angles[k] = Float.NaN;</span>
<span class="source-line-no">202</span><span id="line-202">                                float hc = oh[k]; // center value</span>
<span class="source-line-no">203</span><span id="line-203">                                if (oh[k] &gt; minh) { // value is min. 80% of global peak</span>
<span class="source-line-no">204</span><span id="line-204">                                        float hp = oh[(k - 1 + nb) % nb]; // previous histogram</span>
<span class="source-line-no">205</span><span id="line-205">                                        // value</span>
<span class="source-line-no">206</span><span id="line-206">                                        float hn = oh[(k + 1) % nb]; // next histogram value</span>
<span class="source-line-no">207</span><span id="line-207">                                        if (hc &gt; hp &amp;&amp; hc &gt; hn) { // check if 'hc' is a local peak</span>
<span class="source-line-no">208</span><span id="line-208">                                                // interpolate orientation by a quadratic function (parabola):</span>
<span class="source-line-no">209</span><span id="line-209">                                                double delta = interpolateQuadratic(hp, hc, hn);</span>
<span class="source-line-no">210</span><span id="line-210">                                                double k_max = (k + delta + nb) % nb; </span>
<span class="source-line-no">211</span><span id="line-211">                                                // interpolated bin index, 0 &lt;= km &lt; nPhi:</span>
<span class="source-line-no">212</span><span id="line-212">                                                // double phi_max = k_max * 2 * Math.PI / nb; // 0 &lt;=</span>
<span class="source-line-no">213</span><span id="line-213">                                                // phi &lt; 2 PI. Should be in range +/-PI?</span>
<span class="source-line-no">214</span><span id="line-214">                                                orientIndexes.add(k_max);</span>
<span class="source-line-no">215</span><span id="line-215">                                        }</span>
<span class="source-line-no">216</span><span id="line-216">                                }</span>
<span class="source-line-no">217</span><span id="line-217">                        }</span>
<span class="source-line-no">218</span><span id="line-218">                }</span>
<span class="source-line-no">219</span><span id="line-219">                return orientIndexes;</span>
<span class="source-line-no">220</span><span id="line-220">        }</span>
<span class="source-line-no">221</span><span id="line-221"></span>
<span class="source-line-no">222</span><span id="line-222">        private List&lt;KeyPoint&gt; getKeyPoints() {</span>
<span class="source-line-no">223</span><span id="line-223">                List&lt;KeyPoint&gt; keyPts = new ArrayList&lt;KeyPoint&gt;();</span>
<span class="source-line-no">224</span><span id="line-224">                final int P = params.P;</span>
<span class="source-line-no">225</span><span id="line-225">                final int K = params.Q;</span>
<span class="source-line-no">226</span><span id="line-226">                for (int p = 0; p &lt;= P-1; p++) {        // for every octave p</span>
<span class="source-line-no">227</span><span id="line-227">                        for (int q = 0; q &lt;= K-1; q++) {        // for every scale level q</span>
<span class="source-line-no">228</span><span id="line-228">                                List&lt;KeyPoint&gt; extrema = findExtrema(p, q);</span>
<span class="source-line-no">229</span><span id="line-229">                                for (KeyPoint e : extrema) {</span>
<span class="source-line-no">230</span><span id="line-230">                                        KeyPoint c = refineKeyPosition(D, e);</span>
<span class="source-line-no">231</span><span id="line-231">                                        if (c != null) {</span>
<span class="source-line-no">232</span><span id="line-232">                                                keyPts.add(c);</span>
<span class="source-line-no">233</span><span id="line-233">                                        }</span>
<span class="source-line-no">234</span><span id="line-234">                                }</span>
<span class="source-line-no">235</span><span id="line-235">                        }</span>
<span class="source-line-no">236</span><span id="line-236">                }</span>
<span class="source-line-no">237</span><span id="line-237">                Collections.sort(keyPts);       // always sort (by decreasing score)</span>
<span class="source-line-no">238</span><span id="line-238">                return keyPts;</span>
<span class="source-line-no">239</span><span id="line-239">        }</span>
<span class="source-line-no">240</span><span id="line-240"></span>
<span class="source-line-no">241</span><span id="line-241">        private List&lt;KeyPoint&gt; findExtrema(int p, int q) {</span>
<span class="source-line-no">242</span><span id="line-242">                final float tMag = (float) params.tMag;</span>
<span class="source-line-no">243</span><span id="line-243">                final float tExtrm = (float) params.tExtrm;</span>
<span class="source-line-no">244</span><span id="line-244">                final DogOctave Dp = D.getOctave(p);</span>
<span class="source-line-no">245</span><span id="line-245">                final ScaleLevel Dpq = D.getScaleLevel(p, q);</span>
<span class="source-line-no">246</span><span id="line-246">                final int M = Dpq.getWidth();</span>
<span class="source-line-no">247</span><span id="line-247">                final int N = Dpq.getHeight();</span>
<span class="source-line-no">248</span><span id="line-248">                </span>
<span class="source-line-no">249</span><span id="line-249">                List&lt;KeyPoint&gt; E = new ArrayList&lt;KeyPoint&gt;();</span>
<span class="source-line-no">250</span><span id="line-250">                float scale = (float)D.getAbsoluteScale(p, q);  //D.getScaleIndexFloat(p, q); needed?</span>
<span class="source-line-no">251</span><span id="line-251"></span>
<span class="source-line-no">252</span><span id="line-252">                final float[][][] nh = new float[3][3][3];                      // 3x3x3 neighborhood [q][u][v]</span>
<span class="source-line-no">253</span><span id="line-253">                for (int u = 1; u &lt;= M - 2; u++) {</span>
<span class="source-line-no">254</span><span id="line-254">                        float x_real = (float) D.getRealX(p, u);                // for display purposes only</span>
<span class="source-line-no">255</span><span id="line-255">                        for (int v = 1; v &lt;= N - 2; v++) {</span>
<span class="source-line-no">256</span><span id="line-256">                                float y_real = (float) D.getRealY(p, v);        // for display purposes only</span>
<span class="source-line-no">257</span><span id="line-257">                                float mag = Math.abs(Dpq.getValue(u, v));</span>
<span class="source-line-no">258</span><span id="line-258">                                if (mag &gt; tMag) {</span>
<span class="source-line-no">259</span><span id="line-259">                                        Dp.getNeighborhood(q, u, v, nh);                // CHANGE to use D not Dp!!</span>
<span class="source-line-no">260</span><span id="line-260">                                        if (isExtremum(nh, tExtrm)) {</span>
<span class="source-line-no">261</span><span id="line-261">                                                KeyPoint e = new KeyPoint(p, q, u, v, u, v, x_real, y_real, scale, mag);</span>
<span class="source-line-no">262</span><span id="line-262">                                                E.add(e);</span>
<span class="source-line-no">263</span><span id="line-263">                                        }</span>
<span class="source-line-no">264</span><span id="line-264">                                }</span>
<span class="source-line-no">265</span><span id="line-265">                        }</span>
<span class="source-line-no">266</span><span id="line-266">                }</span>
<span class="source-line-no">267</span><span id="line-267">                return E;</span>
<span class="source-line-no">268</span><span id="line-268">        }</span>
<span class="source-line-no">269</span><span id="line-269"></span>
<span class="source-line-no">270</span><span id="line-270">        private KeyPoint refineKeyPosition(DogScaleSpace D, KeyPoint k) { </span>
<span class="source-line-no">271</span><span id="line-271">                final int p = k.p;</span>
<span class="source-line-no">272</span><span id="line-272">                final int q = k.q;</span>
<span class="source-line-no">273</span><span id="line-273">                int u = k.u;</span>
<span class="source-line-no">274</span><span id="line-274">                int v = k.v;</span>
<span class="source-line-no">275</span><span id="line-275">                </span>
<span class="source-line-no">276</span><span id="line-276">                final DogOctave Dp = D.getOctave(p);</span>
<span class="source-line-no">277</span><span id="line-277">                final double rhoMax = params.rhoMax;</span>
<span class="source-line-no">278</span><span id="line-278">                final double tPeak = params.tPeak;</span>
<span class="source-line-no">279</span><span id="line-279">                final int nRefine = params.nRefine;</span>
<span class="source-line-no">280</span><span id="line-280"></span>
<span class="source-line-no">281</span><span id="line-281">                final float[][][] nh = new float[3][3][3];      // 3x3x3 neighborhood nh[q][u][v]</span>
<span class="source-line-no">282</span><span id="line-282">                final float[] grad       = new float[3];                // gradient (dx, dy, ds)        </span>
<span class="source-line-no">283</span><span id="line-283">                final float[] d          = new float[3];                // relocation displacement (dx, dy, ds)</span>
<span class="source-line-no">284</span><span id="line-284">                final float[][] hess = new float[3][3];         // 3D Hessian matrix:</span>
<span class="source-line-no">285</span><span id="line-285">                                                                                                        // | dxx dxy dxs |</span>
<span class="source-line-no">286</span><span id="line-286">                                                                                                        // | dxy dyy dys |</span>
<span class="source-line-no">287</span><span id="line-287">                                                                                                        // | dxs dys dss |</span>
<span class="source-line-no">288</span><span id="line-288">                </span>
<span class="source-line-no">289</span><span id="line-289">                final float aMax = (float) (sqr(rhoMax + 1) / rhoMax);</span>
<span class="source-line-no">290</span><span id="line-290">                KeyPoint kr = null;                                                     // refined keypoint</span>
<span class="source-line-no">291</span><span id="line-291">                boolean done = false;</span>
<span class="source-line-no">292</span><span id="line-292">                int n = 1;</span>
<span class="source-line-no">293</span><span id="line-293">                while (!done &amp;&amp; n &lt;= nRefine &amp;&amp; Dp.isInside(q, u, v)) {</span>
<span class="source-line-no">294</span><span id="line-294">                        Dp.getNeighborhood(q, u, v, nh);        // TODO: CHANGE to use D instead of Dp!</span>
<span class="source-line-no">295</span><span id="line-295">                        gradient(nh, grad);                                     // result stored in grad</span>
<span class="source-line-no">296</span><span id="line-296">                        hessian(nh, hess);                                      // result stored in hess</span>
<span class="source-line-no">297</span><span id="line-297">                        final double detH = Matrix.determinant3x3(hess);</span>
<span class="source-line-no">298</span><span id="line-298">                        if (Arithmetic.isZero(detH)) {  // Hessian matrix has zero determinant?</span>
<span class="source-line-no">299</span><span id="line-299">                                done = true;    // ignore this point and finish</span>
<span class="source-line-no">300</span><span id="line-300">                        }</span>
<span class="source-line-no">301</span><span id="line-301">                        else {</span>
<span class="source-line-no">302</span><span id="line-302">                                final float dxx = hess[0][0];   // extract 2x2 Hessian for calculating curvature ratio below</span>
<span class="source-line-no">303</span><span id="line-303">                                final float dxy = hess[0][1];</span>
<span class="source-line-no">304</span><span id="line-304">                                final float dyy = hess[1][1];</span>
<span class="source-line-no">305</span><span id="line-305">//                              final float[][] invHess = Matrix.inverse3x3(hess);      // deprecated</span>
<span class="source-line-no">306</span><span id="line-306">                                final float[][] invHess = Matrix.inverse(hess);         // alternative (numerically stable)</span>
<span class="source-line-no">307</span><span id="line-307">                                Matrix.multiplyD(invHess, grad, d);     // d &lt;-- invHess . grad</span>
<span class="source-line-no">308</span><span id="line-308">                                Matrix.multiplyD(-1, d);                        // d &lt;-- - d</span>
<span class="source-line-no">309</span><span id="line-309">                                final float xx = d[0];  // = x'</span>
<span class="source-line-no">310</span><span id="line-310">                                final float yy = d[1];  // = y'</span>
<span class="source-line-no">311</span><span id="line-311"></span>
<span class="source-line-no">312</span><span id="line-312">                                if (Math.abs(xx) &lt; 0.5f &amp;&amp; Math.abs(yy) &lt; 0.5f) {       // stay at this lattice point</span>
<span class="source-line-no">313</span><span id="line-313">                                        done = true;</span>
<span class="source-line-no">314</span><span id="line-314">                                        final float Dpeak = nh[1][1][1] + 0.5f * (grad[0]*xx + grad[1]*yy + grad[2]*d[2]);</span>
<span class="source-line-no">315</span><span id="line-315">                                        final float detHxy = dxx * dyy - dxy * dxy;</span>
<span class="source-line-no">316</span><span id="line-316">                                        if (Math.abs(Dpeak) &gt; tPeak &amp;&amp; detHxy &gt; 0) { // check peak magnitude</span>
<span class="source-line-no">317</span><span id="line-317">                                                final float a = sqr(dxx + dyy) / detHxy;</span>
<span class="source-line-no">318</span><span id="line-318">                                                if (a &lt;= aMax) {                                        // check curvature ratio (edgeness)</span>
<span class="source-line-no">319</span><span id="line-319">                                                        // new, refined keypoint:</span>
<span class="source-line-no">320</span><span id="line-320">                                                        float x = u + xx;</span>
<span class="source-line-no">321</span><span id="line-321">                                                        float y = v + yy;</span>
<span class="source-line-no">322</span><span id="line-322">                                                        float x_real = (float) D.getRealX(p, x);</span>
<span class="source-line-no">323</span><span id="line-323">                                                        float y_real = (float) D.getRealY(p, y);</span>
<span class="source-line-no">324</span><span id="line-324">                                                        float scale  = (float) D.getAbsoluteScale(p, q);</span>
<span class="source-line-no">325</span><span id="line-325">                                                        kr = new KeyPoint(k.p, k.q, k.u, k.v, x, y, x_real, y_real, scale, k.magnitude);</span>
<span class="source-line-no">326</span><span id="line-326">                                                }</span>
<span class="source-line-no">327</span><span id="line-327">                                        }</span>
<span class="source-line-no">328</span><span id="line-328">                                }</span>
<span class="source-line-no">329</span><span id="line-329">                                else { // large displacement, move to a neighboring DoG cell at same level q by at most one unit</span>
<span class="source-line-no">330</span><span id="line-330">                                        u = u + Math.min(1, Math.max(-1, Math.round(xx)));      // move u by max +/-1</span>
<span class="source-line-no">331</span><span id="line-331">                                        v = v + Math.min(1, Math.max(-1, Math.round(yy)));      // move v by max +/-1</span>
<span class="source-line-no">332</span><span id="line-332">                                        // Note: we don't move along the scale axis!</span>
<span class="source-line-no">333</span><span id="line-333">                                }</span>
<span class="source-line-no">334</span><span id="line-334">                        }</span>
<span class="source-line-no">335</span><span id="line-335">                        n = n + 1;</span>
<span class="source-line-no">336</span><span id="line-336">                }</span>
<span class="source-line-no">337</span><span id="line-337">                return kr;</span>
<span class="source-line-no">338</span><span id="line-338">        }</span>
<span class="source-line-no">339</span><span id="line-339"></span>
<span class="source-line-no">340</span><span id="line-340">        private boolean isExtremum(float[][][] nh, float tExtrm) {</span>
<span class="source-line-no">341</span><span id="line-341">                return isLocalMin(nh, tExtrm) || isLocalMax(nh, tExtrm);</span>
<span class="source-line-no">342</span><span id="line-342">        }</span>
<span class="source-line-no">343</span><span id="line-343"></span>
<span class="source-line-no">344</span><span id="line-344">        private boolean isLocalMin(final float[][][] neighborhood, float tExtrm) {</span>
<span class="source-line-no">345</span><span id="line-345">                final float c = neighborhood[1][1][1] + tExtrm; // center value + threshold</span>
<span class="source-line-no">346</span><span id="line-346">                if (c &gt;= 0) return false;       // local minimum must have a negative value</span>
<span class="source-line-no">347</span><span id="line-347">                // check 8 neighbors in scale plane q</span>
<span class="source-line-no">348</span><span id="line-348">                if (c &gt;= neighborhood[1][0][0]) return false;</span>
<span class="source-line-no">349</span><span id="line-349">                if (c &gt;= neighborhood[1][1][0]) return false;</span>
<span class="source-line-no">350</span><span id="line-350">                if (c &gt;= neighborhood[1][2][0]) return false;</span>
<span class="source-line-no">351</span><span id="line-351">                if (c &gt;= neighborhood[1][0][1]) return false;</span>
<span class="source-line-no">352</span><span id="line-352">                if (c &gt;= neighborhood[1][2][1]) return false;</span>
<span class="source-line-no">353</span><span id="line-353">                if (c &gt;= neighborhood[1][0][2]) return false;</span>
<span class="source-line-no">354</span><span id="line-354">                if (c &gt;= neighborhood[1][1][2]) return false;</span>
<span class="source-line-no">355</span><span id="line-355">                if (c &gt;= neighborhood[1][2][2]) return false;</span>
<span class="source-line-no">356</span><span id="line-356">                if (nhSize &gt;= 10) {</span>
<span class="source-line-no">357</span><span id="line-357">                        if (c &gt;= neighborhood[0][1][1]) return false;</span>
<span class="source-line-no">358</span><span id="line-358">                        if (c &gt;= neighborhood[2][1][1]) return false;</span>
<span class="source-line-no">359</span><span id="line-359">                        if (nhSize &gt;= 18) {</span>
<span class="source-line-no">360</span><span id="line-360">                                // check 4 more neighbors in scale plane q-1</span>
<span class="source-line-no">361</span><span id="line-361">                                if (c &gt;= neighborhood[0][0][1]) return false;</span>
<span class="source-line-no">362</span><span id="line-362">                                if (c &gt;= neighborhood[0][2][1]) return false;</span>
<span class="source-line-no">363</span><span id="line-363">                                if (c &gt;= neighborhood[0][1][0]) return false;</span>
<span class="source-line-no">364</span><span id="line-364">                                if (c &gt;= neighborhood[0][1][2]) return false;</span>
<span class="source-line-no">365</span><span id="line-365">                                // check 4 more neighbors in scale plane q+1</span>
<span class="source-line-no">366</span><span id="line-366">                                if (c &gt;= neighborhood[2][0][1]) return false;</span>
<span class="source-line-no">367</span><span id="line-367">                                if (c &gt;= neighborhood[2][2][1]) return false;</span>
<span class="source-line-no">368</span><span id="line-368">                                if (c &gt;= neighborhood[2][1][0]) return false;</span>
<span class="source-line-no">369</span><span id="line-369">                                if (c &gt;= neighborhood[2][1][2]) return false;</span>
<span class="source-line-no">370</span><span id="line-370">                                // optionally check 8 remaining neighbors (corners of cube):</span>
<span class="source-line-no">371</span><span id="line-371">                                if (nhSize &gt;= 26) {</span>
<span class="source-line-no">372</span><span id="line-372">                                        if (c &gt;= neighborhood[0][0][0]) return false;</span>
<span class="source-line-no">373</span><span id="line-373">                                        if (c &gt;= neighborhood[0][2][0]) return false;</span>
<span class="source-line-no">374</span><span id="line-374">                                        if (c &gt;= neighborhood[0][0][2]) return false;</span>
<span class="source-line-no">375</span><span id="line-375">                                        if (c &gt;= neighborhood[0][2][2]) return false;</span>
<span class="source-line-no">376</span><span id="line-376">                                        if (c &gt;= neighborhood[2][0][0]) return false;</span>
<span class="source-line-no">377</span><span id="line-377">                                        if (c &gt;= neighborhood[2][2][0]) return false;</span>
<span class="source-line-no">378</span><span id="line-378">                                        if (c &gt;= neighborhood[2][0][2]) return false;</span>
<span class="source-line-no">379</span><span id="line-379">                                        if (c &gt;= neighborhood[2][2][2]) return false;</span>
<span class="source-line-no">380</span><span id="line-380">                                }</span>
<span class="source-line-no">381</span><span id="line-381">                        }</span>
<span class="source-line-no">382</span><span id="line-382">                }</span>
<span class="source-line-no">383</span><span id="line-383">                return true;</span>
<span class="source-line-no">384</span><span id="line-384">        }</span>
<span class="source-line-no">385</span><span id="line-385"></span>
<span class="source-line-no">386</span><span id="line-386">        private boolean isLocalMax(final float[][][] neighborhood, float tExtrm) {</span>
<span class="source-line-no">387</span><span id="line-387">                final float c = neighborhood[1][1][1] - tExtrm;         // center value - threshold</span>
<span class="source-line-no">388</span><span id="line-388">                if (c &lt;= 0) return false;       // local maximum must have a positive value</span>
<span class="source-line-no">389</span><span id="line-389">                // check 8 neighbors in scale plane q</span>
<span class="source-line-no">390</span><span id="line-390">                if (c &lt;= neighborhood[1][0][0]) return false;</span>
<span class="source-line-no">391</span><span id="line-391">                if (c &lt;= neighborhood[1][1][0]) return false;</span>
<span class="source-line-no">392</span><span id="line-392">                if (c &lt;= neighborhood[1][2][0]) return false;</span>
<span class="source-line-no">393</span><span id="line-393">                if (c &lt;= neighborhood[1][0][1]) return false;</span>
<span class="source-line-no">394</span><span id="line-394">                if (c &lt;= neighborhood[1][2][1]) return false;</span>
<span class="source-line-no">395</span><span id="line-395">                if (c &lt;= neighborhood[1][0][2]) return false;</span>
<span class="source-line-no">396</span><span id="line-396">                if (c &lt;= neighborhood[1][1][2]) return false;</span>
<span class="source-line-no">397</span><span id="line-397">                if (c &lt;= neighborhood[1][2][2]) return false;</span>
<span class="source-line-no">398</span><span id="line-398">                if (nhSize &gt;= 10) {</span>
<span class="source-line-no">399</span><span id="line-399">                        if (c &lt;= neighborhood[0][1][1]) return false;</span>
<span class="source-line-no">400</span><span id="line-400">                        if (c &lt;= neighborhood[2][1][1]) return false;</span>
<span class="source-line-no">401</span><span id="line-401">                        if (nhSize &gt;= 18) {</span>
<span class="source-line-no">402</span><span id="line-402">                                // check 4 more neighbors in scale plane q-1</span>
<span class="source-line-no">403</span><span id="line-403">                                if (c &lt;= neighborhood[0][0][1]) return false;</span>
<span class="source-line-no">404</span><span id="line-404">                                if (c &lt;= neighborhood[0][2][1]) return false;</span>
<span class="source-line-no">405</span><span id="line-405">                                if (c &lt;= neighborhood[0][1][0]) return false;</span>
<span class="source-line-no">406</span><span id="line-406">                                if (c &lt;= neighborhood[0][1][2]) return false;</span>
<span class="source-line-no">407</span><span id="line-407">                                // check 4 more neighbors in scale plane q+1</span>
<span class="source-line-no">408</span><span id="line-408">                                if (c &lt;= neighborhood[2][0][1]) return false;</span>
<span class="source-line-no">409</span><span id="line-409">                                if (c &lt;= neighborhood[2][2][1]) return false;</span>
<span class="source-line-no">410</span><span id="line-410">                                if (c &lt;= neighborhood[2][1][0]) return false;</span>
<span class="source-line-no">411</span><span id="line-411">                                if (c &lt;= neighborhood[2][1][2]) return false;</span>
<span class="source-line-no">412</span><span id="line-412">                                // optionally check 8 remaining neighbors (corners of cube):</span>
<span class="source-line-no">413</span><span id="line-413">                                if (nhSize &gt;= 26) {</span>
<span class="source-line-no">414</span><span id="line-414">                                        if (c &lt;= neighborhood[0][0][0]) return false;</span>
<span class="source-line-no">415</span><span id="line-415">                                        if (c &lt;= neighborhood[0][2][0]) return false;</span>
<span class="source-line-no">416</span><span id="line-416">                                        if (c &lt;= neighborhood[0][0][2]) return false;</span>
<span class="source-line-no">417</span><span id="line-417">                                        if (c &lt;= neighborhood[0][2][2]) return false;</span>
<span class="source-line-no">418</span><span id="line-418">                                        if (c &lt;= neighborhood[2][0][0]) return false;</span>
<span class="source-line-no">419</span><span id="line-419">                                        if (c &lt;= neighborhood[2][2][0]) return false;</span>
<span class="source-line-no">420</span><span id="line-420">                                        if (c &lt;= neighborhood[2][0][2]) return false;</span>
<span class="source-line-no">421</span><span id="line-421">                                        if (c &lt;= neighborhood[2][2][2]) return false;</span>
<span class="source-line-no">422</span><span id="line-422">                                }</span>
<span class="source-line-no">423</span><span id="line-423">                        }</span>
<span class="source-line-no">424</span><span id="line-424">                }</span>
<span class="source-line-no">425</span><span id="line-425">                return true;</span>
<span class="source-line-no">426</span><span id="line-426">        }</span>
<span class="source-line-no">427</span><span id="line-427"></span>
<span class="source-line-no">428</span><span id="line-428">        /*</span>
<span class="source-line-no">429</span><span id="line-429">         * Calculates the 3-dimensional gradient vector for the 3x3x3 neighborhood</span>
<span class="source-line-no">430</span><span id="line-430">         * nh[s][x][y]. The result is stored in the supplied vector grad, to which a reference is </span>
<span class="source-line-no">431</span><span id="line-431">         * returned.</span>
<span class="source-line-no">432</span><span id="line-432">         */</span>
<span class="source-line-no">433</span><span id="line-433">        private float[] gradient(final float[][][] nh, final float[] grad) {</span>
<span class="source-line-no">434</span><span id="line-434">                // Note: factor 0.5f not needed, kept for clarity.</span>
<span class="source-line-no">435</span><span id="line-435">                grad[0] = 0.5f * (nh[1][2][1] - nh[1][0][1]);   // = dx</span>
<span class="source-line-no">436</span><span id="line-436">                grad[1] = 0.5f * (nh[1][1][2] - nh[1][1][0]);   // = dy</span>
<span class="source-line-no">437</span><span id="line-437">                grad[2] = 0.5f * (nh[2][1][1] - nh[0][1][1]);   // = ds</span>
<span class="source-line-no">438</span><span id="line-438">                return grad;</span>
<span class="source-line-no">439</span><span id="line-439">        }</span>
<span class="source-line-no">440</span><span id="line-440"></span>
<span class="source-line-no">441</span><span id="line-441">        /* </span>
<span class="source-line-no">442</span><span id="line-442">         * Calculates the 3x3 Hessian matrix for the 3x3x3 neighborhood nh[s][i][j],</span>
<span class="source-line-no">443</span><span id="line-443">         * with scale index s and spatial indices i, j.</span>
<span class="source-line-no">444</span><span id="line-444">         * The result is stored in the supplied array hess, to which a reference is </span>
<span class="source-line-no">445</span><span id="line-445">         * returned.</span>
<span class="source-line-no">446</span><span id="line-446">         */</span>
<span class="source-line-no">447</span><span id="line-447">        private float[][] hessian(final float[][][] nh, final float[][] hess) {</span>
<span class="source-line-no">448</span><span id="line-448">                final float nh_111 = 2 * nh[1][1][1];</span>
<span class="source-line-no">449</span><span id="line-449">                final float dxx = nh[1][0][1] - nh_111 + nh[1][2][1];</span>
<span class="source-line-no">450</span><span id="line-450">                final float dyy = nh[1][1][0] - nh_111 + nh[1][1][2];</span>
<span class="source-line-no">451</span><span id="line-451">                final float dss = nh[0][1][1] - nh_111 + nh[2][1][1];</span>
<span class="source-line-no">452</span><span id="line-452"></span>
<span class="source-line-no">453</span><span id="line-453">                final float dxy = (nh[1][2][2] - nh[1][0][2] - nh[1][2][0] + nh[1][0][0]) * 0.25f;</span>
<span class="source-line-no">454</span><span id="line-454">                final float dxs = (nh[2][2][1] - nh[2][0][1] - nh[0][2][1] + nh[0][0][1]) * 0.25f;</span>
<span class="source-line-no">455</span><span id="line-455">                final float dys = (nh[2][1][2] - nh[2][1][0] - nh[0][1][2] + nh[0][1][0]) * 0.25f;</span>
<span class="source-line-no">456</span><span id="line-456"></span>
<span class="source-line-no">457</span><span id="line-457">                hess[0][0] = dxx;  hess[0][1] = dxy;  hess[0][2] = dxs;</span>
<span class="source-line-no">458</span><span id="line-458">                hess[1][0] = dxy;  hess[1][1] = dyy;  hess[1][2] = dys;</span>
<span class="source-line-no">459</span><span id="line-459">                hess[2][0] = dxs;  hess[2][1] = dys;  hess[2][2] = dss;</span>
<span class="source-line-no">460</span><span id="line-460">                return hess;</span>
<span class="source-line-no">461</span><span id="line-461">        }</span>
<span class="source-line-no">462</span><span id="line-462"></span>
<span class="source-line-no">463</span><span id="line-463">        /*</span>
<span class="source-line-no">464</span><span id="line-464">         * Returns a list of orientations (angles) for the keypoint c.</span>
<span class="source-line-no">465</span><span id="line-465">         */</span>
<span class="source-line-no">466</span><span id="line-466">        private List&lt;Double&gt; getDominantOrientations(KeyPoint c) {</span>
<span class="source-line-no">467</span><span id="line-467">                float[] h_phi = getOrientationHistogram(c);</span>
<span class="source-line-no">468</span><span id="line-468">                smoothCircular(h_phi, params.nSmooth);</span>
<span class="source-line-no">469</span><span id="line-469">                return findPeakOrientations(h_phi);</span>
<span class="source-line-no">470</span><span id="line-470">        }</span>
<span class="source-line-no">471</span><span id="line-471"></span>
<span class="source-line-no">472</span><span id="line-472">        // Smoothes the array A in-place (i.e., destructively) in 'iterations' passes.</span>
<span class="source-line-no">473</span><span id="line-473">        private void smoothCircular(float[] X, int n_iter) {</span>
<span class="source-line-no">474</span><span id="line-474">                final float[] H = { 0.25f, 0.5f, 0.25f }; // filter kernel</span>
<span class="source-line-no">475</span><span id="line-475">                final int n = X.length;</span>
<span class="source-line-no">476</span><span id="line-476">                for (int i = 1; i &lt;= n_iter; i++) {</span>
<span class="source-line-no">477</span><span id="line-477">                        float s = X[0];</span>
<span class="source-line-no">478</span><span id="line-478">                        float p = X[n - 1];</span>
<span class="source-line-no">479</span><span id="line-479">                        for (int j = 0; j &lt;= n - 2; j++) {</span>
<span class="source-line-no">480</span><span id="line-480">                                float c = X[j];</span>
<span class="source-line-no">481</span><span id="line-481">                                X[j] = H[0] * p + H[1] * X[j] + H[2] * X[j + 1];</span>
<span class="source-line-no">482</span><span id="line-482">                                p = c;</span>
<span class="source-line-no">483</span><span id="line-483">                        }</span>
<span class="source-line-no">484</span><span id="line-484">                        X[n - 1] = H[0] * p + H[1] * X[n - 1] + H[2] * s;</span>
<span class="source-line-no">485</span><span id="line-485">                }</span>
<span class="source-line-no">486</span><span id="line-486">        }</span>
<span class="source-line-no">487</span><span id="line-487"></span>
<span class="source-line-no">488</span><span id="line-488">        /* </span>
<span class="source-line-no">489</span><span id="line-489">         * Extracts the peaks in the orientation histogram 'h_phi'</span>
<span class="source-line-no">490</span><span id="line-490">         * and returns the corresponding angles in a (possibly empty) list. </span>
<span class="source-line-no">491</span><span id="line-491">         */</span>
<span class="source-line-no">492</span><span id="line-492">        private List&lt;Double&gt; findPeakOrientations(float[] h_phi) {</span>
<span class="source-line-no">493</span><span id="line-493">                int n = h_phi.length;</span>
<span class="source-line-no">494</span><span id="line-494">                List&lt;Double&gt; angles = new ArrayList&lt;Double&gt;(n);</span>
<span class="source-line-no">495</span><span id="line-495">                // find the maximum entry in the orientation histogram 'h_phi'</span>
<span class="source-line-no">496</span><span id="line-496">                float h_max = h_phi[0];</span>
<span class="source-line-no">497</span><span id="line-497">                for (int k = 1; k &lt; n; k++) {</span>
<span class="source-line-no">498</span><span id="line-498">                        if (h_phi[k] &gt; h_max)</span>
<span class="source-line-no">499</span><span id="line-499">                                h_max = h_phi[k];</span>
<span class="source-line-no">500</span><span id="line-500">                }</span>
<span class="source-line-no">501</span><span id="line-501">                if (h_max &gt; 0.01f) {    // ascertain minimum (non-zero) gradient energy </span>
<span class="source-line-no">502</span><span id="line-502">                        // collect all peaks &gt; 80% of the maximum entry in 'oh'</span>
<span class="source-line-no">503</span><span id="line-503">                        float h_min = h_max * 0.8f;</span>
<span class="source-line-no">504</span><span id="line-504">                        for (int k = 0; k &lt; n; k++) {   // hp ~ hc ~ ha</span>
<span class="source-line-no">505</span><span id="line-505">                                float hc = h_phi[k];                                            // center value</span>
<span class="source-line-no">506</span><span id="line-506">                                if (hc &gt; h_min) {               // value is min. 80% of global peak</span>
<span class="source-line-no">507</span><span id="line-507">                                        float hp = h_phi[(k - 1 + n) % n];      // previous histogram value</span>
<span class="source-line-no">508</span><span id="line-508">                                        float hn = h_phi[(k + 1) % n];          // next histogram value</span>
<span class="source-line-no">509</span><span id="line-509">                                        if (hc &gt; hp &amp;&amp; hc &gt; hn) {                       // check if 'hc' is a local peak</span>
<span class="source-line-no">510</span><span id="line-510">                                                // interpolate orientation by a quadratic function (parabola):</span>
<span class="source-line-no">511</span><span id="line-511">                                                double delta = interpolateQuadratic(hp, hc, hn);</span>
<span class="source-line-no">512</span><span id="line-512">                                                double k_max = (k + delta + n) % n;     // interpolated bin index, 0 &lt;= km &lt; nPhi</span>
<span class="source-line-no">513</span><span id="line-513">                                                double phi_max = k_max * 2 * Math.PI / n;       // 0 &lt;= phi &lt; 2 PI. Should be in range +/-PI?</span>
<span class="source-line-no">514</span><span id="line-514">                                                angles.add(phi_max);</span>
<span class="source-line-no">515</span><span id="line-515">                                        }</span>
<span class="source-line-no">516</span><span id="line-516">                                }</span>
<span class="source-line-no">517</span><span id="line-517">                        }</span>
<span class="source-line-no">518</span><span id="line-518">                }</span>
<span class="source-line-no">519</span><span id="line-519">                return angles;</span>
<span class="source-line-no">520</span><span id="line-520">        }</span>
<span class="source-line-no">521</span><span id="line-521"></span>
<span class="source-line-no">522</span><span id="line-522">        private float[] getOrientationHistogram(KeyPoint c) {</span>
<span class="source-line-no">523</span><span id="line-523">                final int n_phi = params.nOrient;</span>
<span class="source-line-no">524</span><span id="line-524">                final int K = params.Q;</span>
<span class="source-line-no">525</span><span id="line-525"></span>
<span class="source-line-no">526</span><span id="line-526">                ScaleLevel Gpq = G.getScaleLevel(c.p, c.q);</span>
<span class="source-line-no">527</span><span id="line-527">                final float[] h_phi = new float[n_phi]; // automatically initialized to zero</span>
<span class="source-line-no">528</span><span id="line-528">                final int M = Gpq.getWidth(), N = Gpq.getHeight();</span>
<span class="source-line-no">529</span><span id="line-529">                final double x = c.x, y = c.y;</span>
<span class="source-line-no">530</span><span id="line-530"></span>
<span class="source-line-no">531</span><span id="line-531">                final double sigma_w = 1.5 * params.sigma0 * Math.pow(2,(double)c.q/K);</span>
<span class="source-line-no">532</span><span id="line-532">                final double sigma_w22 = 2 * sigma_w * sigma_w;</span>
<span class="source-line-no">533</span><span id="line-533">                final double r_w = Math.max(1, 2.5 * sigma_w);</span>
<span class="source-line-no">534</span><span id="line-534">                final double r_w2 = r_w * r_w;</span>
<span class="source-line-no">535</span><span id="line-535"></span>
<span class="source-line-no">536</span><span id="line-536">                final int u_min = Math.max((int)Math.floor(x - r_w), 1);</span>
<span class="source-line-no">537</span><span id="line-537">                final int u_max = Math.min((int)Math.ceil(x + r_w), M-2);</span>
<span class="source-line-no">538</span><span id="line-538">                final int v_min = Math.max((int)Math.floor(y - r_w), 1);</span>
<span class="source-line-no">539</span><span id="line-539">                final int v_max = Math.min((int)Math.ceil(y + r_w), N-2);</span>
<span class="source-line-no">540</span><span id="line-540"></span>
<span class="source-line-no">541</span><span id="line-541">                double[] gradPol = new double[2]; // gradient magnitude/orientation</span>
<span class="source-line-no">542</span><span id="line-542"></span>
<span class="source-line-no">543</span><span id="line-543">                for (int u = u_min; u &lt;= u_max; u++) {</span>
<span class="source-line-no">544</span><span id="line-544">                        double dx = u - x;                                      // distance to feature's center</span>
<span class="source-line-no">545</span><span id="line-545">                        for (int v = v_min; v &lt;= v_max; v++) {</span>
<span class="source-line-no">546</span><span id="line-546">                                double dy = v - y;</span>
<span class="source-line-no">547</span><span id="line-547">                                double r2 = dx * dx + dy * dy;  // squared distance from center</span>
<span class="source-line-no">548</span><span id="line-548">                                if (r2 &lt; r_w2) {                                // inside limiting circle</span>
<span class="source-line-no">549</span><span id="line-549">                                        Gpq.getGradientPolar(u, v, gradPol);</span>
<span class="source-line-no">550</span><span id="line-550">                                        double E = gradPol[0], phi = gradPol[1];                                // gradient magnitude/orientation</span>
<span class="source-line-no">551</span><span id="line-551">                                        double wG = Math.exp(-(dx*dx + dy*dy)/sigma_w22);               // Gaussian weight</span>
<span class="source-line-no">552</span><span id="line-552">                                        double z = E * wG;</span>
<span class="source-line-no">553</span><span id="line-553">                                        double k_phi = n_phi * phi / (2 * Math.PI);                             // continuous histogram bin index</span>
<span class="source-line-no">554</span><span id="line-554">                                        double alpha = k_phi - Math.floor(k_phi);                               // weight alpha</span>
<span class="source-line-no">555</span><span id="line-555">                                        int k_0 = Math.floorMod((int)Math.floor(k_phi), n_phi); // lower histogram index</span>
<span class="source-line-no">556</span><span id="line-556">                                        int k_1 = Math.floorMod(k_0 + 1, n_phi);                                                        // upper histogram index</span>
<span class="source-line-no">557</span><span id="line-557">                                        h_phi[k_0] = (float) (h_phi[k_0] + (1 - alpha) * z);    // distribute z into bins k_0, k_1</span>
<span class="source-line-no">558</span><span id="line-558">                                        h_phi[k_1] = (float) (h_phi[k_1] + alpha * z);</span>
<span class="source-line-no">559</span><span id="line-559">                                }</span>
<span class="source-line-no">560</span><span id="line-560">                        }</span>
<span class="source-line-no">561</span><span id="line-561">                }</span>
<span class="source-line-no">562</span><span id="line-562">                return h_phi;</span>
<span class="source-line-no">563</span><span id="line-563">        }</span>
<span class="source-line-no">564</span><span id="line-564"></span>
<span class="source-line-no">565</span><span id="line-565">        private SiftDescriptor makeSiftDescriptor(KeyPoint c, double phi_d) {</span>
<span class="source-line-no">566</span><span id="line-566">                final int p = c.p;</span>
<span class="source-line-no">567</span><span id="line-567">                final int q = c.q;</span>
<span class="source-line-no">568</span><span id="line-568">                final double x = c.x;</span>
<span class="source-line-no">569</span><span id="line-569">                final double y = c.y;</span>
<span class="source-line-no">570</span><span id="line-570">                final double mag = c.magnitude;</span>
<span class="source-line-no">571</span><span id="line-571"></span>
<span class="source-line-no">572</span><span id="line-572">                ScaleLevel Gpq = G.getScaleLevel(p, q);</span>
<span class="source-line-no">573</span><span id="line-573">                final int M = Gpq.getWidth(), N = Gpq.getHeight(), K = G.getQ();</span>
<span class="source-line-no">574</span><span id="line-574"></span>
<span class="source-line-no">575</span><span id="line-575">                double sigma_q = G.getSigma_0() * Math.pow(2, (double) q / K);  // = Gpq.getAbsoluteScale() ?? decimated scale</span>
<span class="source-line-no">576</span><span id="line-576">                double w_d = params.sDesc * sigma_q;            // descriptor width</span>
<span class="source-line-no">577</span><span id="line-577">                double sigma_d = 0.25 * w_d;    // width of Gaussian weighting function</span>
<span class="source-line-no">578</span><span id="line-578">                double sigma_d2 = 2 * sigma_d * sigma_d;</span>
<span class="source-line-no">579</span><span id="line-579">                double r_d = 2.5 * sigma_d;             // limiting radius</span>
<span class="source-line-no">580</span><span id="line-580">                double r_d2 = r_d * r_d;                // squared limiting radius</span>
<span class="source-line-no">581</span><span id="line-581"></span>
<span class="source-line-no">582</span><span id="line-582">                double sc = 1.0/w_d;                                    // scale to canonical frame</span>
<span class="source-line-no">583</span><span id="line-583">                double sin_phi_d = Math.sin(-phi_d);    // precalculated sine</span>
<span class="source-line-no">584</span><span id="line-584">                double cos_phi_d = Math.cos(-phi_d);    // precalculated cosine</span>
<span class="source-line-no">585</span><span id="line-585"></span>
<span class="source-line-no">586</span><span id="line-586">                int u_min = Math.max((int)Math.floor(x - r_d), 1);</span>
<span class="source-line-no">587</span><span id="line-587">                int u_max = Math.min((int)Math.ceil(x + r_d), M - 2);</span>
<span class="source-line-no">588</span><span id="line-588"></span>
<span class="source-line-no">589</span><span id="line-589">                int v_min = Math.max((int)Math.floor(y - r_d), 1);</span>
<span class="source-line-no">590</span><span id="line-590">                int v_max = Math.min((int)Math.ceil(y + r_d), N - 2);</span>
<span class="source-line-no">591</span><span id="line-591"></span>
<span class="source-line-no">592</span><span id="line-592">                // create the 3D orientation histogram, initialize to zero:</span>
<span class="source-line-no">593</span><span id="line-593">                final int n_Spat = params.nSpat;</span>
<span class="source-line-no">594</span><span id="line-594">                final int n_Angl = params.nAngl;</span>
<span class="source-line-no">595</span><span id="line-595">                double[][][] h_grad = new double[n_Spat][n_Spat][n_Angl];</span>
<span class="source-line-no">596</span><span id="line-596">                double[] gmo = new double[2];   // gradient magnitude/orientation</span>
<span class="source-line-no">597</span><span id="line-597"></span>
<span class="source-line-no">598</span><span id="line-598">                for (int u = u_min; u &lt;= u_max; u++) {</span>
<span class="source-line-no">599</span><span id="line-599">                        double dx = u - x;</span>
<span class="source-line-no">600</span><span id="line-600">                        for (int v = v_min; v &lt;= v_max; v++) {</span>
<span class="source-line-no">601</span><span id="line-601">                                double dy = v - y;</span>
<span class="source-line-no">602</span><span id="line-602">                                double r2 = sqr(dx) + sqr(dy);  // squared distance from center</span>
<span class="source-line-no">603</span><span id="line-603">                                if (r2 &lt; r_d2) {                                        // inside limiting circle</span>
<span class="source-line-no">604</span><span id="line-604">                                        // map to the canonical coordinate frame, ii,jj \in [-1/2, +1/2]:</span>
<span class="source-line-no">605</span><span id="line-605">                                        double uu = sc * (cos_phi_d * dx - sin_phi_d * dy);</span>
<span class="source-line-no">606</span><span id="line-606">                                        double vv = sc * (sin_phi_d * dx + cos_phi_d * dy);</span>
<span class="source-line-no">607</span><span id="line-607">                                        // calculate the gradient of Gaussian scale level (p,q) at position (u,v):</span>
<span class="source-line-no">608</span><span id="line-608">                                        Gpq.getGradientPolar(u, v, gmo);</span>
<span class="source-line-no">609</span><span id="line-609">                                        double E = gmo[0];                      // gradient magnitude</span>
<span class="source-line-no">610</span><span id="line-610">                                        double phi = gmo[1];            // gradient orientation</span>
<span class="source-line-no">611</span><span id="line-611">                                        double phi_norm = mod(phi - phi_d, PI2);// normalized gradient orientation      </span>
<span class="source-line-no">612</span><span id="line-612">                                        double w_G = Math.exp(-r2/sigma_d2);    // Gaussian weight</span>
<span class="source-line-no">613</span><span id="line-613">                                        double z = E * w_G;                                             // quantity to accumulate</span>
<span class="source-line-no">614</span><span id="line-614">                                        updateGradientHistogram(h_grad, uu, vv, phi_norm, z);</span>
<span class="source-line-no">615</span><span id="line-615">                                }</span>
<span class="source-line-no">616</span><span id="line-616">                        }</span>
<span class="source-line-no">617</span><span id="line-617">                }</span>
<span class="source-line-no">618</span><span id="line-618">                int[] f_int = makeFeatureVector(h_grad);</span>
<span class="source-line-no">619</span><span id="line-619">                double sigma_pq = G.getAbsoluteScale(p, q);</span>
<span class="source-line-no">620</span><span id="line-620">                double x_real = G.getRealX(p, x);</span>
<span class="source-line-no">621</span><span id="line-621">                double y_real = G.getRealY(p, y);</span>
<span class="source-line-no">622</span><span id="line-622">                return new SiftDescriptor(x_real, y_real, sigma_pq, p, mag, phi_d, f_int);</span>
<span class="source-line-no">623</span><span id="line-623">        }</span>
<span class="source-line-no">624</span><span id="line-624"></span>
<span class="source-line-no">625</span><span id="line-625">        private void updateGradientHistogram(double[][][] h_grad, double uu, double vv, double phi_norm, double z) {</span>
<span class="source-line-no">626</span><span id="line-626">                final int n_Spat = params.nSpat;</span>
<span class="source-line-no">627</span><span id="line-627">                final int n_Angl = params.nAngl;</span>
<span class="source-line-no">628</span><span id="line-628"></span>
<span class="source-line-no">629</span><span id="line-629">                final double ii = n_Spat * uu + 0.5 * (n_Spat - 1);     // continuous spatial histogram index i'</span>
<span class="source-line-no">630</span><span id="line-630">                final double jj = n_Spat * vv + 0.5 * (n_Spat - 1);     // continuous spatial histogram index j'</span>
<span class="source-line-no">631</span><span id="line-631">                final double kk = phi_norm * (n_Angl / PI2);            // continuous orientation histogram index k'</span>
<span class="source-line-no">632</span><span id="line-632"></span>
<span class="source-line-no">633</span><span id="line-633">                final int i0 = (int) Math.floor(ii);</span>
<span class="source-line-no">634</span><span id="line-634">                final int i1 = i0 + 1;</span>
<span class="source-line-no">635</span><span id="line-635">                </span>
<span class="source-line-no">636</span><span id="line-636">                final int j0 = (int) Math.floor(jj);</span>
<span class="source-line-no">637</span><span id="line-637">                final int j1 = j0 + 1;</span>
<span class="source-line-no">638</span><span id="line-638">                </span>
<span class="source-line-no">639</span><span id="line-639">                final int k0 = Math.floorMod((int) Math.floor(kk), n_Angl);</span>
<span class="source-line-no">640</span><span id="line-640">                final int k1 = (k0 + 1) % n_Angl;                       // k0 &gt;= 0</span>
<span class="source-line-no">641</span><span id="line-641">                </span>
<span class="source-line-no">642</span><span id="line-642">                final double alpha0 = 1.0 - (ii - i0);</span>
<span class="source-line-no">643</span><span id="line-643">                final double alpha1 = 1.0 - alpha0;</span>
<span class="source-line-no">644</span><span id="line-644"></span>
<span class="source-line-no">645</span><span id="line-645">                final double beta0 = 1.0 - (jj - j0);</span>
<span class="source-line-no">646</span><span id="line-646">                final double beta1 = 1.0 - beta0;</span>
<span class="source-line-no">647</span><span id="line-647"></span>
<span class="source-line-no">648</span><span id="line-648">                final double gamma0 = 1.0 - (kk - Math.floor(kk));</span>
<span class="source-line-no">649</span><span id="line-649">                final double gamma1 = 1.0 - gamma0;</span>
<span class="source-line-no">650</span><span id="line-650"></span>
<span class="source-line-no">651</span><span id="line-651">                final int[] I = {i0, i1};       // index arrays used in loops below</span>
<span class="source-line-no">652</span><span id="line-652">                final int[] J = {j0, j1};</span>
<span class="source-line-no">653</span><span id="line-653">                final int[] K = {k0, k1};</span>
<span class="source-line-no">654</span><span id="line-654"></span>
<span class="source-line-no">655</span><span id="line-655">                final double[] A = {alpha0, alpha1};</span>
<span class="source-line-no">656</span><span id="line-656">                final double[] B = {beta0, beta1};</span>
<span class="source-line-no">657</span><span id="line-657">                final double[] C = {gamma0, gamma1};</span>
<span class="source-line-no">658</span><span id="line-658"></span>
<span class="source-line-no">659</span><span id="line-659">                // distribute z over 8 adjacent spatial/angular bins:</span>
<span class="source-line-no">660</span><span id="line-660">                for (int a = 0; a &lt;= 1; a++) {</span>
<span class="source-line-no">661</span><span id="line-661">                        int i = I[a];</span>
<span class="source-line-no">662</span><span id="line-662">                        if (i &gt;= 0 &amp;&amp; i &lt; n_Spat) {</span>
<span class="source-line-no">663</span><span id="line-663">                                double wa = A[a];</span>
<span class="source-line-no">664</span><span id="line-664">                                for (int b = 0; b &lt;= 1; b++) {</span>
<span class="source-line-no">665</span><span id="line-665">                                        int j = J[b];</span>
<span class="source-line-no">666</span><span id="line-666">                                        if (j &gt;= 0 &amp;&amp; j &lt; n_Spat) {</span>
<span class="source-line-no">667</span><span id="line-667">                                                double wb = B[b];</span>
<span class="source-line-no">668</span><span id="line-668">                                                for (int c = 0; c &lt;= 1; c++) {</span>
<span class="source-line-no">669</span><span id="line-669">                                                        int k = K[c];</span>
<span class="source-line-no">670</span><span id="line-670">                                                        double wc = C[c];</span>
<span class="source-line-no">671</span><span id="line-671">                                                        h_grad[i][j][k] = h_grad[i][j][k] + z * wa * wb * wc;</span>
<span class="source-line-no">672</span><span id="line-672"></span>
<span class="source-line-no">673</span><span id="line-673">                                                }</span>
<span class="source-line-no">674</span><span id="line-674">                                        }</span>
<span class="source-line-no">675</span><span id="line-675">                                }</span>
<span class="source-line-no">676</span><span id="line-676">                        }</span>
<span class="source-line-no">677</span><span id="line-677">                }</span>
<span class="source-line-no">678</span><span id="line-678">        }</span>
<span class="source-line-no">679</span><span id="line-679"></span>
<span class="source-line-no">680</span><span id="line-680">        private int[] makeFeatureVector(double[][][] h_grad) {</span>
<span class="source-line-no">681</span><span id="line-681">                final int n_Spat = params.nSpat;</span>
<span class="source-line-no">682</span><span id="line-682">                final int n_Angl = params.nAngl;</span>
<span class="source-line-no">683</span><span id="line-683">                float[] f = new float[n_Spat * n_Spat * n_Angl];</span>
<span class="source-line-no">684</span><span id="line-684">                // flatten 3D histogram to a 1D vector</span>
<span class="source-line-no">685</span><span id="line-685">                // the histogram is vectorized such that k (phi) is the fastest</span>
<span class="source-line-no">686</span><span id="line-686">                // varying index, followed by j and i (which is the slowest index).</span>
<span class="source-line-no">687</span><span id="line-687">                int m = 0;</span>
<span class="source-line-no">688</span><span id="line-688">                for (int i = 0; i &lt; n_Spat; i++) {</span>
<span class="source-line-no">689</span><span id="line-689">                        for (int j = 0; j &lt; n_Spat; j++) {</span>
<span class="source-line-no">690</span><span id="line-690">                                for (int k = 0; k &lt; n_Angl; k++) {</span>
<span class="source-line-no">691</span><span id="line-691">                                        f[m] = (float) h_grad[i][j][k];</span>
<span class="source-line-no">692</span><span id="line-692">                                        m = m + 1;</span>
<span class="source-line-no">693</span><span id="line-693">                                }</span>
<span class="source-line-no">694</span><span id="line-694">                        }</span>
<span class="source-line-no">695</span><span id="line-695">                }</span>
<span class="source-line-no">696</span><span id="line-696">                normalize(f);</span>
<span class="source-line-no">697</span><span id="line-697">                clipPeaks(f, (float) params.tFclip);    </span>
<span class="source-line-no">698</span><span id="line-698">                normalize(f);</span>
<span class="source-line-no">699</span><span id="line-699">                return mapToIntegers(f, (float) params.sFscale);</span>
<span class="source-line-no">700</span><span id="line-700">        }</span>
<span class="source-line-no">701</span><span id="line-701"></span>
<span class="source-line-no">702</span><span id="line-702">        private void normalize(float[] x) {</span>
<span class="source-line-no">703</span><span id="line-703">                final double norm = Matrix.normL2(x);</span>
<span class="source-line-no">704</span><span id="line-704">                if (norm &gt; Arithmetic.EPSILON_FLOAT) {</span>
<span class="source-line-no">705</span><span id="line-705">                        final float s = (float) (1.0 / norm);</span>
<span class="source-line-no">706</span><span id="line-706">                        for (int i = 0; i &lt; x.length; i++) {</span>
<span class="source-line-no">707</span><span id="line-707">                                x[i] = s * x[i];</span>
<span class="source-line-no">708</span><span id="line-708">                        }</span>
<span class="source-line-no">709</span><span id="line-709">                }</span>
<span class="source-line-no">710</span><span id="line-710">        }</span>
<span class="source-line-no">711</span><span id="line-711"></span>
<span class="source-line-no">712</span><span id="line-712">        private void clipPeaks(float[] x, float xmax) {</span>
<span class="source-line-no">713</span><span id="line-713">                for (int i = 0; i&lt;x.length; i++) {</span>
<span class="source-line-no">714</span><span id="line-714">                        if (x[i] &gt; xmax) {</span>
<span class="source-line-no">715</span><span id="line-715">                                x[i] = xmax;</span>
<span class="source-line-no">716</span><span id="line-716">                        }</span>
<span class="source-line-no">717</span><span id="line-717">                }</span>
<span class="source-line-no">718</span><span id="line-718">        }</span>
<span class="source-line-no">719</span><span id="line-719"></span>
<span class="source-line-no">720</span><span id="line-720">        private int[] mapToIntegers(float[] x, float s) {</span>
<span class="source-line-no">721</span><span id="line-721">                int[] ivec = new int[x.length];</span>
<span class="source-line-no">722</span><span id="line-722">                for (int i = 0; i &lt; x.length; i++) {</span>
<span class="source-line-no">723</span><span id="line-723">                        ivec[i] = Math.round(s * x[i]);</span>
<span class="source-line-no">724</span><span id="line-724">                }</span>
<span class="source-line-no">725</span><span id="line-725">                return ivec;</span>
<span class="source-line-no">726</span><span id="line-726">        }</span>
<span class="source-line-no">727</span><span id="line-727"></span>
<span class="source-line-no">728</span><span id="line-728">        //  auxiliary methods -------------------------</span>
<span class="source-line-no">729</span><span id="line-729"></span>
<span class="source-line-no">730</span><span id="line-730">        /*</span>
<span class="source-line-no">731</span><span id="line-731">         * Calculate the extremal position from 3 discrete function values </span>
<span class="source-line-no">732</span><span id="line-732">         * at x = -1, 0, +1: f(-1) = 'y1', f(0) = 'y2', f(+1) = 'y3'.</span>
<span class="source-line-no">733</span><span id="line-733">         */</span>
<span class="source-line-no">734</span><span id="line-734">        private float interpolateQuadratic(float y1, float y2, float y3) {</span>
<span class="source-line-no">735</span><span id="line-735">                float a = (y1 - 2*y2 + y3) / 2;</span>
<span class="source-line-no">736</span><span id="line-736">                if (Math.abs(a) &lt; 0.00001f) {</span>
<span class="source-line-no">737</span><span id="line-737">                        throw new IllegalArgumentException("quadratic interpolation failed " </span>
<span class="source-line-no">738</span><span id="line-738">                                        + a + " " + y1 + " " + y2 + " " + y3);</span>
<span class="source-line-no">739</span><span id="line-739">                }</span>
<span class="source-line-no">740</span><span id="line-740">                float b = (y3 - y1) / 2;</span>
<span class="source-line-no">741</span><span id="line-741">//              float c = y2;</span>
<span class="source-line-no">742</span><span id="line-742">                float x_extrm = -b / (2*a);             // extremal position</span>
<span class="source-line-no">743</span><span id="line-743">//              float y_extrm = a*x*x + b*x + c;        // extremal value (not needed)</span>
<span class="source-line-no">744</span><span id="line-744">                return x_extrm; // x is in [-1,+1]</span>
<span class="source-line-no">745</span><span id="line-745">        }</span>
<span class="source-line-no">746</span><span id="line-746"></span>
<span class="source-line-no">747</span><span id="line-747">}</span>




























































</pre>
</div>
</main>
</body>
</html>
