<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: module: imagingbook.common, package: imagingbook.common.corners, class: GradientCornerDetector">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/*</span>
<span class="source-line-no">002</span><span id="line-2"> *  This software is provided as a supplement to the authors' textbooks on digital</span>
<span class="source-line-no">003</span><span id="line-3"> * image processing published by Springer-Verlag in various languages and editions.</span>
<span class="source-line-no">004</span><span id="line-4"> * Permission to use and distribute this software is granted under the BSD 2-Clause</span>
<span class="source-line-no">005</span><span id="line-5"> * "Simplified" License (see http://opensource.org/licenses/BSD-2-Clause).</span>
<span class="source-line-no">006</span><span id="line-6"> * Copyright (c) 2006-2022 Wilhelm Burger, Mark J. Burge.</span>
<span class="source-line-no">007</span><span id="line-7"> * All rights reserved. Visit https://imagingbook.com for additional details.</span>
<span class="source-line-no">008</span><span id="line-8"> */</span>
<span class="source-line-no">009</span><span id="line-9"></span>
<span class="source-line-no">010</span><span id="line-10">package imagingbook.common.corners;</span>
<span class="source-line-no">011</span><span id="line-11"></span>
<span class="source-line-no">012</span><span id="line-12">import static imagingbook.common.ij.IjUtils.convolveX;</span>
<span class="source-line-no">013</span><span id="line-13">import static imagingbook.common.ij.IjUtils.convolveY;</span>
<span class="source-line-no">014</span><span id="line-14">import static imagingbook.common.math.Arithmetic.sqr;</span>
<span class="source-line-no">015</span><span id="line-15"></span>
<span class="source-line-no">016</span><span id="line-16">import java.util.ArrayList;</span>
<span class="source-line-no">017</span><span id="line-17">import java.util.Collections;</span>
<span class="source-line-no">018</span><span id="line-18">import java.util.List;</span>
<span class="source-line-no">019</span><span id="line-19"></span>
<span class="source-line-no">020</span><span id="line-20">import ij.process.FloatProcessor;</span>
<span class="source-line-no">021</span><span id="line-21">import ij.process.ImageProcessor;</span>
<span class="source-line-no">022</span><span id="line-22">import imagingbook.common.corners.SubpixelMaxInterpolator.Method;</span>
<span class="source-line-no">023</span><span id="line-23">import imagingbook.common.filter.linear.GaussianFilterSeparable;</span>
<span class="source-line-no">024</span><span id="line-24">import imagingbook.common.filter.linear.LinearFilterSeparable;</span>
<span class="source-line-no">025</span><span id="line-25">import imagingbook.common.ij.DialogUtils;</span>
<span class="source-line-no">026</span><span id="line-26">import imagingbook.common.image.ImageMath;</span>
<span class="source-line-no">027</span><span id="line-27">import imagingbook.common.util.ParameterBundle;</span>
<span class="source-line-no">028</span><span id="line-28"></span>
<span class="source-line-no">029</span><span id="line-29">/**</span>
<span class="source-line-no">030</span><span id="line-30"> * &lt;p&gt;</span>
<span class="source-line-no">031</span><span id="line-31"> * Abstract super class for all corner detectors based on the local structure</span>
<span class="source-line-no">032</span><span id="line-32"> * matrix (tensor). See Ch. 6 of [1] for details.</span>
<span class="source-line-no">033</span><span id="line-33"> * &lt;/p&gt;</span>
<span class="source-line-no">034</span><span id="line-34"> * &lt;p&gt;</span>
<span class="source-line-no">035</span><span id="line-35"> * [1] W. Burger, M.J. Burge, &lt;em&gt;Digital Image Processing &amp;ndash; An</span>
<span class="source-line-no">036</span><span id="line-36"> * Algorithmic Introduction&lt;/em&gt;, 3rd ed, Springer (2022).</span>
<span class="source-line-no">037</span><span id="line-37"> * &lt;/p&gt;</span>
<span class="source-line-no">038</span><span id="line-38"> * </span>
<span class="source-line-no">039</span><span id="line-39"> * @author WB</span>
<span class="source-line-no">040</span><span id="line-40"> * @version 2022/03/30</span>
<span class="source-line-no">041</span><span id="line-41"> * </span>
<span class="source-line-no">042</span><span id="line-42"> * @see HarrisCornerDetector</span>
<span class="source-line-no">043</span><span id="line-43"> * @see MopsCornerDetector</span>
<span class="source-line-no">044</span><span id="line-44"> * @see ShiTomasiCornerDetector</span>
<span class="source-line-no">045</span><span id="line-45"> */</span>
<span class="source-line-no">046</span><span id="line-46">public abstract class GradientCornerDetector {</span>
<span class="source-line-no">047</span><span id="line-47">        </span>
<span class="source-line-no">048</span><span id="line-48">        /** For testing/example calculations only! */</span>
<span class="source-line-no">049</span><span id="line-49">        public static boolean RETAIN_TEMPORARY_DATA = false;</span>
<span class="source-line-no">050</span><span id="line-50">        </span>
<span class="source-line-no">051</span><span id="line-51">        public static class Parameters implements ParameterBundle&lt;GradientCornerDetector&gt; {</span>
<span class="source-line-no">052</span><span id="line-52">                @DialogUtils.DialogLabel("Apply pre-filter")</span>
<span class="source-line-no">053</span><span id="line-53">                public boolean doPreFilter = true;</span>
<span class="source-line-no">054</span><span id="line-54">                </span>
<span class="source-line-no">055</span><span id="line-55">                @DialogUtils.DialogLabel("Gaussian smoothing radius (\u03C3)")@DialogUtils.DialogDigits(3)</span>
<span class="source-line-no">056</span><span id="line-56">                public double sigma = 1.275;</span>
<span class="source-line-no">057</span><span id="line-57">                </span>
<span class="source-line-no">058</span><span id="line-58">                @DialogUtils.DialogLabel("Border margins")</span>
<span class="source-line-no">059</span><span id="line-59">                public int border = 20; // TODO: replace 'border' by ROI rectangle</span>
<span class="source-line-no">060</span><span id="line-60">                </span>
<span class="source-line-no">061</span><span id="line-61">                @DialogUtils.DialogLabel("Clean up corners")</span>
<span class="source-line-no">062</span><span id="line-62">                public boolean doCleanUp = true;</span>
<span class="source-line-no">063</span><span id="line-63">                </span>
<span class="source-line-no">064</span><span id="line-64">                @DialogUtils.DialogLabel("Min. distance between final corners")@DialogUtils.DialogDigits(1)</span>
<span class="source-line-no">065</span><span id="line-65">                public double dmin = 10;</span>
<span class="source-line-no">066</span><span id="line-66">                </span>
<span class="source-line-no">067</span><span id="line-67">                @DialogUtils.DialogLabel("Subpixel positioning method")</span>
<span class="source-line-no">068</span><span id="line-68">                public Method maxLocatorMethod = Method.None;</span>
<span class="source-line-no">069</span><span id="line-69">                </span>
<span class="source-line-no">070</span><span id="line-70">                @DialogUtils.DialogLabel("Corner response threshold (th)")@DialogUtils.DialogDigits(1)</span>
<span class="source-line-no">071</span><span id="line-71">                public double scoreThreshold = 100;</span>
<span class="source-line-no">072</span><span id="line-72">                </span>
<span class="source-line-no">073</span><span id="line-73">                @Override</span>
<span class="source-line-no">074</span><span id="line-74">                public boolean validate() {</span>
<span class="source-line-no">075</span><span id="line-75">                        return sigma &gt; 0 &amp;&amp; border &gt;= 0 &amp;&amp; dmin &gt;= 0 &amp;&amp; scoreThreshold &gt; 0;</span>
<span class="source-line-no">076</span><span id="line-76">                }</span>
<span class="source-line-no">077</span><span id="line-77">        }</span>
<span class="source-line-no">078</span><span id="line-78">        </span>
<span class="source-line-no">079</span><span id="line-79">        protected static final float UndefinedScoreValue = 0;   // to be returned when corner score is undefined</span>
<span class="source-line-no">080</span><span id="line-80">        </span>
<span class="source-line-no">081</span><span id="line-81">        //filter kernels (one-dim. part of separable 2D filters)</span>
<span class="source-line-no">082</span><span id="line-82">        private final static float[] hp = {2f/9, 5f/9, 2f/9};           // pre-smoothing filter kernel</span>
<span class="source-line-no">083</span><span id="line-83">        private final static float[] hd = {0.5f, 0, -0.5f};                     // first-derivative kernel</span>
<span class="source-line-no">084</span><span id="line-84">//      private final static float[] hb = {1f/64, 6f/64, 15f/64, 20f/64, 15f/64, 6f/64, 1f/64}; // original gradient blur filter kernel</span>
<span class="source-line-no">085</span><span id="line-85">        </span>
<span class="source-line-no">086</span><span id="line-86">        protected final int M, N;</span>
<span class="source-line-no">087</span><span id="line-87">        protected final Parameters params;</span>
<span class="source-line-no">088</span><span id="line-88">        protected final FloatProcessor Q;</span>
<span class="source-line-no">089</span><span id="line-89">        </span>
<span class="source-line-no">090</span><span id="line-90">        private final SubpixelMaxInterpolator maxLocator;</span>
<span class="source-line-no">091</span><span id="line-91">//      private final List&lt;Corner&gt; corners;</span>
<span class="source-line-no">092</span><span id="line-92">        </span>
<span class="source-line-no">093</span><span id="line-93">        // retained mainly for debugging</span>
<span class="source-line-no">094</span><span id="line-94">        private FloatProcessor A = null;</span>
<span class="source-line-no">095</span><span id="line-95">        private FloatProcessor B = null;</span>
<span class="source-line-no">096</span><span id="line-96">        private FloatProcessor C = null;</span>
<span class="source-line-no">097</span><span id="line-97">        </span>
<span class="source-line-no">098</span><span id="line-98">        // ---------------------------------------------------------------------------</span>
<span class="source-line-no">099</span><span id="line-99">        </span>
<span class="source-line-no">100</span><span id="line-100">        protected GradientCornerDetector(ImageProcessor ip, Parameters params) {</span>
<span class="source-line-no">101</span><span id="line-101">                this.M = ip.getWidth();</span>
<span class="source-line-no">102</span><span id="line-102">                this.N = ip.getHeight();</span>
<span class="source-line-no">103</span><span id="line-103">                this.params = params;</span>
<span class="source-line-no">104</span><span id="line-104">                this.maxLocator = params.maxLocatorMethod.getInstance();</span>
<span class="source-line-no">105</span><span id="line-105">                //(params.maxLocatorMethod == Method.None) ? null : </span>
<span class="source-line-no">106</span><span id="line-106">                        //SubpixelMaxInterpolator.getInstance(params.maxLocatorMethod);</span>
<span class="source-line-no">107</span><span id="line-107">                this.Q = makeCornerScores(ip);</span>
<span class="source-line-no">108</span><span id="line-108">        }</span>
<span class="source-line-no">109</span><span id="line-109">        </span>
<span class="source-line-no">110</span><span id="line-110">        /**</span>
<span class="source-line-no">111</span><span id="line-111">         * Calculates the corner response score for a single image position (u,v)</span>
<span class="source-line-no">112</span><span id="line-112">         * from the elements A, B, C of the local structure matrix.</span>
<span class="source-line-no">113</span><span id="line-113">         * The method should normalize the score value, such that 100</span>
<span class="source-line-no">114</span><span id="line-114">         * is returned for the default threshold value.</span>
<span class="source-line-no">115</span><span id="line-115">         * To be implemented by concrete sub-classes.</span>
<span class="source-line-no">116</span><span id="line-116">         * </span>
<span class="source-line-no">117</span><span id="line-117">         * @see HarrisCornerDetector</span>
<span class="source-line-no">118</span><span id="line-118">         * @see ShiTomasiCornerDetector</span>
<span class="source-line-no">119</span><span id="line-119">         * @param A = Ixx(u,v)</span>
<span class="source-line-no">120</span><span id="line-120">         * @param B = Iyy(u,v)</span>
<span class="source-line-no">121</span><span id="line-121">         * @param C = Ixy(u,v)</span>
<span class="source-line-no">122</span><span id="line-122">         * @return the corner score</span>
<span class="source-line-no">123</span><span id="line-123">         */</span>
<span class="source-line-no">124</span><span id="line-124">        protected abstract float getCornerScore(float A, float B, float C);</span>
<span class="source-line-no">125</span><span id="line-125">        </span>
<span class="source-line-no">126</span><span id="line-126">        // -------------------------------------------------------------</span>
<span class="source-line-no">127</span><span id="line-127">        </span>
<span class="source-line-no">128</span><span id="line-128">        private FloatProcessor makeCornerScores(ImageProcessor I) {</span>
<span class="source-line-no">129</span><span id="line-129">                FloatProcessor Ix = I.convertToFloatProcessor(); </span>
<span class="source-line-no">130</span><span id="line-130">                FloatProcessor Iy = (FloatProcessor) Ix.duplicate();</span>
<span class="source-line-no">131</span><span id="line-131">                </span>
<span class="source-line-no">132</span><span id="line-132">                // nothing really but a Sobel-type gradient:    TODO: replace by LinearFilter</span>
<span class="source-line-no">133</span><span id="line-133">                if (params.doPreFilter) {</span>
<span class="source-line-no">134</span><span id="line-134">                        convolveY(Ix, hp);                      // pre-filter Ix vertically</span>
<span class="source-line-no">135</span><span id="line-135">                        convolveX(Iy, hp);                      // pre-filter Iy horizontally</span>
<span class="source-line-no">136</span><span id="line-136">                }</span>
<span class="source-line-no">137</span><span id="line-137">                </span>
<span class="source-line-no">138</span><span id="line-138">                convolveX(Ix, hd);                              // get first derivative in x</span>
<span class="source-line-no">139</span><span id="line-139">                convolveY(Iy, hd);                              // get first derivative in y</span>
<span class="source-line-no">140</span><span id="line-140">                </span>
<span class="source-line-no">141</span><span id="line-141">                // gradient products:</span>
<span class="source-line-no">142</span><span id="line-142">                A = ImageMath.sqr(Ix);                          // A(u,v) = Ixx(u,v) = (Ix(u,v))^2</span>
<span class="source-line-no">143</span><span id="line-143">                B = ImageMath.sqr(Iy);                          // B(u,v) = Iyy(u,v) = (Iy(u,v))^2</span>
<span class="source-line-no">144</span><span id="line-144">                C = ImageMath.mult(Ix, Iy);                     // C(u,v) = Ixy(u,v) = Ix(u,v)*Iy(u,v)</span>
<span class="source-line-no">145</span><span id="line-145">                </span>
<span class="source-line-no">146</span><span id="line-146">                // blur the gradient components with a small Gaussian:</span>
<span class="source-line-no">147</span><span id="line-147">                LinearFilterSeparable gf = new GaussianFilterSeparable(params.sigma);</span>
<span class="source-line-no">148</span><span id="line-148">                gf.applyTo(A);</span>
<span class="source-line-no">149</span><span id="line-149">                gf.applyTo(B);</span>
<span class="source-line-no">150</span><span id="line-150">                gf.applyTo(C);</span>
<span class="source-line-no">151</span><span id="line-151">                </span>
<span class="source-line-no">152</span><span id="line-152">                FloatProcessor Q = new FloatProcessor(M, N);</span>
<span class="source-line-no">153</span><span id="line-153">                </span>
<span class="source-line-no">154</span><span id="line-154">                final float[] pA = (float[]) A.getPixels();</span>
<span class="source-line-no">155</span><span id="line-155">                final float[] pB = (float[]) B.getPixels();</span>
<span class="source-line-no">156</span><span id="line-156">                final float[] pC = (float[]) C.getPixels();</span>
<span class="source-line-no">157</span><span id="line-157">                final float[] pQ = (float[]) Q.getPixels();</span>
<span class="source-line-no">158</span><span id="line-158">                </span>
<span class="source-line-no">159</span><span id="line-159">                for (int i = 0; i &lt; M * N; i++) {</span>
<span class="source-line-no">160</span><span id="line-160">                        pQ[i] = getCornerScore(pA[i], pB[i], pC[i]);</span>
<span class="source-line-no">161</span><span id="line-161">                }</span>
<span class="source-line-no">162</span><span id="line-162">                </span>
<span class="source-line-no">163</span><span id="line-163">                return Q;</span>
<span class="source-line-no">164</span><span id="line-164">        }</span>
<span class="source-line-no">165</span><span id="line-165">        </span>
<span class="source-line-no">166</span><span id="line-166"></span>
<span class="source-line-no">167</span><span id="line-167">        /**</span>
<span class="source-line-no">168</span><span id="line-168">         * Returns the corner score function as a {@link FloatProcessor} object.</span>
<span class="source-line-no">169</span><span id="line-169">         * @return the score function</span>
<span class="source-line-no">170</span><span id="line-170">         */</span>
<span class="source-line-no">171</span><span id="line-171">        public FloatProcessor getQ() {</span>
<span class="source-line-no">172</span><span id="line-172">                return this.Q;</span>
<span class="source-line-no">173</span><span id="line-173">        }</span>
<span class="source-line-no">174</span><span id="line-174">        </span>
<span class="source-line-no">175</span><span id="line-175">        public FloatProcessor getA() {</span>
<span class="source-line-no">176</span><span id="line-176">                return this.A;</span>
<span class="source-line-no">177</span><span id="line-177">        }</span>
<span class="source-line-no">178</span><span id="line-178">        </span>
<span class="source-line-no">179</span><span id="line-179">        public FloatProcessor getB() {</span>
<span class="source-line-no">180</span><span id="line-180">                return this.B;</span>
<span class="source-line-no">181</span><span id="line-181">        }</span>
<span class="source-line-no">182</span><span id="line-182">        </span>
<span class="source-line-no">183</span><span id="line-183">        public FloatProcessor getC() {</span>
<span class="source-line-no">184</span><span id="line-184">                return this.C;</span>
<span class="source-line-no">185</span><span id="line-185">        }</span>
<span class="source-line-no">186</span><span id="line-186">        </span>
<span class="source-line-no">187</span><span id="line-187">        public List&lt;Corner&gt; getCorners() {</span>
<span class="source-line-no">188</span><span id="line-188">                List&lt;Corner&gt; cl = collectCorners(params.scoreThreshold, params.border);</span>
<span class="source-line-no">189</span><span id="line-189">                if (params.doCleanUp) {</span>
<span class="source-line-no">190</span><span id="line-190">                        cl = cleanupCorners(cl);</span>
<span class="source-line-no">191</span><span id="line-191">                }</span>
<span class="source-line-no">192</span><span id="line-192">                return cl;</span>
<span class="source-line-no">193</span><span id="line-193">        }</span>
<span class="source-line-no">194</span><span id="line-194">        </span>
<span class="source-line-no">195</span><span id="line-195">        // ----------------------------------------------------------</span>
<span class="source-line-no">196</span><span id="line-196">        </span>
<span class="source-line-no">197</span><span id="line-197">        /*</span>
<span class="source-line-no">198</span><span id="line-198">         * Returned samples are arranged as follows:</span>
<span class="source-line-no">199</span><span id="line-199">         *      s4 s3 s2</span>
<span class="source-line-no">200</span><span id="line-200">         *  s5 s0 s1</span>
<span class="source-line-no">201</span><span id="line-201">         *  s6 s7 s8</span>
<span class="source-line-no">202</span><span id="line-202">         */</span>
<span class="source-line-no">203</span><span id="line-203">        private float[] getNeighborhood(FloatProcessor Q, int u, int v) {</span>
<span class="source-line-no">204</span><span id="line-204">                if (u &lt;= 0 || u &gt;= M - 1 || v &lt;= 0 || v &gt;= N - 1) {</span>
<span class="source-line-no">205</span><span id="line-205">                        return null;</span>
<span class="source-line-no">206</span><span id="line-206">                } </span>
<span class="source-line-no">207</span><span id="line-207">                else {</span>
<span class="source-line-no">208</span><span id="line-208">                        final float[] q = (float[]) Q.getPixels();</span>
<span class="source-line-no">209</span><span id="line-209">                        float[] s = new float[9];</span>
<span class="source-line-no">210</span><span id="line-210">                        final int i0 = (v - 1) * M + u;</span>
<span class="source-line-no">211</span><span id="line-211">                        final int i1 = v * M + u;</span>
<span class="source-line-no">212</span><span id="line-212">                        final int i2 = (v + 1) * M + u;</span>
<span class="source-line-no">213</span><span id="line-213">                        s[0] = q[i1];</span>
<span class="source-line-no">214</span><span id="line-214">                        s[1] = q[i1 + 1];</span>
<span class="source-line-no">215</span><span id="line-215">                        s[2] = q[i0 + 1];</span>
<span class="source-line-no">216</span><span id="line-216">                        s[3] = q[i0];</span>
<span class="source-line-no">217</span><span id="line-217">                        s[4] = q[i0 - 1];</span>
<span class="source-line-no">218</span><span id="line-218">                        s[5] = q[i1 - 1];</span>
<span class="source-line-no">219</span><span id="line-219">                        s[6] = q[i2 - 1];</span>
<span class="source-line-no">220</span><span id="line-220">                        s[7] = q[i2];</span>
<span class="source-line-no">221</span><span id="line-221">                        s[8] = q[i2 + 1];</span>
<span class="source-line-no">222</span><span id="line-222">                        return s;</span>
<span class="source-line-no">223</span><span id="line-223">                }</span>
<span class="source-line-no">224</span><span id="line-224">        }</span>
<span class="source-line-no">225</span><span id="line-225">        </span>
<span class="source-line-no">226</span><span id="line-226">        private boolean isLocalMax(float[] s) {</span>
<span class="source-line-no">227</span><span id="line-227">                if (s == null) {</span>
<span class="source-line-no">228</span><span id="line-228">                        return false;</span>
<span class="source-line-no">229</span><span id="line-229">                }</span>
<span class="source-line-no">230</span><span id="line-230">                else {</span>
<span class="source-line-no">231</span><span id="line-231">                        final float s0 = s[0];</span>
<span class="source-line-no">232</span><span id="line-232">                        return  // check 8 neighbors of q0</span>
<span class="source-line-no">233</span><span id="line-233">                                        s0 &gt; s[4] &amp;&amp; s0 &gt; s[3] &amp;&amp; s0 &gt; s[2] &amp;&amp;</span>
<span class="source-line-no">234</span><span id="line-234">                                        s0 &gt; s[5] &amp;&amp;              s0 &gt; s[1] &amp;&amp; </span>
<span class="source-line-no">235</span><span id="line-235">                                        s0 &gt; s[6] &amp;&amp; s0 &gt; s[7] &amp;&amp; s0 &gt; s[8] ;</span>
<span class="source-line-no">236</span><span id="line-236">                }</span>
<span class="source-line-no">237</span><span id="line-237">        }</span>
<span class="source-line-no">238</span><span id="line-238">        </span>
<span class="source-line-no">239</span><span id="line-239">        private List&lt;Corner&gt; collectCorners(double scoreThreshold, int borderWidth) {</span>
<span class="source-line-no">240</span><span id="line-240">                float th = (float) scoreThreshold; //params.scoreThreshold;</span>
<span class="source-line-no">241</span><span id="line-241">                //int border = params.border;</span>
<span class="source-line-no">242</span><span id="line-242">                List&lt;Corner&gt; C = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">243</span><span id="line-243">                for (int v = borderWidth; v &lt; N - borderWidth; v++) {</span>
<span class="source-line-no">244</span><span id="line-244">                        for (int u = borderWidth; u &lt; M - borderWidth; u++) {</span>
<span class="source-line-no">245</span><span id="line-245">                                float[] qn = getNeighborhood(Q, u, v);</span>
<span class="source-line-no">246</span><span id="line-246">                                if (qn != null &amp;&amp; qn[0] &gt; th &amp;&amp; isLocalMax(qn)) {</span>
<span class="source-line-no">247</span><span id="line-247">                                        Corner c = makeCorner(u, v, qn);</span>
<span class="source-line-no">248</span><span id="line-248">                                        if (c != null) {</span>
<span class="source-line-no">249</span><span id="line-249">                                                C.add(c);</span>
<span class="source-line-no">250</span><span id="line-250">                                        }</span>
<span class="source-line-no">251</span><span id="line-251">                                }</span>
<span class="source-line-no">252</span><span id="line-252">                        }</span>
<span class="source-line-no">253</span><span id="line-253">                }</span>
<span class="source-line-no">254</span><span id="line-254">                return C;</span>
<span class="source-line-no">255</span><span id="line-255">        }</span>
<span class="source-line-no">256</span><span id="line-256">        </span>
<span class="source-line-no">257</span><span id="line-257">        private List&lt;Corner&gt; cleanupCorners(List&lt;Corner&gt; C) {</span>
<span class="source-line-no">258</span><span id="line-258">                final double dmin2 = sqr(params.dmin);</span>
<span class="source-line-no">259</span><span id="line-259">                // sort corners by descending q-value:</span>
<span class="source-line-no">260</span><span id="line-260">                Collections.sort(C);</span>
<span class="source-line-no">261</span><span id="line-261">                // we use an array of corners for efficiency reasons:</span>
<span class="source-line-no">262</span><span id="line-262">                Corner[] Ca = C.toArray(new Corner[C.size()]);</span>
<span class="source-line-no">263</span><span id="line-263">                List&lt;Corner&gt; Cclean = new ArrayList&lt;&gt;(C.size());</span>
<span class="source-line-no">264</span><span id="line-264">                for (int i = 0; i &lt; Ca.length; i++) {</span>
<span class="source-line-no">265</span><span id="line-265">                        Corner c0 = Ca[i];              // get next strongest corner</span>
<span class="source-line-no">266</span><span id="line-266">                        if (c0 != null) {</span>
<span class="source-line-no">267</span><span id="line-267">                                Cclean.add(c0);</span>
<span class="source-line-no">268</span><span id="line-268">                                // delete all remaining corners cj too close to c0:</span>
<span class="source-line-no">269</span><span id="line-269">                                for (int j = i + 1; j &lt; Ca.length; j++) {</span>
<span class="source-line-no">270</span><span id="line-270">                                        Corner cj = Ca[j];</span>
<span class="source-line-no">271</span><span id="line-271">                                        if (cj != null &amp;&amp; c0.distanceSq(cj) &lt; dmin2)</span>
<span class="source-line-no">272</span><span id="line-272">                                                Ca[j] = null;   //delete corner cj from C</span>
<span class="source-line-no">273</span><span id="line-273">                                }</span>
<span class="source-line-no">274</span><span id="line-274">                        }</span>
<span class="source-line-no">275</span><span id="line-275">                }</span>
<span class="source-line-no">276</span><span id="line-276">                return Cclean;</span>
<span class="source-line-no">277</span><span id="line-277">        }</span>
<span class="source-line-no">278</span><span id="line-278">        </span>
<span class="source-line-no">279</span><span id="line-279">        /**</span>
<span class="source-line-no">280</span><span id="line-280">         * Creates a new {@link Corner} instance. Performs sub-pixel</span>
<span class="source-line-no">281</span><span id="line-281">         * position refinement if a {@link #maxLocator} is defined.</span>
<span class="source-line-no">282</span><span id="line-282">         * @param u the corner's horizontal position (int)</span>
<span class="source-line-no">283</span><span id="line-283">         * @param v the corner's vertical position (int)</span>
<span class="source-line-no">284</span><span id="line-284">         * @param qn the 9 corner scores in the 3x3 neighborhood</span>
<span class="source-line-no">285</span><span id="line-285">         * @return a new {@link Corner} instance</span>
<span class="source-line-no">286</span><span id="line-286">         */</span>
<span class="source-line-no">287</span><span id="line-287">        private Corner makeCorner(int u, int v, float[] qn) {</span>
<span class="source-line-no">288</span><span id="line-288">                if (maxLocator == null) {</span>
<span class="source-line-no">289</span><span id="line-289">                        // no sub-pixel refinement, use original integer coordinates</span>
<span class="source-line-no">290</span><span id="line-290">                        return new Corner(u, v, qn[0]);</span>
<span class="source-line-no">291</span><span id="line-291">                }</span>
<span class="source-line-no">292</span><span id="line-292">                else {</span>
<span class="source-line-no">293</span><span id="line-293">                        // do sub-pixel refinement</span>
<span class="source-line-no">294</span><span id="line-294">                        float[] xyz = maxLocator.getMax(qn);</span>
<span class="source-line-no">295</span><span id="line-295">                        return (xyz == null) ? null : new Corner(u + xyz[0], v + xyz[1], xyz[2]);</span>
<span class="source-line-no">296</span><span id="line-296">                }</span>
<span class="source-line-no">297</span><span id="line-297">        }</span>
<span class="source-line-no">298</span><span id="line-298">        </span>
<span class="source-line-no">299</span><span id="line-299">        </span>
<span class="source-line-no">300</span><span id="line-300">}</span>




























































</pre>
</div>
</main>
</body>
</html>
